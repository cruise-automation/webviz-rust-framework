"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwrf"] = self["webpackChunkwrf"] || []).push([["wrf_buffer_ts"],{

/***/ "./common.ts":
/*!*******************!*\
  !*** ./common.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rpc\": () => (/* binding */ Rpc),\n/* harmony export */   \"mutexLock\": () => (/* binding */ mutexLock),\n/* harmony export */   \"mutexUnlock\": () => (/* binding */ mutexUnlock),\n/* harmony export */   \"TW_SAB_MUTEX_PTR\": () => (/* binding */ TW_SAB_MUTEX_PTR),\n/* harmony export */   \"TW_SAB_MESSAGE_COUNT_PTR\": () => (/* binding */ TW_SAB_MESSAGE_COUNT_PTR),\n/* harmony export */   \"initTaskWorkerSab\": () => (/* binding */ initTaskWorkerSab),\n/* harmony export */   \"initThreadLocalStorageMainWorker\": () => (/* binding */ initThreadLocalStorageMainWorker),\n/* harmony export */   \"makeThreadLocalStorageAndStackDataOnExistingThread\": () => (/* binding */ makeThreadLocalStorageAndStackDataOnExistingThread),\n/* harmony export */   \"initThreadLocalStorageAndStackOtherWorkers\": () => (/* binding */ initThreadLocalStorageAndStackOtherWorkers),\n/* harmony export */   \"copyArrayToRustBuffer\": () => (/* binding */ copyArrayToRustBuffer),\n/* harmony export */   \"getWrfParamType\": () => (/* binding */ getWrfParamType),\n/* harmony export */   \"createWasmBuffer\": () => (/* binding */ createWasmBuffer),\n/* harmony export */   \"makeZerdeBuilder\": () => (/* binding */ makeZerdeBuilder),\n/* harmony export */   \"getWasmEnv\": () => (/* binding */ getWasmEnv),\n/* harmony export */   \"transformParamsFromRustImpl\": () => (/* binding */ transformParamsFromRustImpl),\n/* harmony export */   \"assertNotNull\": () => (/* binding */ assertNotNull)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n/* harmony import */ var _zerde__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zerde */ \"./zerde.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// This file should only be imported by WebWorkers\n/// <reference lib=\"WebWorker\" />\n\n\n\nconst RESPONSE = \"$$RESPONSE\";\nconst ERROR = \"$$ERROR\";\n// helper function to create linked channels for testing\nfunction _createLinkedChannels() {\n    const local = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (remote.onmessage) {\n                remote.onmessage(ev);\n            }\n        },\n    };\n    const remote = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (local.onmessage) {\n                local.onmessage(ev);\n            }\n        },\n    };\n    return { local, remote };\n}\n// This class allows you to hook up bi-directional async calls across web-worker\n// boundaries where a single call to or from a worker can 'wait' on the response.\n// Errors in receivers are propigated back to the caller as a rejection.\n// It also supports returning transferrables over the web-worker postMessage api,\n// which was the main shortcomming with the worker-rpc npm module.\n// To attach rpc to an instance of a worker in the main thread:\n//   const rpc = new Rpc(workerInstace);\n// To attach rpc within an a web worker:\n//   const rpc = new Rpc(global);\n// Check out the tests for more examples.\nclass Rpc {\n    constructor(channel) {\n        this._messageId = 0;\n        this._pendingCallbacks = {};\n        this._receivers = new Map();\n        this._onChannelMessage = (ev) => {\n            const { id, topic, data } = ev.data;\n            if (topic === RESPONSE) {\n                this._pendingCallbacks[id](ev.data);\n                delete this._pendingCallbacks[id];\n                return;\n            }\n            // invoke the receive handler in a promise so if it throws synchronously we can reject\n            new Promise((resolve) => {\n                const handler = this._receivers.get(topic);\n                if (!handler) {\n                    throw new Error(`no receiver registered for ${topic}`);\n                }\n                // This works both when `handler` returns a value or a Promise.\n                resolve(handler(data));\n            })\n                .then((result) => {\n                if (!result) {\n                    this.postMessage({ topic: RESPONSE, id }, []);\n                    return;\n                }\n                const transferrables = result[Rpc.transferrables];\n                delete result[Rpc.transferrables];\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: result,\n                };\n                this.postMessage(message, transferrables);\n            })\n                .catch((err) => {\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: {\n                        [ERROR]: true,\n                        name: err.name,\n                        message: err.message,\n                        stack: err.stack,\n                    },\n                };\n                this.postMessage(message, []);\n            });\n        };\n        this._channel = channel;\n        if (this._channel.onmessage) {\n            throw new Error(\"channel.onmessage is already set. Can only use one Rpc instance per channel.\");\n        }\n        this._channel.onmessage = this._onChannelMessage;\n    }\n    // send a message across the rpc boundary to a receiver on the other side\n    // this returns a promise for the receiver's response.  If there is no registered\n    // receiver for the given topic, this method throws\n    send(topic, data, transfer) {\n        const id = this._messageId++;\n        const message = { topic, id, data };\n        const result = new Promise((resolve, reject) => {\n            this._pendingCallbacks[id] = (info) => {\n                if (info.data && info.data[ERROR]) {\n                    const error = new Error(info.data.message);\n                    error.name = info.data.name;\n                    error.stack = info.data.stack;\n                    reject(error);\n                }\n                else {\n                    resolve(info.data);\n                }\n            };\n        });\n        this.postMessage(message, transfer);\n        return result;\n    }\n    // register a receiver for a given message on a topic\n    // only one receiver can be registered per topic and currently\n    // 'deregistering' a receiver is not supported since this is not common\n    receive(topic, handler) {\n        if (this._receivers.has(topic)) {\n            throw new Error(`Receiver already registered for topic: ${topic}`);\n        }\n        this._receivers.set(topic, handler);\n    }\n    postMessage(message, transfer) {\n        try {\n            this._channel.postMessage(message, transfer);\n        }\n        catch (e) {\n            console.error(\"Rpc postMessage call itself failed: \", e);\n        }\n    }\n}\nRpc.transferrables = \"$$TRANSFERRABLES\";\n////////////////////////////////////////////////////////////////\n// Mutex\n////////////////////////////////////////////////////////////////\nconst MUTEX_UNLOCKED = 0;\nconst MUTEX_LOCKED = 1;\nconst mutexLock = (sabi32, offset) => {\n    // This needs to be in a loop, because between the `wait` and `compareExchange` another thread might\n    // take the Mutex.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (Atomics.compareExchange(sabi32, offset, MUTEX_UNLOCKED, MUTEX_LOCKED) ==\n            MUTEX_UNLOCKED) {\n            return;\n        }\n        Atomics.wait(sabi32, offset, MUTEX_LOCKED);\n    }\n};\nconst mutexUnlock = (sabi32, offset) => {\n    if (Atomics.compareExchange(sabi32, offset, MUTEX_LOCKED, MUTEX_UNLOCKED) !=\n        MUTEX_LOCKED) {\n        throw new Error(\"Called mutex_unlock on an already unlocked mutex\");\n    }\n    Atomics.notify(sabi32, offset, 1);\n};\n////////////////////////////////////////////////////////////////\n// Task worker\n////////////////////////////////////////////////////////////////\nconst TW_SAB_MUTEX_PTR = 0;\nconst TW_SAB_MESSAGE_COUNT_PTR = 1;\n// Initialize a SharedArrayBuffer used to communicate with task_worker.ts. This\n// is a one-way communication channel; use pointers into `memory` for communicating\n// information back.\n//\n// We use this because we typically can't use `postMessage`; see task_worker.ts\n// for more details.\n//\n// Format:\n// * i32 (4 bytes)         - read/write mutex\n// * i32 (4 bytes)         - number of messages in queue (notify on this to wake up the task worker - it will\n//                           read this before taking a mutex, but then reread it after taking the mutex)\n// * n * u32 (n * 4 bytes) - pointers to messages serialized with `ZerdeBuilder`\nconst initTaskWorkerSab = () => {\n    const bufferSizeBytes = 10000;\n    const taskWorkerSab = new SharedArrayBuffer(bufferSizeBytes);\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    taskWorkerSabi32[TW_SAB_MUTEX_PTR] = MUTEX_UNLOCKED;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = 0;\n    return taskWorkerSab;\n};\n// Append a new message pointer to the SharedArrayBuffer used by task_worker.ts,\n// and wake it up so it can process this new message (unless it's currently in polling\n// mode, in that case the `Atomics.notify` will just not do anything).\nconst sendTaskWorkerMessage = (taskWorkerSab, twMessagePtr) => {\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    mutexLock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    const currentNumberOfMessages = taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR];\n    // Use unsigned numbers for the actual pointer, since they can be >2GB.\n    new Uint32Array(taskWorkerSab)[currentNumberOfMessages + 2] = twMessagePtr;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = currentNumberOfMessages + 1;\n    mutexUnlock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    Atomics.notify(taskWorkerSabi32, 1);\n};\n////////////////////////////////////////////////////////////////\n// Wasm Thread initialization\n////////////////////////////////////////////////////////////////\n// Threads in WebAssembly! They are.. fun! Here's what happens.\n//\n// The first Wasm instance we start is in the main worker. It does the following:\n// - It initializes static memory using `__wasm_init_memory`, which is automatically set\n//   by LLVM as the special \"start\" function.\n// - It already has memory allocated for the \"shadow stack\". This is like any stack in a\n//   native program, but in WebAssembly it's called the \"shadow stack\" because WebAssembly\n//   itself also has a notion of a stack built-in. It is however not suitable for all\n//   kinds of data, which is why we need another separate stack.\n// - We allocate Thread Local Storage (TLS) by allocating some memory on the heap (an\n//   operation which by itself should not require TLS; otherwise we'd have a Catch-22\n//   situation..), and calling `initThreadLocalStorageMainWorker` with it.\n//\n// Then, when we make any other WebAssembly threads (e.g. in our own WebWorkers, or in\n// the WebWorkers of users), we do the following:\n// - `__wasm_init_memory` is again called automatically, but will be skipped, since an\n//   (atomic) flag has been set not to initialize static memory again.\n// - We need to initialize memory for both the shadow stack and the Thread Local\n//   Storage (TLS), using `makeThreadLocalStorageAndStackDataOnExistingThread`. We do this\n//   by allocating memory on the heap on an already initialized thread, since allocating memory DOES\n//   require the shadow stack to be initialized.\n// - We then use this memory for both the TLS (on the lower side) and the shadow stack\n//   (on the upper side, since it moves downward), using `initThreadLocalStorageAndStackOtherWorkers`.\n//\n// TODO(JP): This currently leaks memory since we never deallocate the TLS/shadow stack!\n//\n// TODO(JP): Even if we do deallocate the memory, there is currently no way to call TLS\n// destructors; so we'd still leak memory. See https://github.com/rust-lang/rust/issues/77839\n// The \"shadow stack\" size for new threads. Note that the main thread will\n// keep using its own shadow stack size.\nconst WASM_STACK_SIZE_BYTES = 2 * 1024 * 1024; // 2 MB\n// For the main worker, we only need to initialize Thread Local Storage (TLS).\nconst initThreadLocalStorageMainWorker = (wasmExports) => {\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(wasmExports.__tls_size.value));\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    wasmExports.__wasm_init_tls(Number(ptr));\n};\n// For non-main workers, we need to allocate enough data for Thread Local Storage (TLS)\n// and the \"shadow stack\". We allocate this data in the main worker, and then send the\n// pointer + size to other workers.\n//\n// This is easier than trying to allocate the appropriate amount of data in the other\n// itself, which is possible (e.g. using memory.grow) but kind of cumbersome.\nconst makeThreadLocalStorageAndStackDataOnExistingThread = (wasmExports) => {\n    // Align size to 64 bits / 8 bytes.\n    const size = Math.ceil((wasmExports.__tls_size.value + WASM_STACK_SIZE_BYTES) / 8) * 8;\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(size));\n    return { ptr, size };\n};\n// Set the shadow stack pointer and initialize thet Thread Local Storage (TLS).\n//\n// Note that the TLS sits on the lower side of the memory, wheras the shadow stack\n// starts on the upper side of the memory and grows downwards.\n//\n// TODO(JP): __wasm_init_tls takes a Number, which might not work when it is >2GB.\nconst initThreadLocalStorageAndStackOtherWorkers = (wasmExports, tlsAndStackData) => {\n    // Start the shadow stack pointer on the upper side of the memory, though subtract\n    // 8 so we don't overwrite the byte right after the memory, while still keeping it\n    // 64-bit aligned. TODO(JP): Is the 64-bit alignment necessary for the shadow stack?\n    wasmExports.__stack_pointer.value =\n        Number(tlsAndStackData.ptr) + tlsAndStackData.size - 8;\n    wasmExports.__wasm_init_tls(\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    Number(tlsAndStackData.ptr));\n};\n////////////////////////////////////////////////////////////////\n// Common wasm functions\n////////////////////////////////////////////////////////////////\nconst copyArrayToRustBuffer = (inputBuffer, outputBuffer, outputPtr) => {\n    // should be the same type as inputBuffer\n    // @ts-ignore: constructor is getting typed as Function instead of a constructor\n    new inputBuffer.constructor(outputBuffer, outputPtr, inputBuffer.length).set(inputBuffer);\n};\nconst getWrfParamType = (array, readonly) => {\n    if (array instanceof Uint8Array) {\n        return readonly ? _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyU8Buffer : _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.U8Buffer;\n    }\n    else if (array instanceof Float32Array) {\n        return readonly ? _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyF32Buffer : _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.F32Buffer;\n    }\n    else {\n        throw new Error(\"Invalid array type\");\n    }\n};\nconst createWasmBuffer = (memory, exports, data) => {\n    const vecPtr = Number(exports.allocWasmVec(BigInt(data.byteLength)));\n    copyArrayToRustBuffer(data, memory.buffer, vecPtr);\n    return vecPtr;\n};\nconst makeZerdeBuilder = (memory, wasmExports) => {\n    const slots = 1024;\n    // We have get memory.buffer *after* calling `allocWasmMessage`, because\n    // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n    const byteOffset = Number(wasmExports.allocWasmMessage(BigInt(slots * 4)));\n    return new _zerde__WEBPACK_IMPORTED_MODULE_2__.ZerdeBuilder({\n        buffer: memory.buffer,\n        byteOffset: byteOffset,\n        slots,\n        growCallback: (_buffer, oldByteOffset, newBytes) => {\n            const newByteOffset = Number(wasmExports.reallocWasmMessage(BigInt(oldByteOffset), BigInt(newBytes)));\n            // We have get memory.buffer *after* calling `reallocWasmMessage`, because\n            // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n            return { buffer: memory.buffer, byteOffset: newByteOffset };\n        },\n    });\n};\nconst getWasmEnv = ({ getExports, memory, taskWorkerSab, fileHandles, sendEventFromAnyThread, threadSpawn, baseUri, }) => {\n    const fileReaderSync = new FileReaderSync();\n    const parseString = (ptr, len) => {\n        let out = \"\";\n        // Can't use TextDecoder here since it doesn't work with SharedArrayBuffer.\n        // TODO(JP): If it becomes important enough, we can see if making a copy to a regular\n        // ArrayBuffer and then using TextDecoder is faster than what we do here.\n        const array = new Uint32Array(memory.buffer, ptr, len);\n        for (let i = 0; i < len; i++) {\n            out += String.fromCharCode(array[i]);\n        }\n        return out;\n    };\n    return {\n        memory,\n        _consoleLog: (charsPtr, len, error) => {\n            const out = parseString(parseInt(charsPtr), parseInt(len));\n            if (error) {\n                console.error(out);\n            }\n            else {\n                console.log(out);\n            }\n        },\n        readUserFileRange: (userFileId, bufPtr, bufLen, fileOffset) => {\n            const file = fileHandles[userFileId];\n            const start = Number(fileOffset);\n            const end = start + Number(bufLen);\n            if (file.lastReadStart <= start && start < file.lastReadEnd) {\n                console.warn(`Read start (${start}) fell in the range of the last read (${file.lastReadStart}-${file.lastReadEnd}); ` +\n                    \"this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.\");\n            }\n            file.lastReadStart = start;\n            file.lastReadEnd = end;\n            // TODO(JP): This creates a new buffer instead of reading directly into the wasm memory.\n            // Maybe we can avoid this by using a stream with a ReadableStreamBYOBReader, but that is\n            // asynchronous, so we'd have to do a dance with another thread and atomics and all that,\n            // and I don't know if that overhead would be worth it..\n            const buffer = fileReaderSync.readAsArrayBuffer(file.file.slice(start, end));\n            copyArrayToRustBuffer(new Uint8Array(buffer), memory.buffer, Number(bufPtr));\n            return BigInt(buffer.byteLength);\n        },\n        performanceNow: () => {\n            return performance.now();\n        },\n        threadSpawn: (ctxPtr) => {\n            threadSpawn(ctxPtr);\n        },\n        _sendEventFromAnyThread: (eventPtr) => {\n            sendEventFromAnyThread(eventPtr);\n        },\n        readUrlSync: (urlPtr, urlLen, bufPtrOut, bufLenOut) => {\n            const url = parseString(urlPtr, urlLen);\n            const request = new XMLHttpRequest();\n            request.responseType = \"arraybuffer\";\n            request.open(\"GET\", new URL(url, baseUri).href, false /* synchronous */);\n            request.send(null);\n            if (request.status === 200) {\n                const exports = getExports();\n                const outputBufPtr = createWasmBuffer(memory, exports, new Uint8Array(request.response));\n                new Uint32Array(memory.buffer, bufPtrOut, 1)[0] = outputBufPtr;\n                new Uint32Array(memory.buffer, bufLenOut, 1)[0] =\n                    request.response.byteLength;\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        },\n        randomU64: () => new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],\n        sendTaskWorkerMessage: (twMessagePtr) => {\n            sendTaskWorkerMessage(taskWorkerSab, parseInt(twMessagePtr));\n        },\n    };\n};\nfunction transformParamsFromRustImpl(memory, destructor, mutableDestructor, params) {\n    return params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else {\n            const wrfBuffer = (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.getWrfBufferWasm)(memory, param, destructor, mutableDestructor);\n            if (param.paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.String) {\n                throw new Error(\"WrfParam buffer type called with string paramType\");\n            }\n            // These are actually WrfArray types, since we overwrite TypedArrays in overwriteTypedArraysWithWrfArrays()\n            const ArrayConstructor = {\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.U8Buffer]: Uint8Array,\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyU8Buffer]: Uint8Array,\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.F32Buffer]: Float32Array,\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyF32Buffer]: Float32Array,\n            }[param.paramType];\n            return (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.getCachedWrfBuffer)(wrfBuffer, new ArrayConstructor(wrfBuffer, param.bufferPtr, param.bufferLen / ArrayConstructor.BYTES_PER_ELEMENT));\n        }\n    });\n}\nfunction assertNotNull(value, objectName = \"Value\") {\n    if (value === null || value === undefined) {\n        throw new Error(`Assertion failed: ${objectName} is null`);\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21tb24udHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vY29tbW9uLnRzPzIwYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFRoaXMgZmlsZSBzaG91bGQgb25seSBiZSBpbXBvcnRlZCBieSBXZWJXb3JrZXJzXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJXZWJXb3JrZXJcIiAvPlxuaW1wb3J0IHsgV3JmUGFyYW1UeXBlLCB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRDYWNoZWRXcmZCdWZmZXIsIGdldFdyZkJ1ZmZlcldhc20gfSBmcm9tIFwiLi93cmZfYnVmZmVyXCI7XG5pbXBvcnQgeyBaZXJkZUJ1aWxkZXIgfSBmcm9tIFwiLi96ZXJkZVwiO1xuY29uc3QgUkVTUE9OU0UgPSBcIiQkUkVTUE9OU0VcIjtcbmNvbnN0IEVSUk9SID0gXCIkJEVSUk9SXCI7XG4vLyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGxpbmtlZCBjaGFubmVscyBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gX2NyZWF0ZUxpbmtlZENoYW5uZWxzKCkge1xuICAgIGNvbnN0IGxvY2FsID0ge1xuICAgICAgICBvbm1lc3NhZ2UsXG4gICAgICAgIHBvc3RNZXNzYWdlKGRhdGEsIF90cmFuc2Zlcikge1xuICAgICAgICAgICAgY29uc3QgZXYgPSBuZXcgTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCB7IGRhdGEgfSk7XG4gICAgICAgICAgICBpZiAocmVtb3RlLm9ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJlbW90ZS5vbm1lc3NhZ2UoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgY29uc3QgcmVtb3RlID0ge1xuICAgICAgICBvbm1lc3NhZ2UsXG4gICAgICAgIHBvc3RNZXNzYWdlKGRhdGEsIF90cmFuc2Zlcikge1xuICAgICAgICAgICAgY29uc3QgZXYgPSBuZXcgTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCB7IGRhdGEgfSk7XG4gICAgICAgICAgICBpZiAobG9jYWwub25tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgbG9jYWwub25tZXNzYWdlKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB7IGxvY2FsLCByZW1vdGUgfTtcbn1cbi8vIFRoaXMgY2xhc3MgYWxsb3dzIHlvdSB0byBob29rIHVwIGJpLWRpcmVjdGlvbmFsIGFzeW5jIGNhbGxzIGFjcm9zcyB3ZWItd29ya2VyXG4vLyBib3VuZGFyaWVzIHdoZXJlIGEgc2luZ2xlIGNhbGwgdG8gb3IgZnJvbSBhIHdvcmtlciBjYW4gJ3dhaXQnIG9uIHRoZSByZXNwb25zZS5cbi8vIEVycm9ycyBpbiByZWNlaXZlcnMgYXJlIHByb3BpZ2F0ZWQgYmFjayB0byB0aGUgY2FsbGVyIGFzIGEgcmVqZWN0aW9uLlxuLy8gSXQgYWxzbyBzdXBwb3J0cyByZXR1cm5pbmcgdHJhbnNmZXJyYWJsZXMgb3ZlciB0aGUgd2ViLXdvcmtlciBwb3N0TWVzc2FnZSBhcGksXG4vLyB3aGljaCB3YXMgdGhlIG1haW4gc2hvcnRjb21taW5nIHdpdGggdGhlIHdvcmtlci1ycGMgbnBtIG1vZHVsZS5cbi8vIFRvIGF0dGFjaCBycGMgdG8gYW4gaW5zdGFuY2Ugb2YgYSB3b3JrZXIgaW4gdGhlIG1haW4gdGhyZWFkOlxuLy8gICBjb25zdCBycGMgPSBuZXcgUnBjKHdvcmtlckluc3RhY2UpO1xuLy8gVG8gYXR0YWNoIHJwYyB3aXRoaW4gYW4gYSB3ZWIgd29ya2VyOlxuLy8gICBjb25zdCBycGMgPSBuZXcgUnBjKGdsb2JhbCk7XG4vLyBDaGVjayBvdXQgdGhlIHRlc3RzIGZvciBtb3JlIGV4YW1wbGVzLlxuZXhwb3J0IGNsYXNzIFJwYyB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCkge1xuICAgICAgICB0aGlzLl9tZXNzYWdlSWQgPSAwO1xuICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0ge307XG4gICAgICAgIHRoaXMuX3JlY2VpdmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fb25DaGFubmVsTWVzc2FnZSA9IChldikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgdG9waWMsIGRhdGEgfSA9IGV2LmRhdGE7XG4gICAgICAgICAgICBpZiAodG9waWMgPT09IFJFU1BPTlNFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrc1tpZF0oZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdDYWxsYmFja3NbaWRdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGludm9rZSB0aGUgcmVjZWl2ZSBoYW5kbGVyIGluIGEgcHJvbWlzZSBzbyBpZiBpdCB0aHJvd3Mgc3luY2hyb25vdXNseSB3ZSBjYW4gcmVqZWN0XG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9yZWNlaXZlcnMuZ2V0KHRvcGljKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyByZWNlaXZlciByZWdpc3RlcmVkIGZvciAke3RvcGljfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdvcmtzIGJvdGggd2hlbiBgaGFuZGxlcmAgcmV0dXJucyBhIHZhbHVlIG9yIGEgUHJvbWlzZS5cbiAgICAgICAgICAgICAgICByZXNvbHZlKGhhbmRsZXIoZGF0YSkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3N0TWVzc2FnZSh7IHRvcGljOiBSRVNQT05TRSwgaWQgfSwgW10pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVycmFibGVzID0gcmVzdWx0W1JwYy50cmFuc2ZlcnJhYmxlc107XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtScGMudHJhbnNmZXJyYWJsZXNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljOiBSRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJyYWJsZXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljOiBSRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtFUlJPUl06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlcnIubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IGVyci5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2UobWVzc2FnZSwgW10pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICBpZiAodGhpcy5fY2hhbm5lbC5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwub25tZXNzYWdlIGlzIGFscmVhZHkgc2V0LiBDYW4gb25seSB1c2Ugb25lIFJwYyBpbnN0YW5jZSBwZXIgY2hhbm5lbC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbm1lc3NhZ2UgPSB0aGlzLl9vbkNoYW5uZWxNZXNzYWdlO1xuICAgIH1cbiAgICAvLyBzZW5kIGEgbWVzc2FnZSBhY3Jvc3MgdGhlIHJwYyBib3VuZGFyeSB0byBhIHJlY2VpdmVyIG9uIHRoZSBvdGhlciBzaWRlXG4gICAgLy8gdGhpcyByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlY2VpdmVyJ3MgcmVzcG9uc2UuICBJZiB0aGVyZSBpcyBubyByZWdpc3RlcmVkXG4gICAgLy8gcmVjZWl2ZXIgZm9yIHRoZSBnaXZlbiB0b3BpYywgdGhpcyBtZXRob2QgdGhyb3dzXG4gICAgc2VuZCh0b3BpYywgZGF0YSwgdHJhbnNmZXIpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLl9tZXNzYWdlSWQrKztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHsgdG9waWMsIGlkLCBkYXRhIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3NbaWRdID0gKGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5kYXRhICYmIGluZm8uZGF0YVtFUlJPUl0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoaW5mby5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gaW5mby5kYXRhLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gaW5mby5kYXRhLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbmZvLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gcmVnaXN0ZXIgYSByZWNlaXZlciBmb3IgYSBnaXZlbiBtZXNzYWdlIG9uIGEgdG9waWNcbiAgICAvLyBvbmx5IG9uZSByZWNlaXZlciBjYW4gYmUgcmVnaXN0ZXJlZCBwZXIgdG9waWMgYW5kIGN1cnJlbnRseVxuICAgIC8vICdkZXJlZ2lzdGVyaW5nJyBhIHJlY2VpdmVyIGlzIG5vdCBzdXBwb3J0ZWQgc2luY2UgdGhpcyBpcyBub3QgY29tbW9uXG4gICAgcmVjZWl2ZSh0b3BpYywgaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5fcmVjZWl2ZXJzLmhhcyh0b3BpYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZXIgYWxyZWFkeSByZWdpc3RlcmVkIGZvciB0b3BpYzogJHt0b3BpY31gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWNlaXZlcnMuc2V0KHRvcGljLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgcG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5uZWwucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUnBjIHBvc3RNZXNzYWdlIGNhbGwgaXRzZWxmIGZhaWxlZDogXCIsIGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuUnBjLnRyYW5zZmVycmFibGVzID0gXCIkJFRSQU5TRkVSUkFCTEVTXCI7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNdXRleFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuY29uc3QgTVVURVhfVU5MT0NLRUQgPSAwO1xuY29uc3QgTVVURVhfTE9DS0VEID0gMTtcbmV4cG9ydCBjb25zdCBtdXRleExvY2sgPSAoc2FiaTMyLCBvZmZzZXQpID0+IHtcbiAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGluIGEgbG9vcCwgYmVjYXVzZSBiZXR3ZWVuIHRoZSBgd2FpdGAgYW5kIGBjb21wYXJlRXhjaGFuZ2VgIGFub3RoZXIgdGhyZWFkIG1pZ2h0XG4gICAgLy8gdGFrZSB0aGUgTXV0ZXguXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShzYWJpMzIsIG9mZnNldCwgTVVURVhfVU5MT0NLRUQsIE1VVEVYX0xPQ0tFRCkgPT1cbiAgICAgICAgICAgIE1VVEVYX1VOTE9DS0VEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQXRvbWljcy53YWl0KHNhYmkzMiwgb2Zmc2V0LCBNVVRFWF9MT0NLRUQpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbXV0ZXhVbmxvY2sgPSAoc2FiaTMyLCBvZmZzZXQpID0+IHtcbiAgICBpZiAoQXRvbWljcy5jb21wYXJlRXhjaGFuZ2Uoc2FiaTMyLCBvZmZzZXQsIE1VVEVYX0xPQ0tFRCwgTVVURVhfVU5MT0NLRUQpICE9XG4gICAgICAgIE1VVEVYX0xPQ0tFRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgbXV0ZXhfdW5sb2NrIG9uIGFuIGFscmVhZHkgdW5sb2NrZWQgbXV0ZXhcIik7XG4gICAgfVxuICAgIEF0b21pY3Mubm90aWZ5KHNhYmkzMiwgb2Zmc2V0LCAxKTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUYXNrIHdvcmtlclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IFRXX1NBQl9NVVRFWF9QVFIgPSAwO1xuZXhwb3J0IGNvbnN0IFRXX1NBQl9NRVNTQUdFX0NPVU5UX1BUUiA9IDE7XG4vLyBJbml0aWFsaXplIGEgU2hhcmVkQXJyYXlCdWZmZXIgdXNlZCB0byBjb21tdW5pY2F0ZSB3aXRoIHRhc2tfd29ya2VyLnRzLiBUaGlzXG4vLyBpcyBhIG9uZS13YXkgY29tbXVuaWNhdGlvbiBjaGFubmVsOyB1c2UgcG9pbnRlcnMgaW50byBgbWVtb3J5YCBmb3IgY29tbXVuaWNhdGluZ1xuLy8gaW5mb3JtYXRpb24gYmFjay5cbi8vXG4vLyBXZSB1c2UgdGhpcyBiZWNhdXNlIHdlIHR5cGljYWxseSBjYW4ndCB1c2UgYHBvc3RNZXNzYWdlYDsgc2VlIHRhc2tfd29ya2VyLnRzXG4vLyBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIEZvcm1hdDpcbi8vICogaTMyICg0IGJ5dGVzKSAgICAgICAgIC0gcmVhZC93cml0ZSBtdXRleFxuLy8gKiBpMzIgKDQgYnl0ZXMpICAgICAgICAgLSBudW1iZXIgb2YgbWVzc2FnZXMgaW4gcXVldWUgKG5vdGlmeSBvbiB0aGlzIHRvIHdha2UgdXAgdGhlIHRhc2sgd29ya2VyIC0gaXQgd2lsbFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkIHRoaXMgYmVmb3JlIHRha2luZyBhIG11dGV4LCBidXQgdGhlbiByZXJlYWQgaXQgYWZ0ZXIgdGFraW5nIHRoZSBtdXRleClcbi8vICogbiAqIHUzMiAobiAqIDQgYnl0ZXMpIC0gcG9pbnRlcnMgdG8gbWVzc2FnZXMgc2VyaWFsaXplZCB3aXRoIGBaZXJkZUJ1aWxkZXJgXG5leHBvcnQgY29uc3QgaW5pdFRhc2tXb3JrZXJTYWIgPSAoKSA9PiB7XG4gICAgY29uc3QgYnVmZmVyU2l6ZUJ5dGVzID0gMTAwMDA7XG4gICAgY29uc3QgdGFza1dvcmtlclNhYiA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihidWZmZXJTaXplQnl0ZXMpO1xuICAgIGNvbnN0IHRhc2tXb3JrZXJTYWJpMzIgPSBuZXcgSW50MzJBcnJheSh0YXNrV29ya2VyU2FiKTtcbiAgICB0YXNrV29ya2VyU2FiaTMyW1RXX1NBQl9NVVRFWF9QVFJdID0gTVVURVhfVU5MT0NLRUQ7XG4gICAgdGFza1dvcmtlclNhYmkzMltUV19TQUJfTUVTU0FHRV9DT1VOVF9QVFJdID0gMDtcbiAgICByZXR1cm4gdGFza1dvcmtlclNhYjtcbn07XG4vLyBBcHBlbmQgYSBuZXcgbWVzc2FnZSBwb2ludGVyIHRvIHRoZSBTaGFyZWRBcnJheUJ1ZmZlciB1c2VkIGJ5IHRhc2tfd29ya2VyLnRzLFxuLy8gYW5kIHdha2UgaXQgdXAgc28gaXQgY2FuIHByb2Nlc3MgdGhpcyBuZXcgbWVzc2FnZSAodW5sZXNzIGl0J3MgY3VycmVudGx5IGluIHBvbGxpbmdcbi8vIG1vZGUsIGluIHRoYXQgY2FzZSB0aGUgYEF0b21pY3Mubm90aWZ5YCB3aWxsIGp1c3Qgbm90IGRvIGFueXRoaW5nKS5cbmNvbnN0IHNlbmRUYXNrV29ya2VyTWVzc2FnZSA9ICh0YXNrV29ya2VyU2FiLCB0d01lc3NhZ2VQdHIpID0+IHtcbiAgICBjb25zdCB0YXNrV29ya2VyU2FiaTMyID0gbmV3IEludDMyQXJyYXkodGFza1dvcmtlclNhYik7XG4gICAgbXV0ZXhMb2NrKHRhc2tXb3JrZXJTYWJpMzIsIFRXX1NBQl9NVVRFWF9QVFIpO1xuICAgIGNvbnN0IGN1cnJlbnROdW1iZXJPZk1lc3NhZ2VzID0gdGFza1dvcmtlclNhYmkzMltUV19TQUJfTUVTU0FHRV9DT1VOVF9QVFJdO1xuICAgIC8vIFVzZSB1bnNpZ25lZCBudW1iZXJzIGZvciB0aGUgYWN0dWFsIHBvaW50ZXIsIHNpbmNlIHRoZXkgY2FuIGJlID4yR0IuXG4gICAgbmV3IFVpbnQzMkFycmF5KHRhc2tXb3JrZXJTYWIpW2N1cnJlbnROdW1iZXJPZk1lc3NhZ2VzICsgMl0gPSB0d01lc3NhZ2VQdHI7XG4gICAgdGFza1dvcmtlclNhYmkzMltUV19TQUJfTUVTU0FHRV9DT1VOVF9QVFJdID0gY3VycmVudE51bWJlck9mTWVzc2FnZXMgKyAxO1xuICAgIG11dGV4VW5sb2NrKHRhc2tXb3JrZXJTYWJpMzIsIFRXX1NBQl9NVVRFWF9QVFIpO1xuICAgIEF0b21pY3Mubm90aWZ5KHRhc2tXb3JrZXJTYWJpMzIsIDEpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdhc20gVGhyZWFkIGluaXRpYWxpemF0aW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUaHJlYWRzIGluIFdlYkFzc2VtYmx5ISBUaGV5IGFyZS4uIGZ1biEgSGVyZSdzIHdoYXQgaGFwcGVucy5cbi8vXG4vLyBUaGUgZmlyc3QgV2FzbSBpbnN0YW5jZSB3ZSBzdGFydCBpcyBpbiB0aGUgbWFpbiB3b3JrZXIuIEl0IGRvZXMgdGhlIGZvbGxvd2luZzpcbi8vIC0gSXQgaW5pdGlhbGl6ZXMgc3RhdGljIG1lbW9yeSB1c2luZyBgX193YXNtX2luaXRfbWVtb3J5YCwgd2hpY2ggaXMgYXV0b21hdGljYWxseSBzZXRcbi8vICAgYnkgTExWTSBhcyB0aGUgc3BlY2lhbCBcInN0YXJ0XCIgZnVuY3Rpb24uXG4vLyAtIEl0IGFscmVhZHkgaGFzIG1lbW9yeSBhbGxvY2F0ZWQgZm9yIHRoZSBcInNoYWRvdyBzdGFja1wiLiBUaGlzIGlzIGxpa2UgYW55IHN0YWNrIGluIGFcbi8vICAgbmF0aXZlIHByb2dyYW0sIGJ1dCBpbiBXZWJBc3NlbWJseSBpdCdzIGNhbGxlZCB0aGUgXCJzaGFkb3cgc3RhY2tcIiBiZWNhdXNlIFdlYkFzc2VtYmx5XG4vLyAgIGl0c2VsZiBhbHNvIGhhcyBhIG5vdGlvbiBvZiBhIHN0YWNrIGJ1aWx0LWluLiBJdCBpcyBob3dldmVyIG5vdCBzdWl0YWJsZSBmb3IgYWxsXG4vLyAgIGtpbmRzIG9mIGRhdGEsIHdoaWNoIGlzIHdoeSB3ZSBuZWVkIGFub3RoZXIgc2VwYXJhdGUgc3RhY2suXG4vLyAtIFdlIGFsbG9jYXRlIFRocmVhZCBMb2NhbCBTdG9yYWdlIChUTFMpIGJ5IGFsbG9jYXRpbmcgc29tZSBtZW1vcnkgb24gdGhlIGhlYXAgKGFuXG4vLyAgIG9wZXJhdGlvbiB3aGljaCBieSBpdHNlbGYgc2hvdWxkIG5vdCByZXF1aXJlIFRMUzsgb3RoZXJ3aXNlIHdlJ2QgaGF2ZSBhIENhdGNoLTIyXG4vLyAgIHNpdHVhdGlvbi4uKSwgYW5kIGNhbGxpbmcgYGluaXRUaHJlYWRMb2NhbFN0b3JhZ2VNYWluV29ya2VyYCB3aXRoIGl0LlxuLy9cbi8vIFRoZW4sIHdoZW4gd2UgbWFrZSBhbnkgb3RoZXIgV2ViQXNzZW1ibHkgdGhyZWFkcyAoZS5nLiBpbiBvdXIgb3duIFdlYldvcmtlcnMsIG9yIGluXG4vLyB0aGUgV2ViV29ya2VycyBvZiB1c2VycyksIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAtIGBfX3dhc21faW5pdF9tZW1vcnlgIGlzIGFnYWluIGNhbGxlZCBhdXRvbWF0aWNhbGx5LCBidXQgd2lsbCBiZSBza2lwcGVkLCBzaW5jZSBhblxuLy8gICAoYXRvbWljKSBmbGFnIGhhcyBiZWVuIHNldCBub3QgdG8gaW5pdGlhbGl6ZSBzdGF0aWMgbWVtb3J5IGFnYWluLlxuLy8gLSBXZSBuZWVkIHRvIGluaXRpYWxpemUgbWVtb3J5IGZvciBib3RoIHRoZSBzaGFkb3cgc3RhY2sgYW5kIHRoZSBUaHJlYWQgTG9jYWxcbi8vICAgU3RvcmFnZSAoVExTKSwgdXNpbmcgYG1ha2VUaHJlYWRMb2NhbFN0b3JhZ2VBbmRTdGFja0RhdGFPbkV4aXN0aW5nVGhyZWFkYC4gV2UgZG8gdGhpc1xuLy8gICBieSBhbGxvY2F0aW5nIG1lbW9yeSBvbiB0aGUgaGVhcCBvbiBhbiBhbHJlYWR5IGluaXRpYWxpemVkIHRocmVhZCwgc2luY2UgYWxsb2NhdGluZyBtZW1vcnkgRE9FU1xuLy8gICByZXF1aXJlIHRoZSBzaGFkb3cgc3RhY2sgdG8gYmUgaW5pdGlhbGl6ZWQuXG4vLyAtIFdlIHRoZW4gdXNlIHRoaXMgbWVtb3J5IGZvciBib3RoIHRoZSBUTFMgKG9uIHRoZSBsb3dlciBzaWRlKSBhbmQgdGhlIHNoYWRvdyBzdGFja1xuLy8gICAob24gdGhlIHVwcGVyIHNpZGUsIHNpbmNlIGl0IG1vdmVzIGRvd253YXJkKSwgdXNpbmcgYGluaXRUaHJlYWRMb2NhbFN0b3JhZ2VBbmRTdGFja090aGVyV29ya2Vyc2AuXG4vL1xuLy8gVE9ETyhKUCk6IFRoaXMgY3VycmVudGx5IGxlYWtzIG1lbW9yeSBzaW5jZSB3ZSBuZXZlciBkZWFsbG9jYXRlIHRoZSBUTFMvc2hhZG93IHN0YWNrIVxuLy9cbi8vIFRPRE8oSlApOiBFdmVuIGlmIHdlIGRvIGRlYWxsb2NhdGUgdGhlIG1lbW9yeSwgdGhlcmUgaXMgY3VycmVudGx5IG5vIHdheSB0byBjYWxsIFRMU1xuLy8gZGVzdHJ1Y3RvcnM7IHNvIHdlJ2Qgc3RpbGwgbGVhayBtZW1vcnkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcnVzdC1sYW5nL3J1c3QvaXNzdWVzLzc3ODM5XG4vLyBUaGUgXCJzaGFkb3cgc3RhY2tcIiBzaXplIGZvciBuZXcgdGhyZWFkcy4gTm90ZSB0aGF0IHRoZSBtYWluIHRocmVhZCB3aWxsXG4vLyBrZWVwIHVzaW5nIGl0cyBvd24gc2hhZG93IHN0YWNrIHNpemUuXG5jb25zdCBXQVNNX1NUQUNLX1NJWkVfQllURVMgPSAyICogMTAyNCAqIDEwMjQ7IC8vIDIgTUJcbi8vIEZvciB0aGUgbWFpbiB3b3JrZXIsIHdlIG9ubHkgbmVlZCB0byBpbml0aWFsaXplIFRocmVhZCBMb2NhbCBTdG9yYWdlIChUTFMpLlxuZXhwb3J0IGNvbnN0IGluaXRUaHJlYWRMb2NhbFN0b3JhZ2VNYWluV29ya2VyID0gKHdhc21FeHBvcnRzKSA9PiB7XG4gICAgLy8gTm90ZSB0aGF0IGFsbG9jV2FzbU1lc3NhZ2UgYWx3YXlzIGFsaWducyB0byA2NCBiaXRzIC8gOCBieXRlcy5cbiAgICBjb25zdCBwdHIgPSB3YXNtRXhwb3J0cy5hbGxvY1dhc21NZXNzYWdlKEJpZ0ludCh3YXNtRXhwb3J0cy5fX3Rsc19zaXplLnZhbHVlKSk7XG4gICAgLy8gVE9ETyhKUCk6IENhc3QgdG8gTnVtYmVyIGNhbiBjYXVzZSB0cm91YmxlID4yR0IuXG4gICAgd2FzbUV4cG9ydHMuX193YXNtX2luaXRfdGxzKE51bWJlcihwdHIpKTtcbn07XG4vLyBGb3Igbm9uLW1haW4gd29ya2Vycywgd2UgbmVlZCB0byBhbGxvY2F0ZSBlbm91Z2ggZGF0YSBmb3IgVGhyZWFkIExvY2FsIFN0b3JhZ2UgKFRMUylcbi8vIGFuZCB0aGUgXCJzaGFkb3cgc3RhY2tcIi4gV2UgYWxsb2NhdGUgdGhpcyBkYXRhIGluIHRoZSBtYWluIHdvcmtlciwgYW5kIHRoZW4gc2VuZCB0aGVcbi8vIHBvaW50ZXIgKyBzaXplIHRvIG90aGVyIHdvcmtlcnMuXG4vL1xuLy8gVGhpcyBpcyBlYXNpZXIgdGhhbiB0cnlpbmcgdG8gYWxsb2NhdGUgdGhlIGFwcHJvcHJpYXRlIGFtb3VudCBvZiBkYXRhIGluIHRoZSBvdGhlclxuLy8gaXRzZWxmLCB3aGljaCBpcyBwb3NzaWJsZSAoZS5nLiB1c2luZyBtZW1vcnkuZ3JvdykgYnV0IGtpbmQgb2YgY3VtYmVyc29tZS5cbmV4cG9ydCBjb25zdCBtYWtlVGhyZWFkTG9jYWxTdG9yYWdlQW5kU3RhY2tEYXRhT25FeGlzdGluZ1RocmVhZCA9ICh3YXNtRXhwb3J0cykgPT4ge1xuICAgIC8vIEFsaWduIHNpemUgdG8gNjQgYml0cyAvIDggYnl0ZXMuXG4gICAgY29uc3Qgc2l6ZSA9IE1hdGguY2VpbCgod2FzbUV4cG9ydHMuX190bHNfc2l6ZS52YWx1ZSArIFdBU01fU1RBQ0tfU0laRV9CWVRFUykgLyA4KSAqIDg7XG4gICAgLy8gTm90ZSB0aGF0IGFsbG9jV2FzbU1lc3NhZ2UgYWx3YXlzIGFsaWducyB0byA2NCBiaXRzIC8gOCBieXRlcy5cbiAgICBjb25zdCBwdHIgPSB3YXNtRXhwb3J0cy5hbGxvY1dhc21NZXNzYWdlKEJpZ0ludChzaXplKSk7XG4gICAgcmV0dXJuIHsgcHRyLCBzaXplIH07XG59O1xuLy8gU2V0IHRoZSBzaGFkb3cgc3RhY2sgcG9pbnRlciBhbmQgaW5pdGlhbGl6ZSB0aGV0IFRocmVhZCBMb2NhbCBTdG9yYWdlIChUTFMpLlxuLy9cbi8vIE5vdGUgdGhhdCB0aGUgVExTIHNpdHMgb24gdGhlIGxvd2VyIHNpZGUgb2YgdGhlIG1lbW9yeSwgd2hlcmFzIHRoZSBzaGFkb3cgc3RhY2tcbi8vIHN0YXJ0cyBvbiB0aGUgdXBwZXIgc2lkZSBvZiB0aGUgbWVtb3J5IGFuZCBncm93cyBkb3dud2FyZHMuXG4vL1xuLy8gVE9ETyhKUCk6IF9fd2FzbV9pbml0X3RscyB0YWtlcyBhIE51bWJlciwgd2hpY2ggbWlnaHQgbm90IHdvcmsgd2hlbiBpdCBpcyA+MkdCLlxuZXhwb3J0IGNvbnN0IGluaXRUaHJlYWRMb2NhbFN0b3JhZ2VBbmRTdGFja090aGVyV29ya2VycyA9ICh3YXNtRXhwb3J0cywgdGxzQW5kU3RhY2tEYXRhKSA9PiB7XG4gICAgLy8gU3RhcnQgdGhlIHNoYWRvdyBzdGFjayBwb2ludGVyIG9uIHRoZSB1cHBlciBzaWRlIG9mIHRoZSBtZW1vcnksIHRob3VnaCBzdWJ0cmFjdFxuICAgIC8vIDggc28gd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBieXRlIHJpZ2h0IGFmdGVyIHRoZSBtZW1vcnksIHdoaWxlIHN0aWxsIGtlZXBpbmcgaXRcbiAgICAvLyA2NC1iaXQgYWxpZ25lZC4gVE9ETyhKUCk6IElzIHRoZSA2NC1iaXQgYWxpZ25tZW50IG5lY2Vzc2FyeSBmb3IgdGhlIHNoYWRvdyBzdGFjaz9cbiAgICB3YXNtRXhwb3J0cy5fX3N0YWNrX3BvaW50ZXIudmFsdWUgPVxuICAgICAgICBOdW1iZXIodGxzQW5kU3RhY2tEYXRhLnB0cikgKyB0bHNBbmRTdGFja0RhdGEuc2l6ZSAtIDg7XG4gICAgd2FzbUV4cG9ydHMuX193YXNtX2luaXRfdGxzKFxuICAgIC8vIFRPRE8oSlApOiBDYXN0IHRvIE51bWJlciBjYW4gY2F1c2UgdHJvdWJsZSA+MkdCLlxuICAgIE51bWJlcih0bHNBbmRTdGFja0RhdGEucHRyKSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ29tbW9uIHdhc20gZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY29uc3QgY29weUFycmF5VG9SdXN0QnVmZmVyID0gKGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIG91dHB1dFB0cikgPT4ge1xuICAgIC8vIHNob3VsZCBiZSB0aGUgc2FtZSB0eXBlIGFzIGlucHV0QnVmZmVyXG4gICAgLy8gQHRzLWlnbm9yZTogY29uc3RydWN0b3IgaXMgZ2V0dGluZyB0eXBlZCBhcyBGdW5jdGlvbiBpbnN0ZWFkIG9mIGEgY29uc3RydWN0b3JcbiAgICBuZXcgaW5wdXRCdWZmZXIuY29uc3RydWN0b3Iob3V0cHV0QnVmZmVyLCBvdXRwdXRQdHIsIGlucHV0QnVmZmVyLmxlbmd0aCkuc2V0KGlucHV0QnVmZmVyKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0V3JmUGFyYW1UeXBlID0gKGFycmF5LCByZWFkb25seSkgPT4ge1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRvbmx5ID8gV3JmUGFyYW1UeXBlLlJlYWRPbmx5VThCdWZmZXIgOiBXcmZQYXJhbVR5cGUuVThCdWZmZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIHJldHVybiByZWFkb25seSA/IFdyZlBhcmFtVHlwZS5SZWFkT25seUYzMkJ1ZmZlciA6IFdyZlBhcmFtVHlwZS5GMzJCdWZmZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFycmF5IHR5cGVcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBjcmVhdGVXYXNtQnVmZmVyID0gKG1lbW9yeSwgZXhwb3J0cywgZGF0YSkgPT4ge1xuICAgIGNvbnN0IHZlY1B0ciA9IE51bWJlcihleHBvcnRzLmFsbG9jV2FzbVZlYyhCaWdJbnQoZGF0YS5ieXRlTGVuZ3RoKSkpO1xuICAgIGNvcHlBcnJheVRvUnVzdEJ1ZmZlcihkYXRhLCBtZW1vcnkuYnVmZmVyLCB2ZWNQdHIpO1xuICAgIHJldHVybiB2ZWNQdHI7XG59O1xuZXhwb3J0IGNvbnN0IG1ha2VaZXJkZUJ1aWxkZXIgPSAobWVtb3J5LCB3YXNtRXhwb3J0cykgPT4ge1xuICAgIGNvbnN0IHNsb3RzID0gMTAyNDtcbiAgICAvLyBXZSBoYXZlIGdldCBtZW1vcnkuYnVmZmVyICphZnRlciogY2FsbGluZyBgYWxsb2NXYXNtTWVzc2FnZWAsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSdzIGEgZ29vZCBjaGFuY2UgaXQnbGwgZ2V0IHN3YXBwZWQgb3V0IChpZiBpdCBuZWVkZWQgdG8gZ3JvdyB0aGUgYnVmZmVyKS5cbiAgICBjb25zdCBieXRlT2Zmc2V0ID0gTnVtYmVyKHdhc21FeHBvcnRzLmFsbG9jV2FzbU1lc3NhZ2UoQmlnSW50KHNsb3RzICogNCkpKTtcbiAgICByZXR1cm4gbmV3IFplcmRlQnVpbGRlcih7XG4gICAgICAgIGJ1ZmZlcjogbWVtb3J5LmJ1ZmZlcixcbiAgICAgICAgYnl0ZU9mZnNldDogYnl0ZU9mZnNldCxcbiAgICAgICAgc2xvdHMsXG4gICAgICAgIGdyb3dDYWxsYmFjazogKF9idWZmZXIsIG9sZEJ5dGVPZmZzZXQsIG5ld0J5dGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdCeXRlT2Zmc2V0ID0gTnVtYmVyKHdhc21FeHBvcnRzLnJlYWxsb2NXYXNtTWVzc2FnZShCaWdJbnQob2xkQnl0ZU9mZnNldCksIEJpZ0ludChuZXdCeXRlcykpKTtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZ2V0IG1lbW9yeS5idWZmZXIgKmFmdGVyKiBjYWxsaW5nIGByZWFsbG9jV2FzbU1lc3NhZ2VgLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGVyZSdzIGEgZ29vZCBjaGFuY2UgaXQnbGwgZ2V0IHN3YXBwZWQgb3V0IChpZiBpdCBuZWVkZWQgdG8gZ3JvdyB0aGUgYnVmZmVyKS5cbiAgICAgICAgICAgIHJldHVybiB7IGJ1ZmZlcjogbWVtb3J5LmJ1ZmZlciwgYnl0ZU9mZnNldDogbmV3Qnl0ZU9mZnNldCB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBnZXRXYXNtRW52ID0gKHsgZ2V0RXhwb3J0cywgbWVtb3J5LCB0YXNrV29ya2VyU2FiLCBmaWxlSGFuZGxlcywgc2VuZEV2ZW50RnJvbUFueVRocmVhZCwgdGhyZWFkU3Bhd24sIGJhc2VVcmksIH0pID0+IHtcbiAgICBjb25zdCBmaWxlUmVhZGVyU3luYyA9IG5ldyBGaWxlUmVhZGVyU3luYygpO1xuICAgIGNvbnN0IHBhcnNlU3RyaW5nID0gKHB0ciwgbGVuKSA9PiB7XG4gICAgICAgIGxldCBvdXQgPSBcIlwiO1xuICAgICAgICAvLyBDYW4ndCB1c2UgVGV4dERlY29kZXIgaGVyZSBzaW5jZSBpdCBkb2Vzbid0IHdvcmsgd2l0aCBTaGFyZWRBcnJheUJ1ZmZlci5cbiAgICAgICAgLy8gVE9ETyhKUCk6IElmIGl0IGJlY29tZXMgaW1wb3J0YW50IGVub3VnaCwgd2UgY2FuIHNlZSBpZiBtYWtpbmcgYSBjb3B5IHRvIGEgcmVndWxhclxuICAgICAgICAvLyBBcnJheUJ1ZmZlciBhbmQgdGhlbiB1c2luZyBUZXh0RGVjb2RlciBpcyBmYXN0ZXIgdGhhbiB3aGF0IHdlIGRvIGhlcmUuXG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIsIHB0ciwgbGVuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZW1vcnksXG4gICAgICAgIF9jb25zb2xlTG9nOiAoY2hhcnNQdHIsIGxlbiwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IHBhcnNlU3RyaW5nKHBhcnNlSW50KGNoYXJzUHRyKSwgcGFyc2VJbnQobGVuKSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWFkVXNlckZpbGVSYW5nZTogKHVzZXJGaWxlSWQsIGJ1ZlB0ciwgYnVmTGVuLCBmaWxlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gZmlsZUhhbmRsZXNbdXNlckZpbGVJZF07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IE51bWJlcihmaWxlT2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgTnVtYmVyKGJ1Zkxlbik7XG4gICAgICAgICAgICBpZiAoZmlsZS5sYXN0UmVhZFN0YXJ0IDw9IHN0YXJ0ICYmIHN0YXJ0IDwgZmlsZS5sYXN0UmVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUmVhZCBzdGFydCAoJHtzdGFydH0pIGZlbGwgaW4gdGhlIHJhbmdlIG9mIHRoZSBsYXN0IHJlYWQgKCR7ZmlsZS5sYXN0UmVhZFN0YXJ0fS0ke2ZpbGUubGFzdFJlYWRFbmR9KTsgYCArXG4gICAgICAgICAgICAgICAgICAgIFwidGhpcyB1c3VhbGx5IGhhcHBlbnMgaWYgeW91IGRvbid0IHVzZSBCdWZSZWFkZXIgb3IgaWYgeW91IGRvbid0IHVzZSBCdWZSZWFkZXIuc2Vla19yZWxhdGl2ZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlLmxhc3RSZWFkU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGZpbGUubGFzdFJlYWRFbmQgPSBlbmQ7XG4gICAgICAgICAgICAvLyBUT0RPKEpQKTogVGhpcyBjcmVhdGVzIGEgbmV3IGJ1ZmZlciBpbnN0ZWFkIG9mIHJlYWRpbmcgZGlyZWN0bHkgaW50byB0aGUgd2FzbSBtZW1vcnkuXG4gICAgICAgICAgICAvLyBNYXliZSB3ZSBjYW4gYXZvaWQgdGhpcyBieSB1c2luZyBhIHN0cmVhbSB3aXRoIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLCBidXQgdGhhdCBpc1xuICAgICAgICAgICAgLy8gYXN5bmNocm9ub3VzLCBzbyB3ZSdkIGhhdmUgdG8gZG8gYSBkYW5jZSB3aXRoIGFub3RoZXIgdGhyZWFkIGFuZCBhdG9taWNzIGFuZCBhbGwgdGhhdCxcbiAgICAgICAgICAgIC8vIGFuZCBJIGRvbid0IGtub3cgaWYgdGhhdCBvdmVyaGVhZCB3b3VsZCBiZSB3b3J0aCBpdC4uXG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBmaWxlUmVhZGVyU3luYy5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlLmZpbGUuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgY29weUFycmF5VG9SdXN0QnVmZmVyKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIG1lbW9yeS5idWZmZXIsIE51bWJlcihidWZQdHIpKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQoYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICBwZXJmb3JtYW5jZU5vdzogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9LFxuICAgICAgICB0aHJlYWRTcGF3bjogKGN0eFB0cikgPT4ge1xuICAgICAgICAgICAgdGhyZWFkU3Bhd24oY3R4UHRyKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NlbmRFdmVudEZyb21BbnlUaHJlYWQ6IChldmVudFB0cikgPT4ge1xuICAgICAgICAgICAgc2VuZEV2ZW50RnJvbUFueVRocmVhZChldmVudFB0cik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRVcmxTeW5jOiAodXJsUHRyLCB1cmxMZW4sIGJ1ZlB0ck91dCwgYnVmTGVuT3V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBwYXJzZVN0cmluZyh1cmxQdHIsIHVybExlbik7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCBuZXcgVVJMKHVybCwgYmFzZVVyaSkuaHJlZiwgZmFsc2UgLyogc3luY2hyb25vdXMgKi8pO1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKG51bGwpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBvcnRzID0gZ2V0RXhwb3J0cygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dEJ1ZlB0ciA9IGNyZWF0ZVdhc21CdWZmZXIobWVtb3J5LCBleHBvcnRzLCBuZXcgVWludDhBcnJheShyZXF1ZXN0LnJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIsIGJ1ZlB0ck91dCwgMSlbMF0gPSBvdXRwdXRCdWZQdHI7XG4gICAgICAgICAgICAgICAgbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIsIGJ1Zkxlbk91dCwgMSlbMF0gPVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmFuZG9tVTY0OiAoKSA9PiBuZXcgQmlnVWludDY0QXJyYXkoc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSkuYnVmZmVyKVswXSxcbiAgICAgICAgc2VuZFRhc2tXb3JrZXJNZXNzYWdlOiAodHdNZXNzYWdlUHRyKSA9PiB7XG4gICAgICAgICAgICBzZW5kVGFza1dvcmtlck1lc3NhZ2UodGFza1dvcmtlclNhYiwgcGFyc2VJbnQodHdNZXNzYWdlUHRyKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3RJbXBsKG1lbW9yeSwgZGVzdHJ1Y3RvciwgbXV0YWJsZURlc3RydWN0b3IsIHBhcmFtcykge1xuICAgIHJldHVybiBwYXJhbXMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB3cmZCdWZmZXIgPSBnZXRXcmZCdWZmZXJXYXNtKG1lbW9yeSwgcGFyYW0sIGRlc3RydWN0b3IsIG11dGFibGVEZXN0cnVjdG9yKTtcbiAgICAgICAgICAgIGlmIChwYXJhbS5wYXJhbVR5cGUgPT09IFdyZlBhcmFtVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcmZQYXJhbSBidWZmZXIgdHlwZSBjYWxsZWQgd2l0aCBzdHJpbmcgcGFyYW1UeXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIGFjdHVhbGx5IFdyZkFycmF5IHR5cGVzLCBzaW5jZSB3ZSBvdmVyd3JpdGUgVHlwZWRBcnJheXMgaW4gb3ZlcndyaXRlVHlwZWRBcnJheXNXaXRoV3JmQXJyYXlzKClcbiAgICAgICAgICAgIGNvbnN0IEFycmF5Q29uc3RydWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgW1dyZlBhcmFtVHlwZS5VOEJ1ZmZlcl06IFVpbnQ4QXJyYXksXG4gICAgICAgICAgICAgICAgW1dyZlBhcmFtVHlwZS5SZWFkT25seVU4QnVmZmVyXTogVWludDhBcnJheSxcbiAgICAgICAgICAgICAgICBbV3JmUGFyYW1UeXBlLkYzMkJ1ZmZlcl06IEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAgICAgICBbV3JmUGFyYW1UeXBlLlJlYWRPbmx5RjMyQnVmZmVyXTogRmxvYXQzMkFycmF5LFxuICAgICAgICAgICAgfVtwYXJhbS5wYXJhbVR5cGVdO1xuICAgICAgICAgICAgcmV0dXJuIGdldENhY2hlZFdyZkJ1ZmZlcih3cmZCdWZmZXIsIG5ldyBBcnJheUNvbnN0cnVjdG9yKHdyZkJ1ZmZlciwgcGFyYW0uYnVmZmVyUHRyLCBwYXJhbS5idWZmZXJMZW4gLyBBcnJheUNvbnN0cnVjdG9yLkJZVEVTX1BFUl9FTEVNRU5UKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3ROdWxsKHZhbHVlLCBvYmplY3ROYW1lID0gXCJWYWx1ZVwiKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb24gZmFpbGVkOiAke29iamVjdE5hbWV9IGlzIG51bGxgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./common.ts\n");

/***/ }),

/***/ "./type_of_runtime.ts":
/*!****************************!*\
  !*** ./type_of_runtime.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jsRuntime\": () => (/* binding */ jsRuntime)\n/* harmony export */ });\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// We only define `cefCallRust` if in CEF, so we can use this for environment detection.\n// This should only be used at the top level `wrf_runtime` file or in test, since we want to keep\n// CEF and WASM code separate for bundle size.\nconst jsRuntime = \"cefCallRust\" in self ? \"cef\" : \"wasm\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90eXBlX29mX3J1bnRpbWUudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3R5cGVfb2ZfcnVudGltZS50cz9kNzJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMS1wcmVzZW50LCBDcnVpc2UgTExDXG4vL1xuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UtQVBBQ0hFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBXZSBvbmx5IGRlZmluZSBgY2VmQ2FsbFJ1c3RgIGlmIGluIENFRiwgc28gd2UgY2FuIHVzZSB0aGlzIGZvciBlbnZpcm9ubWVudCBkZXRlY3Rpb24uXG4vLyBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgYXQgdGhlIHRvcCBsZXZlbCBgd3JmX3J1bnRpbWVgIGZpbGUgb3IgaW4gdGVzdCwgc2luY2Ugd2Ugd2FudCB0byBrZWVwXG4vLyBDRUYgYW5kIFdBU00gY29kZSBzZXBhcmF0ZSBmb3IgYnVuZGxlIHNpemUuXG5leHBvcnQgY29uc3QganNSdW50aW1lID0gXCJjZWZDYWxsUnVzdFwiIGluIHNlbGYgPyBcImNlZlwiIDogXCJ3YXNtXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./type_of_runtime.ts\n");

/***/ }),

/***/ "./types.ts":
/*!******************!*\
  !*** ./types.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WrfParamType\": () => (/* binding */ WrfParamType),\n/* harmony export */   \"WorkerEvent\": () => (/* binding */ WorkerEvent),\n/* harmony export */   \"MainWorkerChannelEvent\": () => (/* binding */ MainWorkerChannelEvent),\n/* harmony export */   \"AsyncWorkerEvent\": () => (/* binding */ AsyncWorkerEvent),\n/* harmony export */   \"TaskWorkerEvent\": () => (/* binding */ TaskWorkerEvent)\n/* harmony export */ });\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Keep in sync with `param.rs`\nvar WrfParamType;\n(function (WrfParamType) {\n    WrfParamType[WrfParamType[\"String\"] = 0] = \"String\";\n    WrfParamType[WrfParamType[\"ReadOnlyU8Buffer\"] = 1] = \"ReadOnlyU8Buffer\";\n    WrfParamType[WrfParamType[\"U8Buffer\"] = 2] = \"U8Buffer\";\n    WrfParamType[WrfParamType[\"F32Buffer\"] = 3] = \"F32Buffer\";\n    WrfParamType[WrfParamType[\"ReadOnlyF32Buffer\"] = 4] = \"ReadOnlyF32Buffer\";\n})(WrfParamType || (WrfParamType = {}));\nvar WorkerEvent;\n(function (WorkerEvent) {\n    WorkerEvent[\"CallRust\"] = \"WorkerEvent.CallRust\";\n    WorkerEvent[\"CreateBuffer\"] = \"WorkerEvent.CreateBuffer\";\n    WorkerEvent[\"CreateReadOnlyBuffer\"] = \"WorkerEvent.CreateReadOnlyBuffer\";\n    WorkerEvent[\"BindMainWorkerPort\"] = \"WorkerEvent.BindMainWorkerPort\";\n    WorkerEvent[\"DecrementArc\"] = \"WorkerEvent.DecrementArc\";\n    WorkerEvent[\"DeallocVec\"] = \"WorkerEvent.DeallocVec\";\n    WorkerEvent[\"IncrementArc\"] = \"WorkerEvent.IncrementArc\";\n    WorkerEvent[\"DragEnter\"] = \"WorkerEvent.DragEnter\";\n    WorkerEvent[\"DragOver\"] = \"WorkerEvent.DragOver\";\n    WorkerEvent[\"DragLeave\"] = \"WorkerEvent.DragLeave\";\n    WorkerEvent[\"Drop\"] = \"WorkerEvent.Drop\";\n    WorkerEvent[\"WindowMouseUp\"] = \"WorkerEvent.WindowMouseUp\";\n    WorkerEvent[\"CanvasMouseDown\"] = \"WorkerEvent.CanvasMouseDown\";\n    WorkerEvent[\"WindowMouseMove\"] = \"WorkerEvent.WindowMouseMove\";\n    WorkerEvent[\"WindowMouseOut\"] = \"WorkerEvent.WindowMouseOut\";\n    WorkerEvent[\"WindowFocus\"] = \"WorkerEvent.WindowFocus\";\n    WorkerEvent[\"WindowBlur\"] = \"WorkerEvent.WindowBlur\";\n    WorkerEvent[\"ScreenResize\"] = \"WorkerEvent.ScreenResize\";\n    WorkerEvent[\"CanvasWheel\"] = \"WorkerEvent.CanvasWheel\";\n    WorkerEvent[\"ShowIncompatibleBrowserNotification\"] = \"WorkerEvent.ShowIncompatibleBrowserNotification\";\n    WorkerEvent[\"RemoveLoadingIndicators\"] = \"WorkerEvent.RemoveLoadingIndicators\";\n    WorkerEvent[\"SetDocumentTitle\"] = \"WorkerEvent.SetDocumentTitle\";\n    WorkerEvent[\"SetMouseCursor\"] = \"WorkerEvent.SetMouseCursor\";\n    WorkerEvent[\"Fullscreen\"] = \"WorkerEvent.Fullscreen\";\n    WorkerEvent[\"Normalscreen\"] = \"WorkerEvent.Normalscreen\";\n    WorkerEvent[\"TextCopyResponse\"] = \"WorkerEvent.TextCopyResponse\";\n    WorkerEvent[\"EnableGlobalFileDropTarget\"] = \"WorkerEvent.EnableGlobalFileDropTarget\";\n    WorkerEvent[\"CallJs\"] = \"WorkerEvent.CallJs\";\n    WorkerEvent[\"ShowTextIME\"] = \"WorkerEvent.ShowTextIME\";\n    WorkerEvent[\"TextInput\"] = \"WorkerEvent.TextInput\";\n    WorkerEvent[\"TextCopy\"] = \"WorkerEvent.TextCopy\";\n    WorkerEvent[\"KeyDown\"] = \"WorkerEvent.KeyDown\";\n    WorkerEvent[\"KeyUp\"] = \"WorkerEvent.KeyUp\";\n    WorkerEvent[\"Init\"] = \"WorkerEvent.Init\";\n    WorkerEvent[\"RunWebGL\"] = \"WorkerEvent.RunWebGL\";\n    WorkerEvent[\"ThreadSpawn\"] = \"WorkerEvent.ThreadSpawn\";\n    WorkerEvent[\"WindowTouchStart\"] = \"WorkerEvent.WindowTouchStart\";\n    WorkerEvent[\"WindowTouchMove\"] = \"WorkerEvent.WindowTouchMove\";\n    WorkerEvent[\"WindowTouchEndCancelLeave\"] = \"WorkerEvent.WindowTouchEndCancelLeave\";\n})(WorkerEvent || (WorkerEvent = {}));\nvar MainWorkerChannelEvent;\n(function (MainWorkerChannelEvent) {\n    MainWorkerChannelEvent[\"Init\"] = \"MainWorkerChannelEvent.Init\";\n    MainWorkerChannelEvent[\"BindMainWorkerPort\"] = \"MainWorkerChannelEvent.BindMainWorkerPort\";\n    MainWorkerChannelEvent[\"CallRust\"] = \"MainWorkerChannelEvent.CallRust\";\n    MainWorkerChannelEvent[\"SendEventFromAnyThread\"] = \"MainWorkerChannelEvent.SendEventFromAnyThread\";\n})(MainWorkerChannelEvent || (MainWorkerChannelEvent = {}));\nvar AsyncWorkerEvent;\n(function (AsyncWorkerEvent) {\n    AsyncWorkerEvent[\"Run\"] = \"AsyncWorkerEvent.Run\";\n    AsyncWorkerEvent[\"ThreadSpawn\"] = \"AsyncWorkerEvent.ThreadSpawn\";\n})(AsyncWorkerEvent || (AsyncWorkerEvent = {}));\nvar TaskWorkerEvent;\n(function (TaskWorkerEvent) {\n    TaskWorkerEvent[\"Init\"] = \"TaskWorkerEvent.Init\";\n})(TaskWorkerEvent || (TaskWorkerEvent = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90eXBlcy50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3R5cGVzLnRzPzVmNTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIEtlZXAgaW4gc3luYyB3aXRoIGBwYXJhbS5yc2BcbmV4cG9ydCB2YXIgV3JmUGFyYW1UeXBlO1xuKGZ1bmN0aW9uIChXcmZQYXJhbVR5cGUpIHtcbiAgICBXcmZQYXJhbVR5cGVbV3JmUGFyYW1UeXBlW1wiU3RyaW5nXCJdID0gMF0gPSBcIlN0cmluZ1wiO1xuICAgIFdyZlBhcmFtVHlwZVtXcmZQYXJhbVR5cGVbXCJSZWFkT25seVU4QnVmZmVyXCJdID0gMV0gPSBcIlJlYWRPbmx5VThCdWZmZXJcIjtcbiAgICBXcmZQYXJhbVR5cGVbV3JmUGFyYW1UeXBlW1wiVThCdWZmZXJcIl0gPSAyXSA9IFwiVThCdWZmZXJcIjtcbiAgICBXcmZQYXJhbVR5cGVbV3JmUGFyYW1UeXBlW1wiRjMyQnVmZmVyXCJdID0gM10gPSBcIkYzMkJ1ZmZlclwiO1xuICAgIFdyZlBhcmFtVHlwZVtXcmZQYXJhbVR5cGVbXCJSZWFkT25seUYzMkJ1ZmZlclwiXSA9IDRdID0gXCJSZWFkT25seUYzMkJ1ZmZlclwiO1xufSkoV3JmUGFyYW1UeXBlIHx8IChXcmZQYXJhbVR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBXb3JrZXJFdmVudDtcbihmdW5jdGlvbiAoV29ya2VyRXZlbnQpIHtcbiAgICBXb3JrZXJFdmVudFtcIkNhbGxSdXN0XCJdID0gXCJXb3JrZXJFdmVudC5DYWxsUnVzdFwiO1xuICAgIFdvcmtlckV2ZW50W1wiQ3JlYXRlQnVmZmVyXCJdID0gXCJXb3JrZXJFdmVudC5DcmVhdGVCdWZmZXJcIjtcbiAgICBXb3JrZXJFdmVudFtcIkNyZWF0ZVJlYWRPbmx5QnVmZmVyXCJdID0gXCJXb3JrZXJFdmVudC5DcmVhdGVSZWFkT25seUJ1ZmZlclwiO1xuICAgIFdvcmtlckV2ZW50W1wiQmluZE1haW5Xb3JrZXJQb3J0XCJdID0gXCJXb3JrZXJFdmVudC5CaW5kTWFpbldvcmtlclBvcnRcIjtcbiAgICBXb3JrZXJFdmVudFtcIkRlY3JlbWVudEFyY1wiXSA9IFwiV29ya2VyRXZlbnQuRGVjcmVtZW50QXJjXCI7XG4gICAgV29ya2VyRXZlbnRbXCJEZWFsbG9jVmVjXCJdID0gXCJXb3JrZXJFdmVudC5EZWFsbG9jVmVjXCI7XG4gICAgV29ya2VyRXZlbnRbXCJJbmNyZW1lbnRBcmNcIl0gPSBcIldvcmtlckV2ZW50LkluY3JlbWVudEFyY1wiO1xuICAgIFdvcmtlckV2ZW50W1wiRHJhZ0VudGVyXCJdID0gXCJXb3JrZXJFdmVudC5EcmFnRW50ZXJcIjtcbiAgICBXb3JrZXJFdmVudFtcIkRyYWdPdmVyXCJdID0gXCJXb3JrZXJFdmVudC5EcmFnT3ZlclwiO1xuICAgIFdvcmtlckV2ZW50W1wiRHJhZ0xlYXZlXCJdID0gXCJXb3JrZXJFdmVudC5EcmFnTGVhdmVcIjtcbiAgICBXb3JrZXJFdmVudFtcIkRyb3BcIl0gPSBcIldvcmtlckV2ZW50LkRyb3BcIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd01vdXNlVXBcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd01vdXNlVXBcIjtcbiAgICBXb3JrZXJFdmVudFtcIkNhbnZhc01vdXNlRG93blwiXSA9IFwiV29ya2VyRXZlbnQuQ2FudmFzTW91c2VEb3duXCI7XG4gICAgV29ya2VyRXZlbnRbXCJXaW5kb3dNb3VzZU1vdmVcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd01vdXNlTW92ZVwiO1xuICAgIFdvcmtlckV2ZW50W1wiV2luZG93TW91c2VPdXRcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd01vdXNlT3V0XCI7XG4gICAgV29ya2VyRXZlbnRbXCJXaW5kb3dGb2N1c1wiXSA9IFwiV29ya2VyRXZlbnQuV2luZG93Rm9jdXNcIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd0JsdXJcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd0JsdXJcIjtcbiAgICBXb3JrZXJFdmVudFtcIlNjcmVlblJlc2l6ZVwiXSA9IFwiV29ya2VyRXZlbnQuU2NyZWVuUmVzaXplXCI7XG4gICAgV29ya2VyRXZlbnRbXCJDYW52YXNXaGVlbFwiXSA9IFwiV29ya2VyRXZlbnQuQ2FudmFzV2hlZWxcIjtcbiAgICBXb3JrZXJFdmVudFtcIlNob3dJbmNvbXBhdGlibGVCcm93c2VyTm90aWZpY2F0aW9uXCJdID0gXCJXb3JrZXJFdmVudC5TaG93SW5jb21wYXRpYmxlQnJvd3Nlck5vdGlmaWNhdGlvblwiO1xuICAgIFdvcmtlckV2ZW50W1wiUmVtb3ZlTG9hZGluZ0luZGljYXRvcnNcIl0gPSBcIldvcmtlckV2ZW50LlJlbW92ZUxvYWRpbmdJbmRpY2F0b3JzXCI7XG4gICAgV29ya2VyRXZlbnRbXCJTZXREb2N1bWVudFRpdGxlXCJdID0gXCJXb3JrZXJFdmVudC5TZXREb2N1bWVudFRpdGxlXCI7XG4gICAgV29ya2VyRXZlbnRbXCJTZXRNb3VzZUN1cnNvclwiXSA9IFwiV29ya2VyRXZlbnQuU2V0TW91c2VDdXJzb3JcIjtcbiAgICBXb3JrZXJFdmVudFtcIkZ1bGxzY3JlZW5cIl0gPSBcIldvcmtlckV2ZW50LkZ1bGxzY3JlZW5cIjtcbiAgICBXb3JrZXJFdmVudFtcIk5vcm1hbHNjcmVlblwiXSA9IFwiV29ya2VyRXZlbnQuTm9ybWFsc2NyZWVuXCI7XG4gICAgV29ya2VyRXZlbnRbXCJUZXh0Q29weVJlc3BvbnNlXCJdID0gXCJXb3JrZXJFdmVudC5UZXh0Q29weVJlc3BvbnNlXCI7XG4gICAgV29ya2VyRXZlbnRbXCJFbmFibGVHbG9iYWxGaWxlRHJvcFRhcmdldFwiXSA9IFwiV29ya2VyRXZlbnQuRW5hYmxlR2xvYmFsRmlsZURyb3BUYXJnZXRcIjtcbiAgICBXb3JrZXJFdmVudFtcIkNhbGxKc1wiXSA9IFwiV29ya2VyRXZlbnQuQ2FsbEpzXCI7XG4gICAgV29ya2VyRXZlbnRbXCJTaG93VGV4dElNRVwiXSA9IFwiV29ya2VyRXZlbnQuU2hvd1RleHRJTUVcIjtcbiAgICBXb3JrZXJFdmVudFtcIlRleHRJbnB1dFwiXSA9IFwiV29ya2VyRXZlbnQuVGV4dElucHV0XCI7XG4gICAgV29ya2VyRXZlbnRbXCJUZXh0Q29weVwiXSA9IFwiV29ya2VyRXZlbnQuVGV4dENvcHlcIjtcbiAgICBXb3JrZXJFdmVudFtcIktleURvd25cIl0gPSBcIldvcmtlckV2ZW50LktleURvd25cIjtcbiAgICBXb3JrZXJFdmVudFtcIktleVVwXCJdID0gXCJXb3JrZXJFdmVudC5LZXlVcFwiO1xuICAgIFdvcmtlckV2ZW50W1wiSW5pdFwiXSA9IFwiV29ya2VyRXZlbnQuSW5pdFwiO1xuICAgIFdvcmtlckV2ZW50W1wiUnVuV2ViR0xcIl0gPSBcIldvcmtlckV2ZW50LlJ1bldlYkdMXCI7XG4gICAgV29ya2VyRXZlbnRbXCJUaHJlYWRTcGF3blwiXSA9IFwiV29ya2VyRXZlbnQuVGhyZWFkU3Bhd25cIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd1RvdWNoU3RhcnRcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd1RvdWNoU3RhcnRcIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd1RvdWNoTW92ZVwiXSA9IFwiV29ya2VyRXZlbnQuV2luZG93VG91Y2hNb3ZlXCI7XG4gICAgV29ya2VyRXZlbnRbXCJXaW5kb3dUb3VjaEVuZENhbmNlbExlYXZlXCJdID0gXCJXb3JrZXJFdmVudC5XaW5kb3dUb3VjaEVuZENhbmNlbExlYXZlXCI7XG59KShXb3JrZXJFdmVudCB8fCAoV29ya2VyRXZlbnQgPSB7fSkpO1xuZXhwb3J0IHZhciBNYWluV29ya2VyQ2hhbm5lbEV2ZW50O1xuKGZ1bmN0aW9uIChNYWluV29ya2VyQ2hhbm5lbEV2ZW50KSB7XG4gICAgTWFpbldvcmtlckNoYW5uZWxFdmVudFtcIkluaXRcIl0gPSBcIk1haW5Xb3JrZXJDaGFubmVsRXZlbnQuSW5pdFwiO1xuICAgIE1haW5Xb3JrZXJDaGFubmVsRXZlbnRbXCJCaW5kTWFpbldvcmtlclBvcnRcIl0gPSBcIk1haW5Xb3JrZXJDaGFubmVsRXZlbnQuQmluZE1haW5Xb3JrZXJQb3J0XCI7XG4gICAgTWFpbldvcmtlckNoYW5uZWxFdmVudFtcIkNhbGxSdXN0XCJdID0gXCJNYWluV29ya2VyQ2hhbm5lbEV2ZW50LkNhbGxSdXN0XCI7XG4gICAgTWFpbldvcmtlckNoYW5uZWxFdmVudFtcIlNlbmRFdmVudEZyb21BbnlUaHJlYWRcIl0gPSBcIk1haW5Xb3JrZXJDaGFubmVsRXZlbnQuU2VuZEV2ZW50RnJvbUFueVRocmVhZFwiO1xufSkoTWFpbldvcmtlckNoYW5uZWxFdmVudCB8fCAoTWFpbldvcmtlckNoYW5uZWxFdmVudCA9IHt9KSk7XG5leHBvcnQgdmFyIEFzeW5jV29ya2VyRXZlbnQ7XG4oZnVuY3Rpb24gKEFzeW5jV29ya2VyRXZlbnQpIHtcbiAgICBBc3luY1dvcmtlckV2ZW50W1wiUnVuXCJdID0gXCJBc3luY1dvcmtlckV2ZW50LlJ1blwiO1xuICAgIEFzeW5jV29ya2VyRXZlbnRbXCJUaHJlYWRTcGF3blwiXSA9IFwiQXN5bmNXb3JrZXJFdmVudC5UaHJlYWRTcGF3blwiO1xufSkoQXN5bmNXb3JrZXJFdmVudCB8fCAoQXN5bmNXb3JrZXJFdmVudCA9IHt9KSk7XG5leHBvcnQgdmFyIFRhc2tXb3JrZXJFdmVudDtcbihmdW5jdGlvbiAoVGFza1dvcmtlckV2ZW50KSB7XG4gICAgVGFza1dvcmtlckV2ZW50W1wiSW5pdFwiXSA9IFwiVGFza1dvcmtlckV2ZW50LkluaXRcIjtcbn0pKFRhc2tXb3JrZXJFdmVudCB8fCAoVGFza1dvcmtlckV2ZW50ID0ge30pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./types.ts\n");

/***/ }),

/***/ "./wrf_buffer.ts":
/*!***********************!*\
  !*** ./wrf_buffer.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WrfBuffer\": () => (/* binding */ WrfBuffer),\n/* harmony export */   \"classesToExtend\": () => (/* binding */ classesToExtend),\n/* harmony export */   \"containsWrfBuffer\": () => (/* binding */ containsWrfBuffer),\n/* harmony export */   \"overwriteTypedArraysWithWrfArrays\": () => (/* binding */ overwriteTypedArraysWithWrfArrays),\n/* harmony export */   \"getCachedWrfBuffer\": () => (/* binding */ getCachedWrfBuffer),\n/* harmony export */   \"isWrfBuffer\": () => (/* binding */ isWrfBuffer),\n/* harmony export */   \"checkValidWrfArray\": () => (/* binding */ checkValidWrfArray),\n/* harmony export */   \"allocatedArcs\": () => (/* binding */ allocatedArcs),\n/* harmony export */   \"allocatedVecs\": () => (/* binding */ allocatedVecs),\n/* harmony export */   \"getWrfBufferWasm\": () => (/* binding */ getWrfBufferWasm),\n/* harmony export */   \"unregisterMutableBuffer\": () => (/* binding */ unregisterMutableBuffer),\n/* harmony export */   \"getWrfBufferCef\": () => (/* binding */ getWrfBufferCef)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n/* harmony import */ var _wrf_test__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrf_test */ \"./wrf_test.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Wrapper around SharedArrayBuffer to encapsulate ownership of particular segments of it\n\n\n\n// TODO(Paras) - Make sure we monkeypatch on web workers as well\nclass WrfBuffer extends SharedArrayBuffer {\n    constructor(buffer, bufferData) {\n        super(0);\n        this.__wrflibWasmBuffer = buffer;\n        this.__wrflibBufferData = bufferData;\n    }\n    // TODO(Paras): Actually enforce this flag and prevent mutation of WrfArrays marked as readonly.\n    // Potentially, we can do this by hashing read only buffer data and periodically checking in debug\n    // builds if they have been modified/raising errors.\n    get readonly() {\n        return this.__wrflibBufferData.readonly;\n    }\n    // The only 2 methods on SharedArrayBuffer class to override:\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#instance_properties\n    get byteLength() {\n        return this.__wrflibWasmBuffer.byteLength;\n    }\n    slice(...args) {\n        return this.__wrflibWasmBuffer.slice(...args);\n    }\n}\n// This class is a drop-in replacement for all typed arrays\n// It uses WrfBuffer as a handle for underlying buffer as the object that keeps underlying data around\n// Requirements:\n//  * The underlying typed array behaves like it was created over the original view\n//  * When the new typed array (potentially with different class name) is created from the buffer of the original one,\n//  they share the same handle\n//\n// The Rust side assumes that underlying data buffer is immutable,\n// however it still could be accidentally modified on JS side leading to weird behavior\n// TODO(Dmitry): Throw an error if there is mutation of the data\nfunction wrfBufferExtends(cls) {\n    return class WrfTypedArray extends cls {\n        constructor(...args) {\n            const buffer = args[0];\n            if (typeof buffer === \"object\" && buffer instanceof WrfBuffer) {\n                // Fill in byteOffset if that's omitted.\n                if (args.length < 2) {\n                    args[1] = buffer.__wrflibBufferData.bufferPtr;\n                }\n                // Fill in length (in elements, not in bytes) if that's omitted.\n                if (args.length < 3) {\n                    args[2] = Math.floor((buffer.__wrflibBufferData.bufferPtr +\n                        buffer.__wrflibBufferData.bufferLen -\n                        args[1]) /\n                        cls.BYTES_PER_ELEMENT);\n                }\n                if (args[1] < buffer.__wrflibBufferData.bufferPtr) {\n                    throw new Error(`Byte_offset ${args[1]} is out of bounds`);\n                }\n                if (args[1] + args[2] * cls.BYTES_PER_ELEMENT >\n                    buffer.__wrflibBufferData.bufferPtr +\n                        buffer.__wrflibBufferData.bufferLen) {\n                    throw new Error(`Byte_offset ${args[1]} + length ${args[2]} is out of bounds`);\n                }\n                // Whenever we create WrfUintArray using WrfBuffer as first argument\n                // pass the underlying full wasm_buffer further\n                args[0] = buffer.__wrflibWasmBuffer;\n                super(...args);\n                this.__wrflibBuffer = buffer;\n            }\n            else {\n                super(...args);\n            }\n        }\n        get buffer() {\n            return this.__wrflibBuffer || super.buffer;\n        }\n        subarray(begin = 0, end = this.length) {\n            if (begin < 0) {\n                begin = this.length + begin;\n            }\n            if (end < 0) {\n                end = this.length + end;\n            }\n            if (end < begin) {\n                end = begin;\n            }\n            return new WrfTypedArray(this.buffer, this.byteOffset + begin * this.BYTES_PER_ELEMENT, end - begin);\n        }\n    };\n}\n// Extending all typed arrays\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#indexed_collections\nconst classesToExtend = {\n    Int8Array: \"WrfInt8Array\",\n    Uint8Array: \"WrfUint8Array\",\n    Uint8ClampedArray: \"WrfUint8ClampedArray\",\n    Int16Array: \"WrfInt16Array\",\n    Uint16Array: \"WrfUint16Array\",\n    Uint16ClampedArray: \"WrfUint16ClampedArray\",\n    Int32Array: \"WrfInt32Array\",\n    Uint32Array: \"WrfUint32Array\",\n    Float32Array: \"WrfFloat32Array\",\n    Float64Array: \"WrfFloat64Array\",\n    BigInt64Array: \"WrfBigInt64Array\",\n    BigUint64Array: \"WrfBigUint64Array\",\n    DataView: \"WrfDataView\",\n};\nfor (const [cls, wrfCls] of Object.entries(classesToExtend)) {\n    // Get a new type name by prefixing old one with \"Wrf\".\n    // e.g. Uint8Array is extended by WrfUint8Array, etc\n    if (cls in self) {\n        // @ts-ignore\n        self[wrfCls] = wrfBufferExtends(self[cls]);\n    }\n}\n// Checks if the given object itself or recursively contains WrfBuffers.\n// Exported for tests.\nfunction containsWrfBuffer(object) {\n    if (typeof object != \"object\" || object === null) {\n        return false;\n    }\n    if (Object.prototype.hasOwnProperty.call(object, \"__wrflibBuffer\")) {\n        return true;\n    }\n    // Only supporting nesting for arrays, plain objects, maps and sets similar to StructuredClone algorithm\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types\n    if (Array.isArray(object) || object instanceof Set || object instanceof Map) {\n        for (const entry of object) {\n            if (containsWrfBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    else if (Object.getPrototypeOf(object) === Object.getPrototypeOf({})) {\n        for (const entry of Object.entries(object)) {\n            if (containsWrfBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction patchPostMessage(cls) {\n    const origPostMessage = cls.postMessage;\n    // Explicitly NOT a fat arrow (=>) since we want to keep the original `this`.\n    cls.postMessage = function (...args) {\n        if (containsWrfBuffer(args[0])) {\n            // TODO(Dmitry): add a better error message showing the exact location of typed arrays\n            throw new Error(\"Sending WrfBuffers to/from workers is not supported - \" +\n                \"use .slice() on typed array instead to make an explicit copy\");\n        }\n        origPostMessage.apply(this, args);\n    };\n}\nfunction overwriteTypedArraysWithWrfArrays() {\n    for (const [cls, wrfCls] of Object.entries(classesToExtend)) {\n        if (cls in self) {\n            // @ts-ignore\n            self[cls] = self[wrfCls];\n        }\n    }\n    patchPostMessage(self);\n    patchPostMessage(self.Worker);\n    patchPostMessage(self.MessagePort);\n}\nconst wrfBufferCache = new WeakMap();\nfunction getCachedWrfBuffer(wrfBuffer, fallbackArray) {\n    var _a;\n    if (!(\n    // Overwrite the cached value if we return a pointer to a buffer of a different type\n    // For example, Rust code may cast a float to an u8 and return the same buffer pointer.\n    (((_a = wrfBufferCache.get(wrfBuffer)) === null || _a === void 0 ? void 0 : _a.BYTES_PER_ELEMENT) ===\n        fallbackArray.BYTES_PER_ELEMENT))) {\n        wrfBufferCache.set(wrfBuffer, fallbackArray);\n    }\n    return wrfBufferCache.get(wrfBuffer);\n}\nfunction isWrfBuffer(potentialWrfBuffer) {\n    return (typeof potentialWrfBuffer === \"object\" &&\n        potentialWrfBuffer instanceof WrfBuffer);\n}\nfunction checkValidWrfArray(wrfArray) {\n    if (!isWrfBuffer(wrfArray.buffer)) {\n        throw new Error(\"wrfArray.buffer is not a WrfBuffer in checkValidWrfArray\");\n    }\n    const buffer = wrfArray.buffer;\n    const bufferCoversWrfBuffer = wrfArray.byteOffset === buffer.__wrflibBufferData.bufferPtr &&\n        wrfArray.byteLength === buffer.__wrflibBufferData.bufferLen;\n    if (!bufferCoversWrfBuffer) {\n        throw new Error(\"Called Rust with a buffer that does not span the entire underlying WrfBuffer\");\n    }\n    const paramType = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(wrfArray, buffer.readonly);\n    if (paramType !== buffer.__wrflibBufferData.paramType) {\n        throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${_types__WEBPACK_IMPORTED_MODULE_1__.WrfParamType[buffer.__wrflibBufferData.paramType]} but got ${_types__WEBPACK_IMPORTED_MODULE_1__.WrfParamType[paramType]}`);\n    }\n}\n// Cache WrfBuffers so that we have a stable identity for WrfBuffers pointing to the same\n// Arc. This is useful for any downstream caches in user code.\nconst bufferCache = {};\nconst allocatedArcs = {};\nconst allocatedVecs = {};\nconst bufferRegistry = new FinalizationRegistry(({ arcPtr, destructor, }) => {\n    if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n        if (allocatedArcs[arcPtr] === false) {\n            throw new Error(`Deallocating an already deallocated arcPtr ${arcPtr}`);\n        }\n        else if (allocatedArcs[arcPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated arcPtr ${arcPtr}`);\n        }\n        allocatedArcs[arcPtr] = false;\n    }\n    delete bufferCache[arcPtr];\n    if (destructor)\n        destructor(arcPtr);\n});\nconst mutableWrfBufferRegistry = new FinalizationRegistry(({ bufferData, destructor, }) => {\n    if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n        const { bufferPtr } = bufferData;\n        if (allocatedVecs[bufferPtr] === false) {\n            throw new Error(`Deallocating an already deallocated bufferPtr ${bufferPtr}`);\n        }\n        else if (allocatedVecs[bufferPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated bufferPtr ${bufferPtr}`);\n        }\n        allocatedVecs[bufferPtr] = false;\n    }\n    destructor(bufferData);\n});\n// Return a buffer with a stable identity based on arcPtr.\n// Register callbacks so we de-allocate the buffer when it goes out of scope.\nconst getWrfBufferWasm = (wasmMemory, bufferData, destructor, mutableDestructor) => {\n    var _a;\n    if (bufferData.readonly) {\n        if (!((_a = bufferCache[bufferData.arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n                allocatedArcs[bufferData.arcPtr] = true;\n            }\n            const wrfBuffer = new WrfBuffer(wasmMemory.buffer, bufferData);\n            bufferRegistry.register(wrfBuffer, {\n                arcPtr: bufferData.arcPtr,\n                destructor,\n                /* no unregisterToken here since we never need to unregister */\n            });\n            bufferCache[bufferData.arcPtr] = new WeakRef(wrfBuffer);\n        }\n        else {\n            // If we already hold a reference, decrement the Arc we were just given;\n            // otherwise we leak memory.\n            destructor(bufferData.arcPtr);\n        }\n        return bufferCache[bufferData.arcPtr].deref();\n    }\n    else {\n        if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n            allocatedVecs[bufferData.bufferPtr] = true;\n        }\n        const wrfBuffer = new WrfBuffer(wasmMemory.buffer, bufferData);\n        mutableWrfBufferRegistry.register(wrfBuffer, {\n            bufferData,\n            destructor: mutableDestructor,\n        }, wrfBuffer);\n        return wrfBuffer;\n    }\n};\n// Remove mutable WrfBuffers without running destructors. This is useful\n// when transferring ownership of buffers to Rust without deallocating data.\nconst unregisterMutableBuffer = (wrfBuffer) => {\n    if (wrfBuffer.readonly) {\n        throw new Error(\"`unregisterMutableBuffer` should only be called on mutable WrfBuffers\");\n    }\n    mutableWrfBufferRegistry.unregister(wrfBuffer);\n    if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n        allocatedVecs[wrfBuffer.__wrflibBufferData.bufferPtr] = false;\n    }\n};\n// Return a buffer with a stable identity based on arcPtr\nconst getWrfBufferCef = (buffer, arcPtr, paramType) => {\n    var _a;\n    if (arcPtr) {\n        if (!((_a = bufferCache[arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            const wrfBuffer = new WrfBuffer(buffer, {\n                bufferPtr: 0,\n                bufferLen: buffer.byteLength,\n                readonly: true,\n                paramType,\n                // TODO(Paras): These fields below do not apply to CEF\n                arcPtr: -1,\n            });\n            bufferRegistry.register(wrfBuffer, { arcPtr });\n            bufferCache[arcPtr] = new WeakRef(wrfBuffer);\n        }\n        return bufferCache[arcPtr].deref();\n    }\n    else {\n        return new WrfBuffer(buffer, {\n            bufferPtr: 0,\n            bufferLen: buffer.byteLength,\n            bufferCap: buffer.byteLength,\n            paramType,\n            readonly: false,\n        });\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfYnVmZmVyLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cmYvLi93cmZfYnVmZmVyLnRzP2JiMGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFdyYXBwZXIgYXJvdW5kIFNoYXJlZEFycmF5QnVmZmVyIHRvIGVuY2Fwc3VsYXRlIG93bmVyc2hpcCBvZiBwYXJ0aWN1bGFyIHNlZ21lbnRzIG9mIGl0XG5pbXBvcnQgeyBnZXRXcmZQYXJhbVR5cGUgfSBmcm9tIFwiLi9jb21tb25cIjtcbmltcG9ydCB7IFdyZlBhcmFtVHlwZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBpblRlc3QgfSBmcm9tIFwiLi93cmZfdGVzdFwiO1xuLy8gVE9ETyhQYXJhcykgLSBNYWtlIHN1cmUgd2UgbW9ua2V5cGF0Y2ggb24gd2ViIHdvcmtlcnMgYXMgd2VsbFxuZXhwb3J0IGNsYXNzIFdyZkJ1ZmZlciBleHRlbmRzIFNoYXJlZEFycmF5QnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGJ1ZmZlckRhdGEpIHtcbiAgICAgICAgc3VwZXIoMCk7XG4gICAgICAgIHRoaXMuX193cmZsaWJXYXNtQnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLl9fd3JmbGliQnVmZmVyRGF0YSA9IGJ1ZmZlckRhdGE7XG4gICAgfVxuICAgIC8vIFRPRE8oUGFyYXMpOiBBY3R1YWxseSBlbmZvcmNlIHRoaXMgZmxhZyBhbmQgcHJldmVudCBtdXRhdGlvbiBvZiBXcmZBcnJheXMgbWFya2VkIGFzIHJlYWRvbmx5LlxuICAgIC8vIFBvdGVudGlhbGx5LCB3ZSBjYW4gZG8gdGhpcyBieSBoYXNoaW5nIHJlYWQgb25seSBidWZmZXIgZGF0YSBhbmQgcGVyaW9kaWNhbGx5IGNoZWNraW5nIGluIGRlYnVnXG4gICAgLy8gYnVpbGRzIGlmIHRoZXkgaGF2ZSBiZWVuIG1vZGlmaWVkL3JhaXNpbmcgZXJyb3JzLlxuICAgIGdldCByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJCdWZmZXJEYXRhLnJlYWRvbmx5O1xuICAgIH1cbiAgICAvLyBUaGUgb25seSAyIG1ldGhvZHMgb24gU2hhcmVkQXJyYXlCdWZmZXIgY2xhc3MgdG8gb3ZlcnJpZGU6XG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1NoYXJlZEFycmF5QnVmZmVyI2luc3RhbmNlX3Byb3BlcnRpZXNcbiAgICBnZXQgYnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJXYXNtQnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHNsaWNlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJXYXNtQnVmZmVyLnNsaWNlKC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8vIFRoaXMgY2xhc3MgaXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciBhbGwgdHlwZWQgYXJyYXlzXG4vLyBJdCB1c2VzIFdyZkJ1ZmZlciBhcyBhIGhhbmRsZSBmb3IgdW5kZXJseWluZyBidWZmZXIgYXMgdGhlIG9iamVjdCB0aGF0IGtlZXBzIHVuZGVybHlpbmcgZGF0YSBhcm91bmRcbi8vIFJlcXVpcmVtZW50czpcbi8vICAqIFRoZSB1bmRlcmx5aW5nIHR5cGVkIGFycmF5IGJlaGF2ZXMgbGlrZSBpdCB3YXMgY3JlYXRlZCBvdmVyIHRoZSBvcmlnaW5hbCB2aWV3XG4vLyAgKiBXaGVuIHRoZSBuZXcgdHlwZWQgYXJyYXkgKHBvdGVudGlhbGx5IHdpdGggZGlmZmVyZW50IGNsYXNzIG5hbWUpIGlzIGNyZWF0ZWQgZnJvbSB0aGUgYnVmZmVyIG9mIHRoZSBvcmlnaW5hbCBvbmUsXG4vLyAgdGhleSBzaGFyZSB0aGUgc2FtZSBoYW5kbGVcbi8vXG4vLyBUaGUgUnVzdCBzaWRlIGFzc3VtZXMgdGhhdCB1bmRlcmx5aW5nIGRhdGEgYnVmZmVyIGlzIGltbXV0YWJsZSxcbi8vIGhvd2V2ZXIgaXQgc3RpbGwgY291bGQgYmUgYWNjaWRlbnRhbGx5IG1vZGlmaWVkIG9uIEpTIHNpZGUgbGVhZGluZyB0byB3ZWlyZCBiZWhhdmlvclxuLy8gVE9ETyhEbWl0cnkpOiBUaHJvdyBhbiBlcnJvciBpZiB0aGVyZSBpcyBtdXRhdGlvbiBvZiB0aGUgZGF0YVxuZnVuY3Rpb24gd3JmQnVmZmVyRXh0ZW5kcyhjbHMpIHtcbiAgICByZXR1cm4gY2xhc3MgV3JmVHlwZWRBcnJheSBleHRlbmRzIGNscyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gXCJvYmplY3RcIiAmJiBidWZmZXIgaW5zdGFuY2VvZiBXcmZCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIGluIGJ5dGVPZmZzZXQgaWYgdGhhdCdzIG9taXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICBhcmdzWzFdID0gYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5idWZmZXJQdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbGwgaW4gbGVuZ3RoIChpbiBlbGVtZW50cywgbm90IGluIGJ5dGVzKSBpZiB0aGF0J3Mgb21pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMl0gPSBNYXRoLmZsb29yKChidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlclB0ciArXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlckxlbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzFdKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJnc1sxXSA8IGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQnl0ZV9vZmZzZXQgJHthcmdzWzFdfSBpcyBvdXQgb2YgYm91bmRzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzFdICsgYXJnc1syXSAqIGNscy5CWVRFU19QRVJfRUxFTUVOVCA+XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQnl0ZV9vZmZzZXQgJHthcmdzWzFdfSArIGxlbmd0aCAke2FyZ3NbMl19IGlzIG91dCBvZiBib3VuZHNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbmV2ZXIgd2UgY3JlYXRlIFdyZlVpbnRBcnJheSB1c2luZyBXcmZCdWZmZXIgYXMgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAvLyBwYXNzIHRoZSB1bmRlcmx5aW5nIGZ1bGwgd2FzbV9idWZmZXIgZnVydGhlclxuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBidWZmZXIuX193cmZsaWJXYXNtQnVmZmVyO1xuICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX193cmZsaWJCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgYnVmZmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJCdWZmZXIgfHwgc3VwZXIuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHN1YmFycmF5KGJlZ2luID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDApIHtcbiAgICAgICAgICAgICAgICBiZWdpbiA9IHRoaXMubGVuZ3RoICsgYmVnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoICsgZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA8IGJlZ2luKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gYmVnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyZlR5cGVkQXJyYXkodGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIGJlZ2luICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVCwgZW5kIC0gYmVnaW4pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIEV4dGVuZGluZyBhbGwgdHlwZWQgYXJyYXlzXG4vLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMjaW5kZXhlZF9jb2xsZWN0aW9uc1xuZXhwb3J0IGNvbnN0IGNsYXNzZXNUb0V4dGVuZCA9IHtcbiAgICBJbnQ4QXJyYXk6IFwiV3JmSW50OEFycmF5XCIsXG4gICAgVWludDhBcnJheTogXCJXcmZVaW50OEFycmF5XCIsXG4gICAgVWludDhDbGFtcGVkQXJyYXk6IFwiV3JmVWludDhDbGFtcGVkQXJyYXlcIixcbiAgICBJbnQxNkFycmF5OiBcIldyZkludDE2QXJyYXlcIixcbiAgICBVaW50MTZBcnJheTogXCJXcmZVaW50MTZBcnJheVwiLFxuICAgIFVpbnQxNkNsYW1wZWRBcnJheTogXCJXcmZVaW50MTZDbGFtcGVkQXJyYXlcIixcbiAgICBJbnQzMkFycmF5OiBcIldyZkludDMyQXJyYXlcIixcbiAgICBVaW50MzJBcnJheTogXCJXcmZVaW50MzJBcnJheVwiLFxuICAgIEZsb2F0MzJBcnJheTogXCJXcmZGbG9hdDMyQXJyYXlcIixcbiAgICBGbG9hdDY0QXJyYXk6IFwiV3JmRmxvYXQ2NEFycmF5XCIsXG4gICAgQmlnSW50NjRBcnJheTogXCJXcmZCaWdJbnQ2NEFycmF5XCIsXG4gICAgQmlnVWludDY0QXJyYXk6IFwiV3JmQmlnVWludDY0QXJyYXlcIixcbiAgICBEYXRhVmlldzogXCJXcmZEYXRhVmlld1wiLFxufTtcbmZvciAoY29uc3QgW2Nscywgd3JmQ2xzXSBvZiBPYmplY3QuZW50cmllcyhjbGFzc2VzVG9FeHRlbmQpKSB7XG4gICAgLy8gR2V0IGEgbmV3IHR5cGUgbmFtZSBieSBwcmVmaXhpbmcgb2xkIG9uZSB3aXRoIFwiV3JmXCIuXG4gICAgLy8gZS5nLiBVaW50OEFycmF5IGlzIGV4dGVuZGVkIGJ5IFdyZlVpbnQ4QXJyYXksIGV0Y1xuICAgIGlmIChjbHMgaW4gc2VsZikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHNlbGZbd3JmQ2xzXSA9IHdyZkJ1ZmZlckV4dGVuZHMoc2VsZltjbHNdKTtcbiAgICB9XG59XG4vLyBDaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBpdHNlbGYgb3IgcmVjdXJzaXZlbHkgY29udGFpbnMgV3JmQnVmZmVycy5cbi8vIEV4cG9ydGVkIGZvciB0ZXN0cy5cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1dyZkJ1ZmZlcihvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPSBcIm9iamVjdFwiIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBcIl9fd3JmbGliQnVmZmVyXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBPbmx5IHN1cHBvcnRpbmcgbmVzdGluZyBmb3IgYXJyYXlzLCBwbGFpbiBvYmplY3RzLCBtYXBzIGFuZCBzZXRzIHNpbWlsYXIgdG8gU3RydWN0dXJlZENsb25lIGFsZ29yaXRobVxuICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1dvcmtlcnNfQVBJL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtI3N1cHBvcnRlZF90eXBlc1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgfHwgb2JqZWN0IGluc3RhbmNlb2YgU2V0IHx8IG9iamVjdCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zV3JmQnVmZmVyKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0KSkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zV3JmQnVmZmVyKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhdGNoUG9zdE1lc3NhZ2UoY2xzKSB7XG4gICAgY29uc3Qgb3JpZ1Bvc3RNZXNzYWdlID0gY2xzLnBvc3RNZXNzYWdlO1xuICAgIC8vIEV4cGxpY2l0bHkgTk9UIGEgZmF0IGFycm93ICg9Pikgc2luY2Ugd2Ugd2FudCB0byBrZWVwIHRoZSBvcmlnaW5hbCBgdGhpc2AuXG4gICAgY2xzLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zV3JmQnVmZmVyKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAvLyBUT0RPKERtaXRyeSk6IGFkZCBhIGJldHRlciBlcnJvciBtZXNzYWdlIHNob3dpbmcgdGhlIGV4YWN0IGxvY2F0aW9uIG9mIHR5cGVkIGFycmF5c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZGluZyBXcmZCdWZmZXJzIHRvL2Zyb20gd29ya2VycyBpcyBub3Qgc3VwcG9ydGVkIC0gXCIgK1xuICAgICAgICAgICAgICAgIFwidXNlIC5zbGljZSgpIG9uIHR5cGVkIGFycmF5IGluc3RlYWQgdG8gbWFrZSBhbiBleHBsaWNpdCBjb3B5XCIpO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdQb3N0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJ3cml0ZVR5cGVkQXJyYXlzV2l0aFdyZkFycmF5cygpIHtcbiAgICBmb3IgKGNvbnN0IFtjbHMsIHdyZkNsc10gb2YgT2JqZWN0LmVudHJpZXMoY2xhc3Nlc1RvRXh0ZW5kKSkge1xuICAgICAgICBpZiAoY2xzIGluIHNlbGYpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHNlbGZbY2xzXSA9IHNlbGZbd3JmQ2xzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRjaFBvc3RNZXNzYWdlKHNlbGYpO1xuICAgIHBhdGNoUG9zdE1lc3NhZ2Uoc2VsZi5Xb3JrZXIpO1xuICAgIHBhdGNoUG9zdE1lc3NhZ2Uoc2VsZi5NZXNzYWdlUG9ydCk7XG59XG5jb25zdCB3cmZCdWZmZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVkV3JmQnVmZmVyKHdyZkJ1ZmZlciwgZmFsbGJhY2tBcnJheSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIShcbiAgICAvLyBPdmVyd3JpdGUgdGhlIGNhY2hlZCB2YWx1ZSBpZiB3ZSByZXR1cm4gYSBwb2ludGVyIHRvIGEgYnVmZmVyIG9mIGEgZGlmZmVyZW50IHR5cGVcbiAgICAvLyBGb3IgZXhhbXBsZSwgUnVzdCBjb2RlIG1heSBjYXN0IGEgZmxvYXQgdG8gYW4gdTggYW5kIHJldHVybiB0aGUgc2FtZSBidWZmZXIgcG9pbnRlci5cbiAgICAoKChfYSA9IHdyZkJ1ZmZlckNhY2hlLmdldCh3cmZCdWZmZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuQllURVNfUEVSX0VMRU1FTlQpID09PVxuICAgICAgICBmYWxsYmFja0FycmF5LkJZVEVTX1BFUl9FTEVNRU5UKSkpIHtcbiAgICAgICAgd3JmQnVmZmVyQ2FjaGUuc2V0KHdyZkJ1ZmZlciwgZmFsbGJhY2tBcnJheSk7XG4gICAgfVxuICAgIHJldHVybiB3cmZCdWZmZXJDYWNoZS5nZXQod3JmQnVmZmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1dyZkJ1ZmZlcihwb3RlbnRpYWxXcmZCdWZmZXIpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwb3RlbnRpYWxXcmZCdWZmZXIgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcG90ZW50aWFsV3JmQnVmZmVyIGluc3RhbmNlb2YgV3JmQnVmZmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZhbGlkV3JmQXJyYXkod3JmQXJyYXkpIHtcbiAgICBpZiAoIWlzV3JmQnVmZmVyKHdyZkFycmF5LmJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3JmQXJyYXkuYnVmZmVyIGlzIG5vdCBhIFdyZkJ1ZmZlciBpbiBjaGVja1ZhbGlkV3JmQXJyYXlcIik7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IHdyZkFycmF5LmJ1ZmZlcjtcbiAgICBjb25zdCBidWZmZXJDb3ZlcnNXcmZCdWZmZXIgPSB3cmZBcnJheS5ieXRlT2Zmc2V0ID09PSBidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlclB0ciAmJlxuICAgICAgICB3cmZBcnJheS5ieXRlTGVuZ3RoID09PSBidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlckxlbjtcbiAgICBpZiAoIWJ1ZmZlckNvdmVyc1dyZkJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgUnVzdCB3aXRoIGEgYnVmZmVyIHRoYXQgZG9lcyBub3Qgc3BhbiB0aGUgZW50aXJlIHVuZGVybHlpbmcgV3JmQnVmZmVyXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbVR5cGUgPSBnZXRXcmZQYXJhbVR5cGUod3JmQXJyYXksIGJ1ZmZlci5yZWFkb25seSk7XG4gICAgaWYgKHBhcmFtVHlwZSAhPT0gYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5wYXJhbVR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY2FsbCBSdXN0IHdpdGggYSBidWZmZXIgd2hpY2ggaGFzIGJlZW4gY2FzdCB0byBhIGRpZmZlcmVudCB0eXBlLiBFeHBlY3RlZCAke1dyZlBhcmFtVHlwZVtidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLnBhcmFtVHlwZV19IGJ1dCBnb3QgJHtXcmZQYXJhbVR5cGVbcGFyYW1UeXBlXX1gKTtcbiAgICB9XG59XG4vLyBDYWNoZSBXcmZCdWZmZXJzIHNvIHRoYXQgd2UgaGF2ZSBhIHN0YWJsZSBpZGVudGl0eSBmb3IgV3JmQnVmZmVycyBwb2ludGluZyB0byB0aGUgc2FtZVxuLy8gQXJjLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYW55IGRvd25zdHJlYW0gY2FjaGVzIGluIHVzZXIgY29kZS5cbmNvbnN0IGJ1ZmZlckNhY2hlID0ge307XG5leHBvcnQgY29uc3QgYWxsb2NhdGVkQXJjcyA9IHt9O1xuZXhwb3J0IGNvbnN0IGFsbG9jYXRlZFZlY3MgPSB7fTtcbmNvbnN0IGJ1ZmZlclJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCh7IGFyY1B0ciwgZGVzdHJ1Y3RvciwgfSkgPT4ge1xuICAgIGlmIChpblRlc3QpIHtcbiAgICAgICAgaWYgKGFsbG9jYXRlZEFyY3NbYXJjUHRyXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVhbGxvY2F0aW5nIGFuIGFscmVhZHkgZGVhbGxvY2F0ZWQgYXJjUHRyICR7YXJjUHRyfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG9jYXRlZEFyY3NbYXJjUHRyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlYWxsb2NhdGluZyBhbiB1bmFsbG9jYXRlZCBhcmNQdHIgJHthcmNQdHJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsb2NhdGVkQXJjc1thcmNQdHJdID0gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSBidWZmZXJDYWNoZVthcmNQdHJdO1xuICAgIGlmIChkZXN0cnVjdG9yKVxuICAgICAgICBkZXN0cnVjdG9yKGFyY1B0cik7XG59KTtcbmNvbnN0IG11dGFibGVXcmZCdWZmZXJSZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoeyBidWZmZXJEYXRhLCBkZXN0cnVjdG9yLCB9KSA9PiB7XG4gICAgaWYgKGluVGVzdCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlclB0ciB9ID0gYnVmZmVyRGF0YTtcbiAgICAgICAgaWYgKGFsbG9jYXRlZFZlY3NbYnVmZmVyUHRyXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVhbGxvY2F0aW5nIGFuIGFscmVhZHkgZGVhbGxvY2F0ZWQgYnVmZmVyUHRyICR7YnVmZmVyUHRyfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG9jYXRlZFZlY3NbYnVmZmVyUHRyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlYWxsb2NhdGluZyBhbiB1bmFsbG9jYXRlZCBidWZmZXJQdHIgJHtidWZmZXJQdHJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsb2NhdGVkVmVjc1tidWZmZXJQdHJdID0gZmFsc2U7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoYnVmZmVyRGF0YSk7XG59KTtcbi8vIFJldHVybiBhIGJ1ZmZlciB3aXRoIGEgc3RhYmxlIGlkZW50aXR5IGJhc2VkIG9uIGFyY1B0ci5cbi8vIFJlZ2lzdGVyIGNhbGxiYWNrcyBzbyB3ZSBkZS1hbGxvY2F0ZSB0aGUgYnVmZmVyIHdoZW4gaXQgZ29lcyBvdXQgb2Ygc2NvcGUuXG5leHBvcnQgY29uc3QgZ2V0V3JmQnVmZmVyV2FzbSA9ICh3YXNtTWVtb3J5LCBidWZmZXJEYXRhLCBkZXN0cnVjdG9yLCBtdXRhYmxlRGVzdHJ1Y3RvcikgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYnVmZmVyRGF0YS5yZWFkb25seSkge1xuICAgICAgICBpZiAoISgoX2EgPSBidWZmZXJDYWNoZVtidWZmZXJEYXRhLmFyY1B0cl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXJlZigpKSkge1xuICAgICAgICAgICAgaWYgKGluVGVzdCkge1xuICAgICAgICAgICAgICAgIGFsbG9jYXRlZEFyY3NbYnVmZmVyRGF0YS5hcmNQdHJdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdyZkJ1ZmZlciA9IG5ldyBXcmZCdWZmZXIod2FzbU1lbW9yeS5idWZmZXIsIGJ1ZmZlckRhdGEpO1xuICAgICAgICAgICAgYnVmZmVyUmVnaXN0cnkucmVnaXN0ZXIod3JmQnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgYXJjUHRyOiBidWZmZXJEYXRhLmFyY1B0cixcbiAgICAgICAgICAgICAgICBkZXN0cnVjdG9yLFxuICAgICAgICAgICAgICAgIC8qIG5vIHVucmVnaXN0ZXJUb2tlbiBoZXJlIHNpbmNlIHdlIG5ldmVyIG5lZWQgdG8gdW5yZWdpc3RlciAqL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBidWZmZXJDYWNoZVtidWZmZXJEYXRhLmFyY1B0cl0gPSBuZXcgV2Vha1JlZih3cmZCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBob2xkIGEgcmVmZXJlbmNlLCBkZWNyZW1lbnQgdGhlIEFyYyB3ZSB3ZXJlIGp1c3QgZ2l2ZW47XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbGVhayBtZW1vcnkuXG4gICAgICAgICAgICBkZXN0cnVjdG9yKGJ1ZmZlckRhdGEuYXJjUHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyQ2FjaGVbYnVmZmVyRGF0YS5hcmNQdHJdLmRlcmVmKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5UZXN0KSB7XG4gICAgICAgICAgICBhbGxvY2F0ZWRWZWNzW2J1ZmZlckRhdGEuYnVmZmVyUHRyXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gbmV3IFdyZkJ1ZmZlcih3YXNtTWVtb3J5LmJ1ZmZlciwgYnVmZmVyRGF0YSk7XG4gICAgICAgIG11dGFibGVXcmZCdWZmZXJSZWdpc3RyeS5yZWdpc3Rlcih3cmZCdWZmZXIsIHtcbiAgICAgICAgICAgIGJ1ZmZlckRhdGEsXG4gICAgICAgICAgICBkZXN0cnVjdG9yOiBtdXRhYmxlRGVzdHJ1Y3RvcixcbiAgICAgICAgfSwgd3JmQnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHdyZkJ1ZmZlcjtcbiAgICB9XG59O1xuLy8gUmVtb3ZlIG11dGFibGUgV3JmQnVmZmVycyB3aXRob3V0IHJ1bm5pbmcgZGVzdHJ1Y3RvcnMuIFRoaXMgaXMgdXNlZnVsXG4vLyB3aGVuIHRyYW5zZmVycmluZyBvd25lcnNoaXAgb2YgYnVmZmVycyB0byBSdXN0IHdpdGhvdXQgZGVhbGxvY2F0aW5nIGRhdGEuXG5leHBvcnQgY29uc3QgdW5yZWdpc3Rlck11dGFibGVCdWZmZXIgPSAod3JmQnVmZmVyKSA9PiB7XG4gICAgaWYgKHdyZkJ1ZmZlci5yZWFkb25seSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdW5yZWdpc3Rlck11dGFibGVCdWZmZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBtdXRhYmxlIFdyZkJ1ZmZlcnNcIik7XG4gICAgfVxuICAgIG11dGFibGVXcmZCdWZmZXJSZWdpc3RyeS51bnJlZ2lzdGVyKHdyZkJ1ZmZlcik7XG4gICAgaWYgKGluVGVzdCkge1xuICAgICAgICBhbGxvY2F0ZWRWZWNzW3dyZkJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyXSA9IGZhbHNlO1xuICAgIH1cbn07XG4vLyBSZXR1cm4gYSBidWZmZXIgd2l0aCBhIHN0YWJsZSBpZGVudGl0eSBiYXNlZCBvbiBhcmNQdHJcbmV4cG9ydCBjb25zdCBnZXRXcmZCdWZmZXJDZWYgPSAoYnVmZmVyLCBhcmNQdHIsIHBhcmFtVHlwZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYXJjUHRyKSB7XG4gICAgICAgIGlmICghKChfYSA9IGJ1ZmZlckNhY2hlW2FyY1B0cl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXJlZigpKSkge1xuICAgICAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gbmV3IFdyZkJ1ZmZlcihidWZmZXIsIHtcbiAgICAgICAgICAgICAgICBidWZmZXJQdHI6IDAsXG4gICAgICAgICAgICAgICAgYnVmZmVyTGVuOiBidWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJhbVR5cGUsXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhQYXJhcyk6IFRoZXNlIGZpZWxkcyBiZWxvdyBkbyBub3QgYXBwbHkgdG8gQ0VGXG4gICAgICAgICAgICAgICAgYXJjUHRyOiAtMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnVmZmVyUmVnaXN0cnkucmVnaXN0ZXIod3JmQnVmZmVyLCB7IGFyY1B0ciB9KTtcbiAgICAgICAgICAgIGJ1ZmZlckNhY2hlW2FyY1B0cl0gPSBuZXcgV2Vha1JlZih3cmZCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXJDYWNoZVthcmNQdHJdLmRlcmVmKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFdyZkJ1ZmZlcihidWZmZXIsIHtcbiAgICAgICAgICAgIGJ1ZmZlclB0cjogMCxcbiAgICAgICAgICAgIGJ1ZmZlckxlbjogYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBidWZmZXJDYXA6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgcGFyYW1UeXBlLFxuICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./wrf_buffer.ts\n");

/***/ }),

/***/ "./wrf_test.ts":
/*!*********************!*\
  !*** ./wrf_test.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"expect\": () => (/* binding */ expect),\n/* harmony export */   \"expectThrow\": () => (/* binding */ expectThrow),\n/* harmony export */   \"expectThrowAsync\": () => (/* binding */ expectThrowAsync),\n/* harmony export */   \"expectDeallocationOrUnregister\": () => (/* binding */ expectDeallocationOrUnregister),\n/* harmony export */   \"inTest\": () => (/* binding */ inTest),\n/* harmony export */   \"setInTest\": () => (/* binding */ setInTest)\n/* harmony export */ });\n/* harmony import */ var _type_of_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type_of_runtime */ \"./type_of_runtime.ts\");\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst expect = (actual, expected) => {\n    if (expected === actual) {\n        console.debug(`Success: Got ${actual}, Expected ${expected}`);\n    }\n    else {\n        throw new Error(`Failure: Got ${actual}, Expected ${expected}`);\n    }\n};\n// TODO(Paras): Would be nice to combine the two functions below at some point.\nconst expectThrow = (f, expectedMessage) => {\n    let error;\n    try {\n        f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n};\nconst expectThrowAsync = (f, expectedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n    let error;\n    try {\n        yield f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n});\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst checkConditionTimeout = (condition, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n    const startTime = performance.now();\n    while (!condition() && performance.now() < startTime + timeout) {\n        yield sleep(10);\n    }\n    return condition();\n});\n// Generate some dummy data and then delete it. This usually triggers the garbage collector.\nconst generateGarbage = () => {\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        self[\"garbage_\" + i] = { i };\n    }\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        delete self[\"garbage_\" + i];\n    }\n};\nconst arcAllocated = (callRust, buffer) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!buffer.__wrflibBufferData.readonly)\n        throw new Error(\"arcAllocated called on mutable buffer\");\n    const arcPtr = buffer.__wrflibBufferData.arcPtr;\n    // We still have the buffer here! So it should still be allocated.\n    expect(_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedArcs[arcPtr], true);\n    const [result] = yield callRust(\"check_arc_count\", [`${BigInt(arcPtr)}`]);\n    const [countBeforeDeallocation] = result;\n    expect(countBeforeDeallocation, 1);\n    return arcPtr;\n});\nconst arcDeallocated = (arcPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // From here on out we don't refer to `buffer` any more, so it should get\n    // deallocated, if the garbage collector is any good.\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedArcs[arcPtr] === false;\n    }, 20000), true);\n});\nconst vecDeallocated = (bufferPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // Even though we have the buffer, it might have already been unregistered\n    // when passed to Rust. We shouldn't read/write to it any more. If this is the\n    // case, let's just bail.\n    if (!_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedVecs[bufferPtr])\n        return;\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedVecs[bufferPtr] === false;\n    }, 20000), true);\n});\n// Test that WrfBuffers were deallocated at some point in the next 20 seconds.\n// This is a bit brittle given that there are no guarantees for garbage collection during this time,\n// but observationally this ends up being enough time. The caller must also ensure that the buffer will go out of scope\n// shortly after calling this.\n// We have to pass in `callRust` because we can call this function from a variety of runtimes.\n// Note that assertions on garbage collection are extremely sensitive to exactly how these functions are written,\n// and can easily break if you restucture the function, use a different/newer browser, etc!\nconst expectDeallocationOrUnregister = (callRust, wrfArray) => {\n    // Deallocation code is only run in WASM for now.\n    if (_type_of_runtime__WEBPACK_IMPORTED_MODULE_0__.jsRuntime === \"cef\")\n        return Promise.resolve();\n    const buffer = wrfArray.buffer;\n    return buffer.readonly\n        ? arcAllocated(callRust, buffer).then((arcPtr) => arcDeallocated(arcPtr))\n        : vecDeallocated(buffer.__wrflibBufferData.bufferPtr);\n};\nlet inTest = false;\n// Set this to true to enable testing code\nconst setInTest = (v) => {\n    inTest = v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfdGVzdC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vd3JmX3Rlc3QudHM/MzI5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjEtcHJlc2VudCwgQ3J1aXNlIExMQ1xuLy9cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCxcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFLUFQQUNIRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBqc1J1bnRpbWUgfSBmcm9tIFwiLi90eXBlX29mX3J1bnRpbWVcIjtcbmltcG9ydCB7IGFsbG9jYXRlZEFyY3MsIGFsbG9jYXRlZFZlY3MgfSBmcm9tIFwiLi93cmZfYnVmZmVyXCI7XG5leHBvcnQgY29uc3QgZXhwZWN0ID0gKGFjdHVhbCwgZXhwZWN0ZWQpID0+IHtcbiAgICBpZiAoZXhwZWN0ZWQgPT09IGFjdHVhbCkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKGBTdWNjZXNzOiBHb3QgJHthY3R1YWx9LCBFeHBlY3RlZCAke2V4cGVjdGVkfWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsdXJlOiBHb3QgJHthY3R1YWx9LCBFeHBlY3RlZCAke2V4cGVjdGVkfWApO1xuICAgIH1cbn07XG4vLyBUT0RPKFBhcmFzKTogV291bGQgYmUgbmljZSB0byBjb21iaW5lIHRoZSB0d28gZnVuY3Rpb25zIGJlbG93IGF0IHNvbWUgcG9pbnQuXG5leHBvcnQgY29uc3QgZXhwZWN0VGhyb3cgPSAoZiwgZXhwZWN0ZWRNZXNzYWdlKSA9PiB7XG4gICAgbGV0IGVycm9yO1xuICAgIHRyeSB7XG4gICAgICAgIGYoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgIH1cbiAgICBleHBlY3QoISFlcnJvciwgdHJ1ZSk7XG4gICAgaWYgKGVycm9yICYmIGV4cGVjdGVkTWVzc2FnZSkge1xuICAgICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSwgZXhwZWN0ZWRNZXNzYWdlKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGV4cGVjdFRocm93QXN5bmMgPSAoZiwgZXhwZWN0ZWRNZXNzYWdlKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgICAgeWllbGQgZigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvciA9IGU7XG4gICAgfVxuICAgIGV4cGVjdCghIWVycm9yLCB0cnVlKTtcbiAgICBpZiAoZXJyb3IgJiYgZXhwZWN0ZWRNZXNzYWdlKSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlLCBleHBlY3RlZE1lc3NhZ2UpO1xuICAgIH1cbn0pO1xuY29uc3Qgc2xlZXAgPSAobXMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5jb25zdCBjaGVja0NvbmRpdGlvblRpbWVvdXQgPSAoY29uZGl0aW9uLCB0aW1lb3V0KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB3aGlsZSAoIWNvbmRpdGlvbigpICYmIHBlcmZvcm1hbmNlLm5vdygpIDwgc3RhcnRUaW1lICsgdGltZW91dCkge1xuICAgICAgICB5aWVsZCBzbGVlcCgxMCk7XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb24oKTtcbn0pO1xuLy8gR2VuZXJhdGUgc29tZSBkdW1teSBkYXRhIGFuZCB0aGVuIGRlbGV0ZSBpdC4gVGhpcyB1c3VhbGx5IHRyaWdnZXJzIHRoZSBnYXJiYWdlIGNvbGxlY3Rvci5cbmNvbnN0IGdlbmVyYXRlR2FyYmFnZSA9ICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDAwOyBpKyspIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzZWxmW1wiZ2FyYmFnZV9cIiArIGldID0geyBpIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDA7IGkrKykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGV0ZSBzZWxmW1wiZ2FyYmFnZV9cIiArIGldO1xuICAgIH1cbn07XG5jb25zdCBhcmNBbGxvY2F0ZWQgPSAoY2FsbFJ1c3QsIGJ1ZmZlcikgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKCFidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLnJlYWRvbmx5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcmNBbGxvY2F0ZWQgY2FsbGVkIG9uIG11dGFibGUgYnVmZmVyXCIpO1xuICAgIGNvbnN0IGFyY1B0ciA9IGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYXJjUHRyO1xuICAgIC8vIFdlIHN0aWxsIGhhdmUgdGhlIGJ1ZmZlciBoZXJlISBTbyBpdCBzaG91bGQgc3RpbGwgYmUgYWxsb2NhdGVkLlxuICAgIGV4cGVjdChhbGxvY2F0ZWRBcmNzW2FyY1B0cl0sIHRydWUpO1xuICAgIGNvbnN0IFtyZXN1bHRdID0geWllbGQgY2FsbFJ1c3QoXCJjaGVja19hcmNfY291bnRcIiwgW2Ake0JpZ0ludChhcmNQdHIpfWBdKTtcbiAgICBjb25zdCBbY291bnRCZWZvcmVEZWFsbG9jYXRpb25dID0gcmVzdWx0O1xuICAgIGV4cGVjdChjb3VudEJlZm9yZURlYWxsb2NhdGlvbiwgMSk7XG4gICAgcmV0dXJuIGFyY1B0cjtcbn0pO1xuY29uc3QgYXJjRGVhbGxvY2F0ZWQgPSAoYXJjUHRyKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAvLyBGcm9tIGhlcmUgb24gb3V0IHdlIGRvbid0IHJlZmVyIHRvIGBidWZmZXJgIGFueSBtb3JlLCBzbyBpdCBzaG91bGQgZ2V0XG4gICAgLy8gZGVhbGxvY2F0ZWQsIGlmIHRoZSBnYXJiYWdlIGNvbGxlY3RvciBpcyBhbnkgZ29vZC5cbiAgICBleHBlY3QoeWllbGQgY2hlY2tDb25kaXRpb25UaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGVHYXJiYWdlKCk7XG4gICAgICAgIHJldHVybiBhbGxvY2F0ZWRBcmNzW2FyY1B0cl0gPT09IGZhbHNlO1xuICAgIH0sIDIwMDAwKSwgdHJ1ZSk7XG59KTtcbmNvbnN0IHZlY0RlYWxsb2NhdGVkID0gKGJ1ZmZlclB0cikgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgLy8gRXZlbiB0aG91Z2ggd2UgaGF2ZSB0aGUgYnVmZmVyLCBpdCBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiB1bnJlZ2lzdGVyZWRcbiAgICAvLyB3aGVuIHBhc3NlZCB0byBSdXN0LiBXZSBzaG91bGRuJ3QgcmVhZC93cml0ZSB0byBpdCBhbnkgbW9yZS4gSWYgdGhpcyBpcyB0aGVcbiAgICAvLyBjYXNlLCBsZXQncyBqdXN0IGJhaWwuXG4gICAgaWYgKCFhbGxvY2F0ZWRWZWNzW2J1ZmZlclB0cl0pXG4gICAgICAgIHJldHVybjtcbiAgICBleHBlY3QoeWllbGQgY2hlY2tDb25kaXRpb25UaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGVHYXJiYWdlKCk7XG4gICAgICAgIHJldHVybiBhbGxvY2F0ZWRWZWNzW2J1ZmZlclB0cl0gPT09IGZhbHNlO1xuICAgIH0sIDIwMDAwKSwgdHJ1ZSk7XG59KTtcbi8vIFRlc3QgdGhhdCBXcmZCdWZmZXJzIHdlcmUgZGVhbGxvY2F0ZWQgYXQgc29tZSBwb2ludCBpbiB0aGUgbmV4dCAyMCBzZWNvbmRzLlxuLy8gVGhpcyBpcyBhIGJpdCBicml0dGxlIGdpdmVuIHRoYXQgdGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBkdXJpbmcgdGhpcyB0aW1lLFxuLy8gYnV0IG9ic2VydmF0aW9uYWxseSB0aGlzIGVuZHMgdXAgYmVpbmcgZW5vdWdoIHRpbWUuIFRoZSBjYWxsZXIgbXVzdCBhbHNvIGVuc3VyZSB0aGF0IHRoZSBidWZmZXIgd2lsbCBnbyBvdXQgb2Ygc2NvcGVcbi8vIHNob3J0bHkgYWZ0ZXIgY2FsbGluZyB0aGlzLlxuLy8gV2UgaGF2ZSB0byBwYXNzIGluIGBjYWxsUnVzdGAgYmVjYXVzZSB3ZSBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uIGZyb20gYSB2YXJpZXR5IG9mIHJ1bnRpbWVzLlxuLy8gTm90ZSB0aGF0IGFzc2VydGlvbnMgb24gZ2FyYmFnZSBjb2xsZWN0aW9uIGFyZSBleHRyZW1lbHkgc2Vuc2l0aXZlIHRvIGV4YWN0bHkgaG93IHRoZXNlIGZ1bmN0aW9ucyBhcmUgd3JpdHRlbixcbi8vIGFuZCBjYW4gZWFzaWx5IGJyZWFrIGlmIHlvdSByZXN0dWN0dXJlIHRoZSBmdW5jdGlvbiwgdXNlIGEgZGlmZmVyZW50L25ld2VyIGJyb3dzZXIsIGV0YyFcbmV4cG9ydCBjb25zdCBleHBlY3REZWFsbG9jYXRpb25PclVucmVnaXN0ZXIgPSAoY2FsbFJ1c3QsIHdyZkFycmF5KSA9PiB7XG4gICAgLy8gRGVhbGxvY2F0aW9uIGNvZGUgaXMgb25seSBydW4gaW4gV0FTTSBmb3Igbm93LlxuICAgIGlmIChqc1J1bnRpbWUgPT09IFwiY2VmXCIpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCBidWZmZXIgPSB3cmZBcnJheS5idWZmZXI7XG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkb25seVxuICAgICAgICA/IGFyY0FsbG9jYXRlZChjYWxsUnVzdCwgYnVmZmVyKS50aGVuKChhcmNQdHIpID0+IGFyY0RlYWxsb2NhdGVkKGFyY1B0cikpXG4gICAgICAgIDogdmVjRGVhbGxvY2F0ZWQoYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5idWZmZXJQdHIpO1xufTtcbmV4cG9ydCBsZXQgaW5UZXN0ID0gZmFsc2U7XG4vLyBTZXQgdGhpcyB0byB0cnVlIHRvIGVuYWJsZSB0ZXN0aW5nIGNvZGVcbmV4cG9ydCBjb25zdCBzZXRJblRlc3QgPSAodikgPT4ge1xuICAgIGluVGVzdCA9IHY7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./wrf_test.ts\n");

/***/ }),

/***/ "./zerde.ts":
/*!******************!*\
  !*** ./zerde.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZerdeBuilder\": () => (/* binding */ ZerdeBuilder),\n/* harmony export */   \"ZerdeParser\": () => (/* binding */ ZerdeParser)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Zerde is our lightweight manual serialization/deserialization system.\n//\n// Keep in sync with zerde.rs, and see there for more information.\n\n// Construct a buffer that can be read in Rust, using the corresponding `ZerderParser` struct in Rust.\nclass ZerdeBuilder {\n    constructor({ buffer, byteOffset, slots, growCallback, }) {\n        this._buffer = buffer;\n        this._byteOffset = byteOffset;\n        this._slots = slots;\n        this._growCallback = growCallback;\n        this._used = 2; // Skip 8 byte header which contains the size.\n        this._updateRefs();\n    }\n    _updateRefs() {\n        this._f32 = new Float32Array(this._buffer, this._byteOffset, this._slots);\n        this._u32 = new Uint32Array(this._buffer, this._byteOffset, this._slots);\n        this._f64 = new Float64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64 = new BigUint64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64[0] = BigInt(this._slots) * BigInt(4); // Write size to header.\n    }\n    _fit(slots) {\n        if (this._used + slots > this._slots) {\n            let newSlots = Math.max(this._used + slots, this._slots * 2); // Exponential growth\n            if (newSlots & 1)\n                newSlots++; // 64-bit align it\n            const newBytes = newSlots * 4;\n            const { buffer, byteOffset } = this._growCallback(this._buffer, this._byteOffset, newBytes);\n            this._buffer = buffer;\n            this._byteOffset = byteOffset;\n            this._slots = newSlots;\n            this._updateRefs();\n        }\n        const pos = this._used;\n        this._used += slots;\n        return pos;\n    }\n    sendF32(value) {\n        const pos = this._fit(1);\n        this._f32[pos] = value;\n    }\n    sendU32(value) {\n        const pos = this._fit(1);\n        this._u32[pos] = value;\n    }\n    sendF64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._f64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._f64[pos >> 1] = value;\n        }\n    }\n    sendU64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._u64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._u64[pos >> 1] = value;\n        }\n    }\n    sendString(str) {\n        let pos = this._fit(str.length + 1);\n        this._u32[pos++] = str.length;\n        for (let i = 0; i < str.length; i++) {\n            this._u32[pos++] = str.charCodeAt(i);\n        }\n    }\n    getData() {\n        return { buffer: this._buffer, byteOffset: this._byteOffset };\n    }\n}\nclass ZerdeParser {\n    constructor(memory, zerdePtr) {\n        this._memory = memory;\n        // set up local shortcuts to the zerde memory chunk for faster parsing\n        this._usedSlots = 2; // skip the 8 byte header\n        this._f32 = new Float32Array(this._memory.buffer, zerdePtr);\n        this._u32 = new Uint32Array(this._memory.buffer, zerdePtr);\n        this._f64 = new Float64Array(this._memory.buffer, zerdePtr);\n        this._u64 = new BigUint64Array(this._memory.buffer, zerdePtr);\n    }\n    parseU32() {\n        return this._u32[this._usedSlots++];\n    }\n    parseF32() {\n        return this._f32[this._usedSlots++];\n    }\n    parseF64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._f64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseU64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._u64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseString() {\n        let str = \"\";\n        const len = this.parseU32();\n        for (let i = 0; i < len; i++) {\n            const c = this.parseU32();\n            if (c != 0)\n                str += String.fromCharCode(c);\n        }\n        return str;\n    }\n    parseU8Slice() {\n        const u8Len = this.parseU32();\n        const len = u8Len >> 2;\n        const data = new Uint8Array(u8Len);\n        const spare = u8Len & 3;\n        for (let i = 0; i < len; i++) {\n            const u8Pos = i << 2;\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n            data[u8Pos + 3] = (u32 >> 24) & 0xff;\n        }\n        const u8Pos = len << 2;\n        if (spare == 1) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n        }\n        else if (spare == 2) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n        }\n        else if (spare == 3) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n        }\n        return data;\n    }\n    parseWrfParams() {\n        const len = this.parseU32();\n        const params = [];\n        for (let i = 0; i < len; ++i) {\n            const paramType = this.parseU32();\n            if (paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.String) {\n                params.push(this.parseString());\n            }\n            else if (paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyU8Buffer ||\n                paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyF32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const arcPtr = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    arcPtr,\n                    readonly: true,\n                });\n            }\n            else if (paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.U8Buffer ||\n                paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.F32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const bufferCap = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    bufferCap,\n                    readonly: false,\n                });\n            }\n            else {\n                throw new Error(`Unknown WrfParam type: ${paramType}`);\n            }\n        }\n        return params;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi96ZXJkZS50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3plcmRlLnRzPzNjNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFplcmRlIGlzIG91ciBsaWdodHdlaWdodCBtYW51YWwgc2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRpb24gc3lzdGVtLlxuLy9cbi8vIEtlZXAgaW4gc3luYyB3aXRoIHplcmRlLnJzLCBhbmQgc2VlIHRoZXJlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuaW1wb3J0IHsgV3JmUGFyYW1UeXBlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbi8vIENvbnN0cnVjdCBhIGJ1ZmZlciB0aGF0IGNhbiBiZSByZWFkIGluIFJ1c3QsIHVzaW5nIHRoZSBjb3JyZXNwb25kaW5nIGBaZXJkZXJQYXJzZXJgIHN0cnVjdCBpbiBSdXN0LlxuZXhwb3J0IGNsYXNzIFplcmRlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoeyBidWZmZXIsIGJ5dGVPZmZzZXQsIHNsb3RzLCBncm93Q2FsbGJhY2ssIH0pIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLl9ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgdGhpcy5fc2xvdHMgPSBzbG90cztcbiAgICAgICAgdGhpcy5fZ3Jvd0NhbGxiYWNrID0gZ3Jvd0NhbGxiYWNrO1xuICAgICAgICB0aGlzLl91c2VkID0gMjsgLy8gU2tpcCA4IGJ5dGUgaGVhZGVyIHdoaWNoIGNvbnRhaW5zIHRoZSBzaXplLlxuICAgICAgICB0aGlzLl91cGRhdGVSZWZzKCk7XG4gICAgfVxuICAgIF91cGRhdGVSZWZzKCkge1xuICAgICAgICB0aGlzLl9mMzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5fYnl0ZU9mZnNldCwgdGhpcy5fc2xvdHMpO1xuICAgICAgICB0aGlzLl91MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0LCB0aGlzLl9zbG90cyk7XG4gICAgICAgIHRoaXMuX2Y2NCA9IG5ldyBGbG9hdDY0QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0LCB0aGlzLl9zbG90cyA+PiAxKTtcbiAgICAgICAgdGhpcy5fdTY0ID0gbmV3IEJpZ1VpbnQ2NEFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5fYnl0ZU9mZnNldCwgdGhpcy5fc2xvdHMgPj4gMSk7XG4gICAgICAgIHRoaXMuX3U2NFswXSA9IEJpZ0ludCh0aGlzLl9zbG90cykgKiBCaWdJbnQoNCk7IC8vIFdyaXRlIHNpemUgdG8gaGVhZGVyLlxuICAgIH1cbiAgICBfZml0KHNsb3RzKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VkICsgc2xvdHMgPiB0aGlzLl9zbG90cykge1xuICAgICAgICAgICAgbGV0IG5ld1Nsb3RzID0gTWF0aC5tYXgodGhpcy5fdXNlZCArIHNsb3RzLCB0aGlzLl9zbG90cyAqIDIpOyAvLyBFeHBvbmVudGlhbCBncm93dGhcbiAgICAgICAgICAgIGlmIChuZXdTbG90cyAmIDEpXG4gICAgICAgICAgICAgICAgbmV3U2xvdHMrKzsgLy8gNjQtYml0IGFsaWduIGl0XG4gICAgICAgICAgICBjb25zdCBuZXdCeXRlcyA9IG5ld1Nsb3RzICogNDtcbiAgICAgICAgICAgIGNvbnN0IHsgYnVmZmVyLCBieXRlT2Zmc2V0IH0gPSB0aGlzLl9ncm93Q2FsbGJhY2sodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0LCBuZXdCeXRlcyk7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB0aGlzLl9ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX3Nsb3RzID0gbmV3U2xvdHM7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSZWZzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fdXNlZDtcbiAgICAgICAgdGhpcy5fdXNlZCArPSBzbG90cztcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc2VuZEYzMih2YWx1ZSkge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9maXQoMSk7XG4gICAgICAgIHRoaXMuX2YzMltwb3NdID0gdmFsdWU7XG4gICAgfVxuICAgIHNlbmRVMzIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fZml0KDEpO1xuICAgICAgICB0aGlzLl91MzJbcG9zXSA9IHZhbHVlO1xuICAgIH1cbiAgICBzZW5kRjY0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VkICYgMSkge1xuICAgICAgICAgICAgLy8gNjQtYml0IGFsaWdubWVudC5cbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2ZpdCgzKSArIDE7XG4gICAgICAgICAgICB0aGlzLl9mNjRbcG9zID4+IDFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9maXQoMik7XG4gICAgICAgICAgICB0aGlzLl9mNjRbcG9zID4+IDFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZFU2NCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fdXNlZCAmIDEpIHtcbiAgICAgICAgICAgIC8vIDY0LWJpdCBhbGlnbm1lbnQuXG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9maXQoMykgKyAxO1xuICAgICAgICAgICAgdGhpcy5fdTY0W3BvcyA+PiAxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fZml0KDIpO1xuICAgICAgICAgICAgdGhpcy5fdTY0W3BvcyA+PiAxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRTdHJpbmcoc3RyKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLl9maXQoc3RyLmxlbmd0aCArIDEpO1xuICAgICAgICB0aGlzLl91MzJbcG9zKytdID0gc3RyLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3UzMltwb3MrK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4geyBidWZmZXI6IHRoaXMuX2J1ZmZlciwgYnl0ZU9mZnNldDogdGhpcy5fYnl0ZU9mZnNldCB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBaZXJkZVBhcnNlciB7XG4gICAgY29uc3RydWN0b3IobWVtb3J5LCB6ZXJkZVB0cikge1xuICAgICAgICB0aGlzLl9tZW1vcnkgPSBtZW1vcnk7XG4gICAgICAgIC8vIHNldCB1cCBsb2NhbCBzaG9ydGN1dHMgdG8gdGhlIHplcmRlIG1lbW9yeSBjaHVuayBmb3IgZmFzdGVyIHBhcnNpbmdcbiAgICAgICAgdGhpcy5fdXNlZFNsb3RzID0gMjsgLy8gc2tpcCB0aGUgOCBieXRlIGhlYWRlclxuICAgICAgICB0aGlzLl9mMzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX21lbW9yeS5idWZmZXIsIHplcmRlUHRyKTtcbiAgICAgICAgdGhpcy5fdTMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX21lbW9yeS5idWZmZXIsIHplcmRlUHRyKTtcbiAgICAgICAgdGhpcy5fZjY0ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLl9tZW1vcnkuYnVmZmVyLCB6ZXJkZVB0cik7XG4gICAgICAgIHRoaXMuX3U2NCA9IG5ldyBCaWdVaW50NjRBcnJheSh0aGlzLl9tZW1vcnkuYnVmZmVyLCB6ZXJkZVB0cik7XG4gICAgfVxuICAgIHBhcnNlVTMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdTMyW3RoaXMuX3VzZWRTbG90cysrXTtcbiAgICB9XG4gICAgcGFyc2VGMzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mMzJbdGhpcy5fdXNlZFNsb3RzKytdO1xuICAgIH1cbiAgICBwYXJzZUY2NCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZWRTbG90cyAmIDEpIHtcbiAgICAgICAgICAgIC8vIDY0LWJpdCBhbGlnbm1lbnQuXG4gICAgICAgICAgICB0aGlzLl91c2VkU2xvdHMrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzLl9mNjRbdGhpcy5fdXNlZFNsb3RzID4+IDFdO1xuICAgICAgICB0aGlzLl91c2VkU2xvdHMgKz0gMjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcGFyc2VVNjQoKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VkU2xvdHMgJiAxKSB7XG4gICAgICAgICAgICAvLyA2NC1iaXQgYWxpZ25tZW50LlxuICAgICAgICAgICAgdGhpcy5fdXNlZFNsb3RzKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5fdTY0W3RoaXMuX3VzZWRTbG90cyA+PiAxXTtcbiAgICAgICAgdGhpcy5fdXNlZFNsb3RzICs9IDI7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHBhcnNlU3RyaW5nKCkge1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgaWYgKGMgIT0gMClcbiAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBwYXJzZVU4U2xpY2UoKSB7XG4gICAgICAgIGNvbnN0IHU4TGVuID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICBjb25zdCBsZW4gPSB1OExlbiA+PiAyO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodThMZW4pO1xuICAgICAgICBjb25zdCBzcGFyZSA9IHU4TGVuICYgMztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdThQb3MgPSBpIDw8IDI7XG4gICAgICAgICAgICBjb25zdCB1MzIgPSB0aGlzLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgMF0gPSB1MzIgJiAweGZmO1xuICAgICAgICAgICAgZGF0YVt1OFBvcyArIDFdID0gKHUzMiA+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgMl0gPSAodTMyID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgM10gPSAodTMyID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdThQb3MgPSBsZW4gPDwgMjtcbiAgICAgICAgaWYgKHNwYXJlID09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHUzMiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAwXSA9IHUzMiAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3BhcmUgPT0gMikge1xuICAgICAgICAgICAgY29uc3QgdTMyID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgZGF0YVt1OFBvcyArIDBdID0gdTMyICYgMHhmZjtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAxXSA9ICh1MzIgPj4gOCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNwYXJlID09IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUzMiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAwXSA9IHUzMiAmIDB4ZmY7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgMV0gPSAodTMyID4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAyXSA9ICh1MzIgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcGFyc2VXcmZQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGlmIChwYXJhbVR5cGUgPT09IFdyZlBhcmFtVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh0aGlzLnBhcnNlU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1UeXBlID09PSBXcmZQYXJhbVR5cGUuUmVhZE9ubHlVOEJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgIHBhcmFtVHlwZSA9PT0gV3JmUGFyYW1UeXBlLlJlYWRPbmx5RjMyQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyUHRyID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckxlbiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmNQdHIgPSB0aGlzLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclB0cixcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyTGVuLFxuICAgICAgICAgICAgICAgICAgICBhcmNQdHIsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1UeXBlID09PSBXcmZQYXJhbVR5cGUuVThCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICBwYXJhbVR5cGUgPT09IFdyZlBhcmFtVHlwZS5GMzJCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJQdHIgPSB0aGlzLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyTGVuID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckNhcCA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUHRyLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXJMZW4sXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckNhcCxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFdyZlBhcmFtIHR5cGU6ICR7cGFyYW1UeXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./zerde.ts\n");

/***/ })

}]);