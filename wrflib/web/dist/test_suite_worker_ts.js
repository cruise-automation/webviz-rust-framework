/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["wrf"] = factory();
	else
		root["wrf"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./test_suite_worker.ts":
/*!******************************!*\
  !*** ./test_suite_worker.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _wrf_web_worker_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrf_web_worker_runtime */ \"./wrf_web_worker_runtime.ts\");\n/* harmony import */ var _wrf_test__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrf_test */ \"./wrf_test.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst rpc = new _common__WEBPACK_IMPORTED_MODULE_2__.Rpc(self);\nconst tests = {\n    testCallRustFromWorker: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            const buffer = new SharedArrayBuffer(8);\n            new Uint8Array(buffer).set([1, 2, 3, 4, 5, 6, 7, 8]);\n            const uint8Part = new Uint8Array(buffer, 2, 4);\n            const [result] = yield self.callRust(\"array_multiply\", [\n                JSON.stringify(10),\n                uint8Part,\n            ]);\n            (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result.length, 4);\n            (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[0], 30);\n            (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[1], 40);\n            (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[2], 50);\n            (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[3], 60);\n        });\n    },\n    testCallRustNoReturnFromWorker: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            const buffer = new SharedArrayBuffer(8);\n            new Uint8Array(buffer).set([1, 2, 3, 4, 5, 6, 7, 8]);\n            const uint8Part = new Uint8Array(buffer, 2, 4);\n            const result = yield self.callRust(\"call_rust_no_return\", [\n                JSON.stringify(10),\n                uint8Part,\n            ]);\n            (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result.length, 0);\n        });\n    },\n    testCallRustInSameThreadSyncWithSignal: function () {\n        const result = self.callRustInSameThreadSync(\"send_signal\");\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result.length, 0);\n    },\n    testCallRustFloat32ArrayFromWorker: () => __awaiter(void 0, void 0, void 0, function* () {\n        // Using a normal array\n        const input = new Float32Array([0.1, 0.9, 0.3]);\n        const result = (yield self.callRust(\"array_multiply\", [JSON.stringify(10), input]))[0];\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result.length, 3);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[0], 1);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[1], 9);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[2], 3);\n        // Using a WrfArray\n        const input2 = self.createBuffer(new Float32Array([0.1, 0.9, 0.3]));\n        const result2 = (yield self.callRust(\"array_multiply\", [JSON.stringify(10), input2]))[0];\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result2.length, 3);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result2[0], 1);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result2[1], 9);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result2[2], 3);\n        // Using a readonly WrfArray\n        const input3 = self.createReadOnlyBuffer(new Float32Array([0.1, 0.9, 0.3]));\n        const result3 = (yield self.callRust(\"array_multiply\", [JSON.stringify(10), input3]))[0];\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result3.length, 3);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result3[0], 1);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result3[1], 9);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result3[2], 3);\n    }),\n    testCallRustInSameThreadSyncFloat32ArrayFromWorker: () => __awaiter(void 0, void 0, void 0, function* () {\n        // Using a normal array\n        const input = new Float32Array([0.1, 0.9, 0.3]);\n        const result = self.callRustInSameThreadSync(\"array_multiply\", [\n            JSON.stringify(10),\n            input,\n        ])[0];\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result.length, 3);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[0], 1);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[1], 9);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result[2], 3);\n        // Using a WrfArray\n        const input2 = self.createBuffer(new Float32Array([0.1, 0.9, 0.3]));\n        const result2 = self.callRustInSameThreadSync(\"array_multiply\", [\n            JSON.stringify(10),\n            input2,\n        ])[0];\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result2.length, 3);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result2[0], 1);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result2[1], 9);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result2[2], 3);\n        // Using a readonly WrfArray\n        const input3 = self.createReadOnlyBuffer(new Float32Array([0.1, 0.9, 0.3]));\n        const result3 = self.callRustInSameThreadSync(\"array_multiply\", [\n            JSON.stringify(10),\n            input3,\n        ])[0];\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result3.length, 3);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result3[0], 1);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result3[1], 9);\n        (0,_wrf_test__WEBPACK_IMPORTED_MODULE_1__.expect)(result3[2], 3);\n    }),\n};\nrpc.receive(\"initWasm\", (port) => {\n    self.initWrfUserWorkerRuntime(port);\n});\nrpc.receive(\"runTest\", (testName) => __awaiter(void 0, void 0, void 0, function* () { return tests[testName](); }));\nrpc.receive(\"sendWorker\", function (array) {\n    const data = self.deserializeWrfArrayFromPostMessage(array);\n    console.log(\"got data\", data);\n});\nrpc.receive(\"testSendWrfArrayToMainThread\", function () {\n    const buffer = new SharedArrayBuffer(8);\n    new Uint8Array(buffer).set([1, 2, 3, 4, 5, 6, 7, 8]);\n    const uint8Part = new Uint8Array(buffer, 2, 4);\n    const wrfArray = self.callRustInSameThreadSync(\"array_multiply\", [\n        JSON.stringify(10),\n        uint8Part,\n    ])[0];\n    return {\n        array: self.serializeWrfArrayForPostMessage(wrfArray),\n        subarray: self.serializeWrfArrayForPostMessage(wrfArray.subarray(1, 3)),\n    };\n});\nrpc.receive(\"testCallRustInSameThreadSyncWithWrfbuffer\", function () {\n    const result = self.createBuffer(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]));\n    const [result2] = self.callRustInSameThreadSync(\"array_multiply\", [\n        JSON.stringify(10),\n        result,\n    ]);\n    return self.serializeWrfArrayForPostMessage(result2);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90ZXN0X3N1aXRlX3dvcmtlci50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cmYvLi90ZXN0X3N1aXRlX3dvcmtlci50cz85MzU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMS1wcmVzZW50LCBDcnVpc2UgTExDXG4vL1xuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UtQVBBQ0hFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCBcIi4vd3JmX3dlYl93b3JrZXJfcnVudGltZVwiO1xuaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSBcIi4vd3JmX3Rlc3RcIjtcbmltcG9ydCB7IFJwYyB9IGZyb20gXCIuL2NvbW1vblwiO1xuY29uc3QgcnBjID0gbmV3IFJwYyhzZWxmKTtcbmNvbnN0IHRlc3RzID0ge1xuICAgIHRlc3RDYWxsUnVzdEZyb21Xb3JrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcig4KTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuc2V0KFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4XSk7XG4gICAgICAgICAgICBjb25zdCB1aW50OFBhcnQgPSBuZXcgVWludDhBcnJheShidWZmZXIsIDIsIDQpO1xuICAgICAgICAgICAgY29uc3QgW3Jlc3VsdF0gPSB5aWVsZCBzZWxmLmNhbGxSdXN0KFwiYXJyYXlfbXVsdGlwbHlcIiwgW1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KDEwKSxcbiAgICAgICAgICAgICAgICB1aW50OFBhcnQsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoLCA0KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRbMF0sIDMwKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRbMV0sIDQwKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRbMl0sIDUwKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRbM10sIDYwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB0ZXN0Q2FsbFJ1c3ROb1JldHVybkZyb21Xb3JrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcig4KTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuc2V0KFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4XSk7XG4gICAgICAgICAgICBjb25zdCB1aW50OFBhcnQgPSBuZXcgVWludDhBcnJheShidWZmZXIsIDIsIDQpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5jYWxsUnVzdChcImNhbGxfcnVzdF9ub19yZXR1cm5cIiwgW1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KDEwKSxcbiAgICAgICAgICAgICAgICB1aW50OFBhcnQsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoLCAwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB0ZXN0Q2FsbFJ1c3RJblNhbWVUaHJlYWRTeW5jV2l0aFNpZ25hbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzZWxmLmNhbGxSdXN0SW5TYW1lVGhyZWFkU3luYyhcInNlbmRfc2lnbmFsXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0Lmxlbmd0aCwgMCk7XG4gICAgfSxcbiAgICB0ZXN0Q2FsbFJ1c3RGbG9hdDMyQXJyYXlGcm9tV29ya2VyOiAoKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgLy8gVXNpbmcgYSBub3JtYWwgYXJyYXlcbiAgICAgICAgY29uc3QgaW5wdXQgPSBuZXcgRmxvYXQzMkFycmF5KFswLjEsIDAuOSwgMC4zXSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICh5aWVsZCBzZWxmLmNhbGxSdXN0KFwiYXJyYXlfbXVsdGlwbHlcIiwgW0pTT04uc3RyaW5naWZ5KDEwKSwgaW5wdXRdKSlbMF07XG4gICAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoLCAzKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdFswXSwgMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRbMV0sIDkpO1xuICAgICAgICBleHBlY3QocmVzdWx0WzJdLCAzKTtcbiAgICAgICAgLy8gVXNpbmcgYSBXcmZBcnJheVxuICAgICAgICBjb25zdCBpbnB1dDIgPSBzZWxmLmNyZWF0ZUJ1ZmZlcihuZXcgRmxvYXQzMkFycmF5KFswLjEsIDAuOSwgMC4zXSkpO1xuICAgICAgICBjb25zdCByZXN1bHQyID0gKHlpZWxkIHNlbGYuY2FsbFJ1c3QoXCJhcnJheV9tdWx0aXBseVwiLCBbSlNPTi5zdHJpbmdpZnkoMTApLCBpbnB1dDJdKSlbMF07XG4gICAgICAgIGV4cGVjdChyZXN1bHQyLmxlbmd0aCwgMyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQyWzBdLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdDJbMV0sIDkpO1xuICAgICAgICBleHBlY3QocmVzdWx0MlsyXSwgMyk7XG4gICAgICAgIC8vIFVzaW5nIGEgcmVhZG9ubHkgV3JmQXJyYXlcbiAgICAgICAgY29uc3QgaW5wdXQzID0gc2VsZi5jcmVhdGVSZWFkT25seUJ1ZmZlcihuZXcgRmxvYXQzMkFycmF5KFswLjEsIDAuOSwgMC4zXSkpO1xuICAgICAgICBjb25zdCByZXN1bHQzID0gKHlpZWxkIHNlbGYuY2FsbFJ1c3QoXCJhcnJheV9tdWx0aXBseVwiLCBbSlNPTi5zdHJpbmdpZnkoMTApLCBpbnB1dDNdKSlbMF07XG4gICAgICAgIGV4cGVjdChyZXN1bHQzLmxlbmd0aCwgMyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQzWzBdLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdDNbMV0sIDkpO1xuICAgICAgICBleHBlY3QocmVzdWx0M1syXSwgMyk7XG4gICAgfSksXG4gICAgdGVzdENhbGxSdXN0SW5TYW1lVGhyZWFkU3luY0Zsb2F0MzJBcnJheUZyb21Xb3JrZXI6ICgpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyBVc2luZyBhIG5vcm1hbCBhcnJheVxuICAgICAgICBjb25zdCBpbnB1dCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAuMSwgMC45LCAwLjNdKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2VsZi5jYWxsUnVzdEluU2FtZVRocmVhZFN5bmMoXCJhcnJheV9tdWx0aXBseVwiLCBbXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSgxMCksXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgXSlbMF07XG4gICAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoLCAzKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdFswXSwgMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRbMV0sIDkpO1xuICAgICAgICBleHBlY3QocmVzdWx0WzJdLCAzKTtcbiAgICAgICAgLy8gVXNpbmcgYSBXcmZBcnJheVxuICAgICAgICBjb25zdCBpbnB1dDIgPSBzZWxmLmNyZWF0ZUJ1ZmZlcihuZXcgRmxvYXQzMkFycmF5KFswLjEsIDAuOSwgMC4zXSkpO1xuICAgICAgICBjb25zdCByZXN1bHQyID0gc2VsZi5jYWxsUnVzdEluU2FtZVRocmVhZFN5bmMoXCJhcnJheV9tdWx0aXBseVwiLCBbXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSgxMCksXG4gICAgICAgICAgICBpbnB1dDIsXG4gICAgICAgIF0pWzBdO1xuICAgICAgICBleHBlY3QocmVzdWx0Mi5sZW5ndGgsIDMpO1xuICAgICAgICBleHBlY3QocmVzdWx0MlswXSwgMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQyWzFdLCA5KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdDJbMl0sIDMpO1xuICAgICAgICAvLyBVc2luZyBhIHJlYWRvbmx5IFdyZkFycmF5XG4gICAgICAgIGNvbnN0IGlucHV0MyA9IHNlbGYuY3JlYXRlUmVhZE9ubHlCdWZmZXIobmV3IEZsb2F0MzJBcnJheShbMC4xLCAwLjksIDAuM10pKTtcbiAgICAgICAgY29uc3QgcmVzdWx0MyA9IHNlbGYuY2FsbFJ1c3RJblNhbWVUaHJlYWRTeW5jKFwiYXJyYXlfbXVsdGlwbHlcIiwgW1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoMTApLFxuICAgICAgICAgICAgaW5wdXQzLFxuICAgICAgICBdKVswXTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdDMubGVuZ3RoLCAzKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdDNbMF0sIDEpO1xuICAgICAgICBleHBlY3QocmVzdWx0M1sxXSwgOSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQzWzJdLCAzKTtcbiAgICB9KSxcbn07XG5ycGMucmVjZWl2ZShcImluaXRXYXNtXCIsIChwb3J0KSA9PiB7XG4gICAgc2VsZi5pbml0V3JmVXNlcldvcmtlclJ1bnRpbWUocG9ydCk7XG59KTtcbnJwYy5yZWNlaXZlKFwicnVuVGVzdFwiLCAodGVzdE5hbWUpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gdGVzdHNbdGVzdE5hbWVdKCk7IH0pKTtcbnJwYy5yZWNlaXZlKFwic2VuZFdvcmtlclwiLCBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICBjb25zdCBkYXRhID0gc2VsZi5kZXNlcmlhbGl6ZVdyZkFycmF5RnJvbVBvc3RNZXNzYWdlKGFycmF5KTtcbiAgICBjb25zb2xlLmxvZyhcImdvdCBkYXRhXCIsIGRhdGEpO1xufSk7XG5ycGMucmVjZWl2ZShcInRlc3RTZW5kV3JmQXJyYXlUb01haW5UaHJlYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcig4KTtcbiAgICBuZXcgVWludDhBcnJheShidWZmZXIpLnNldChbMSwgMiwgMywgNCwgNSwgNiwgNywgOF0pO1xuICAgIGNvbnN0IHVpbnQ4UGFydCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMiwgNCk7XG4gICAgY29uc3Qgd3JmQXJyYXkgPSBzZWxmLmNhbGxSdXN0SW5TYW1lVGhyZWFkU3luYyhcImFycmF5X211bHRpcGx5XCIsIFtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoMTApLFxuICAgICAgICB1aW50OFBhcnQsXG4gICAgXSlbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXJyYXk6IHNlbGYuc2VyaWFsaXplV3JmQXJyYXlGb3JQb3N0TWVzc2FnZSh3cmZBcnJheSksXG4gICAgICAgIHN1YmFycmF5OiBzZWxmLnNlcmlhbGl6ZVdyZkFycmF5Rm9yUG9zdE1lc3NhZ2Uod3JmQXJyYXkuc3ViYXJyYXkoMSwgMykpLFxuICAgIH07XG59KTtcbnJwYy5yZWNlaXZlKFwidGVzdENhbGxSdXN0SW5TYW1lVGhyZWFkU3luY1dpdGhXcmZidWZmZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNlbGYuY3JlYXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4XSkpO1xuICAgIGNvbnN0IFtyZXN1bHQyXSA9IHNlbGYuY2FsbFJ1c3RJblNhbWVUaHJlYWRTeW5jKFwiYXJyYXlfbXVsdGlwbHlcIiwgW1xuICAgICAgICBKU09OLnN0cmluZ2lmeSgxMCksXG4gICAgICAgIHJlc3VsdCxcbiAgICBdKTtcbiAgICByZXR1cm4gc2VsZi5zZXJpYWxpemVXcmZBcnJheUZvclBvc3RNZXNzYWdlKHJlc3VsdDIpO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./test_suite_worker.ts\n");

/***/ }),

/***/ "./wrf_web_worker_runtime.ts":
/*!***********************************!*\
  !*** ./wrf_web_worker_runtime.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n/* harmony import */ var _rpc_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc_types */ \"./rpc_types.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n/* harmony import */ var _zerde__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zerde */ \"./zerde.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n(0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.overwriteTypedArraysWithWrfArrays)();\nlet _wrfWorkerRpc;\nself.initWrfUserWorkerRuntime = (wrfWorkerPort) => {\n    if (self.wrfInitialized) {\n        throw new Error(\"Don't call initWrfUserWorkerRuntime twice\");\n    }\n    self.wrfInitialized = new Promise((resolve) => {\n        _wrfWorkerRpc = new _common__WEBPACK_IMPORTED_MODULE_0__.Rpc(wrfWorkerPort);\n        self.wrfNewWorkerPort = () => {\n            const channel = new MessageChannel();\n            _wrfWorkerRpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_1__.MainWorkerChannelEvent.BindMainWorkerPort, channel.port1, [channel.port1]);\n            return channel.port2;\n        };\n        _wrfWorkerRpc\n            .send(_rpc_types__WEBPACK_IMPORTED_MODULE_1__.MainWorkerChannelEvent.Init)\n            .then(({ wasmModule, memory, taskWorkerSab, baseUri, appPtr, tlsAndStackData, }) => {\n            let wasmExports;\n            function getExports() {\n                return wasmExports;\n            }\n            const env = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getWasmEnv)({\n                getExports,\n                memory,\n                taskWorkerSab,\n                fileHandles: [],\n                sendEventFromAnyThread: (eventPtr) => {\n                    _wrfWorkerRpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_1__.MainWorkerChannelEvent.SendEventFromAnyThread, eventPtr);\n                },\n                threadSpawn: () => {\n                    throw new Error(\"Not yet implemented\");\n                },\n                baseUri,\n            });\n            WebAssembly.instantiate(wasmModule, { env }).then((instance) => {\n                wasmExports = instance.exports;\n                (0,_common__WEBPACK_IMPORTED_MODULE_0__.initThreadLocalStorageAndStackOtherWorkers)(wasmExports, tlsAndStackData);\n                const destructor = (arcPtr) => {\n                    wasmExports.decrementArc(BigInt(arcPtr));\n                };\n                const mutableDestructor = ({ bufferPtr, bufferLen, bufferCap, }) => {\n                    wasmExports.deallocVec(BigInt(bufferPtr), BigInt(bufferLen), BigInt(bufferCap));\n                };\n                const transformParamsFromRust = (params) => (0,_common__WEBPACK_IMPORTED_MODULE_0__.transformParamsFromRustImpl)(memory, destructor, mutableDestructor, params);\n                // TODO(JP): Allocate buffers on the wasm memory directly here.\n                self.callRust = (name, params = []) => __awaiter(void 0, void 0, void 0, function* () {\n                    for (const param of params) {\n                        if (typeof param !== \"string\" &&\n                            !(param.buffer instanceof SharedArrayBuffer)) {\n                            console.warn(\"Consider passing Uint8Arrays backed by SharedArrayBuffer into `callRust` to prevent copying data\");\n                        }\n                    }\n                    const result = yield _wrfWorkerRpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_1__.MainWorkerChannelEvent.CallRust, {\n                        name,\n                        params,\n                    });\n                    return transformParamsFromRust(result);\n                });\n                // TODO(JP): Some of this code is duplicated with callRust/call_js; see if we can reuse some.\n                self.callRustInSameThreadSync = (name, params = []) => {\n                    const zerdeBuilder = (0,_common__WEBPACK_IMPORTED_MODULE_0__.makeZerdeBuilder)(memory, wasmExports);\n                    zerdeBuilder.sendString(name);\n                    zerdeBuilder.sendU32(params.length);\n                    for (const param of params) {\n                        if (typeof param === \"string\") {\n                            zerdeBuilder.sendU32(_types__WEBPACK_IMPORTED_MODULE_2__.WrfParamType.String);\n                            zerdeBuilder.sendString(param);\n                        }\n                        else {\n                            if (param.buffer instanceof _wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.WrfBuffer) {\n                                (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.checkValidWrfArray)(param);\n                                if (param.buffer.__wrflibBufferData.readonly) {\n                                    zerdeBuilder.sendU32((0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(param, true));\n                                    const arcPtr = param.buffer.__wrflibBufferData.arcPtr;\n                                    // WrfParam parsing code will construct an Arc without incrementing\n                                    // the count, so we do it here ahead of time.\n                                    wasmExports.incrementArc(BigInt(arcPtr));\n                                    zerdeBuilder.sendU32(arcPtr);\n                                }\n                                else {\n                                    // TODO(Paras): User should not be able to access the buffer after\n                                    // passing it to Rust here\n                                    (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.unregisterMutableBuffer)(param.buffer);\n                                    zerdeBuilder.sendU32((0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(param, false));\n                                    zerdeBuilder.sendU32(param.buffer.__wrflibBufferData.bufferPtr);\n                                    zerdeBuilder.sendU32(param.buffer.__wrflibBufferData.bufferLen);\n                                    zerdeBuilder.sendU32(param.buffer.__wrflibBufferData.bufferCap);\n                                }\n                            }\n                            else {\n                                console.warn(\"Consider passing Uint8Arrays backed by WrfBuffer to prevent copying data\");\n                                const vecLen = param.byteLength;\n                                const vecPtr = (0,_common__WEBPACK_IMPORTED_MODULE_0__.createWasmBuffer)(memory, wasmExports, param);\n                                zerdeBuilder.sendU32((0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(param, false));\n                                zerdeBuilder.sendU32(vecPtr);\n                                zerdeBuilder.sendU32(vecLen);\n                                zerdeBuilder.sendU32(vecLen);\n                            }\n                        }\n                    }\n                    const returnPtr = wasmExports.callRustInSameThreadSync(appPtr, BigInt(zerdeBuilder.getData().byteOffset));\n                    const zerdeParser = new _zerde__WEBPACK_IMPORTED_MODULE_4__.ZerdeParser(memory, Number(returnPtr));\n                    const returnParams = zerdeParser.parseWrfParams();\n                    return transformParamsFromRust(returnParams);\n                };\n                self.createBuffer = (data) => {\n                    const bufferLen = data.byteLength;\n                    const bufferPtr = (0,_common__WEBPACK_IMPORTED_MODULE_0__.createWasmBuffer)(memory, wasmExports, data);\n                    return transformParamsFromRust([\n                        {\n                            paramType: (0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(data, false),\n                            bufferPtr,\n                            bufferLen,\n                            bufferCap: bufferLen,\n                            readonly: false,\n                        },\n                    ])[0];\n                };\n                self.createReadOnlyBuffer = (data) => {\n                    const bufferPtr = (0,_common__WEBPACK_IMPORTED_MODULE_0__.createWasmBuffer)(memory, wasmExports, data);\n                    const paramType = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(data, true);\n                    const arcPtr = Number(wasmExports.createArcVec(BigInt(bufferPtr), BigInt(data.length), BigInt(paramType)));\n                    return transformParamsFromRust([\n                        {\n                            paramType,\n                            bufferPtr,\n                            bufferLen: data.byteLength,\n                            arcPtr,\n                            readonly: true,\n                        },\n                    ])[0];\n                };\n                self.isWrfBuffer = _wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.isWrfBuffer;\n                // TODO(JP): Somewhat duplicated with the other implementation.\n                self.serializeWrfArrayForPostMessage = (wrfArray) => {\n                    if (!(typeof wrfArray === \"object\" &&\n                        self.isWrfBuffer(wrfArray.buffer))) {\n                        throw new Error(\"Only pass Wrf arrays to serializeWrfArrayForPostMessage\");\n                    }\n                    const wrfBuffer = wrfArray.buffer;\n                    if (wrfBuffer.readonly) {\n                        wasmExports.incrementArc(BigInt(wrfBuffer.__wrflibBufferData.arcPtr));\n                    }\n                    else {\n                        (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.unregisterMutableBuffer)(wrfBuffer);\n                    }\n                    return {\n                        bufferData: wrfBuffer.__wrflibBufferData,\n                        byteOffset: wrfArray.byteOffset,\n                        byteLength: wrfArray.byteLength,\n                    };\n                };\n                self.deserializeWrfArrayFromPostMessage = (postMessageData) => {\n                    const wrfBuffer = (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.getWrfBufferWasm)(memory, postMessageData.bufferData, destructor, mutableDestructor);\n                    return new Uint8Array(wrfBuffer, postMessageData.byteOffset, postMessageData.byteLength);\n                };\n                resolve();\n            });\n        });\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfd2ViX3dvcmtlcl9ydW50aW1lLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cmYvLi93cmZfd2ViX3dvcmtlcl9ydW50aW1lLnRzPzEwMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgY3JlYXRlV2FzbUJ1ZmZlciwgZ2V0V2FzbUVudiwgZ2V0V3JmUGFyYW1UeXBlLCBpbml0VGhyZWFkTG9jYWxTdG9yYWdlQW5kU3RhY2tPdGhlcldvcmtlcnMsIG1ha2VaZXJkZUJ1aWxkZXIsIFJwYywgdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3RJbXBsLCB9IGZyb20gXCIuL2NvbW1vblwiO1xuaW1wb3J0IHsgTWFpbldvcmtlckNoYW5uZWxFdmVudCB9IGZyb20gXCIuL3JwY190eXBlc1wiO1xuaW1wb3J0IHsgV3JmUGFyYW1UeXBlLCB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRXcmZCdWZmZXJXYXNtLCBpc1dyZkJ1ZmZlciwgb3ZlcndyaXRlVHlwZWRBcnJheXNXaXRoV3JmQXJyYXlzLCB1bnJlZ2lzdGVyTXV0YWJsZUJ1ZmZlciwgV3JmQnVmZmVyLCBjaGVja1ZhbGlkV3JmQXJyYXksIH0gZnJvbSBcIi4vd3JmX2J1ZmZlclwiO1xuaW1wb3J0IHsgWmVyZGVQYXJzZXIgfSBmcm9tIFwiLi96ZXJkZVwiO1xub3ZlcndyaXRlVHlwZWRBcnJheXNXaXRoV3JmQXJyYXlzKCk7XG5sZXQgX3dyZldvcmtlclJwYztcbnNlbGYuaW5pdFdyZlVzZXJXb3JrZXJSdW50aW1lID0gKHdyZldvcmtlclBvcnQpID0+IHtcbiAgICBpZiAoc2VsZi53cmZJbml0aWFsaXplZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCBjYWxsIGluaXRXcmZVc2VyV29ya2VyUnVudGltZSB0d2ljZVwiKTtcbiAgICB9XG4gICAgc2VsZi53cmZJbml0aWFsaXplZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF93cmZXb3JrZXJScGMgPSBuZXcgUnBjKHdyZldvcmtlclBvcnQpO1xuICAgICAgICBzZWxmLndyZk5ld1dvcmtlclBvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBfd3JmV29ya2VyUnBjLnNlbmQoTWFpbldvcmtlckNoYW5uZWxFdmVudC5CaW5kTWFpbldvcmtlclBvcnQsIGNoYW5uZWwucG9ydDEsIFtjaGFubmVsLnBvcnQxXSk7XG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbC5wb3J0MjtcbiAgICAgICAgfTtcbiAgICAgICAgX3dyZldvcmtlclJwY1xuICAgICAgICAgICAgLnNlbmQoTWFpbldvcmtlckNoYW5uZWxFdmVudC5Jbml0KVxuICAgICAgICAgICAgLnRoZW4oKHsgd2FzbU1vZHVsZSwgbWVtb3J5LCB0YXNrV29ya2VyU2FiLCBiYXNlVXJpLCBhcHBQdHIsIHRsc0FuZFN0YWNrRGF0YSwgfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHdhc21FeHBvcnRzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RXhwb3J0cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FzbUV4cG9ydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbnYgPSBnZXRXYXNtRW52KHtcbiAgICAgICAgICAgICAgICBnZXRFeHBvcnRzLFxuICAgICAgICAgICAgICAgIG1lbW9yeSxcbiAgICAgICAgICAgICAgICB0YXNrV29ya2VyU2FiLFxuICAgICAgICAgICAgICAgIGZpbGVIYW5kbGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRGcm9tQW55VGhyZWFkOiAoZXZlbnRQdHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgX3dyZldvcmtlclJwYy5zZW5kKE1haW5Xb3JrZXJDaGFubmVsRXZlbnQuU2VuZEV2ZW50RnJvbUFueVRocmVhZCwgZXZlbnRQdHIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhyZWFkU3Bhd246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhc2VVcmksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21Nb2R1bGUsIHsgZW52IH0pLnRoZW4oKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgd2FzbUV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgICAgICAgICAgICAgIGluaXRUaHJlYWRMb2NhbFN0b3JhZ2VBbmRTdGFja090aGVyV29ya2Vycyh3YXNtRXhwb3J0cywgdGxzQW5kU3RhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXN0cnVjdG9yID0gKGFyY1B0cikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3YXNtRXhwb3J0cy5kZWNyZW1lbnRBcmMoQmlnSW50KGFyY1B0cikpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbXV0YWJsZURlc3RydWN0b3IgPSAoeyBidWZmZXJQdHIsIGJ1ZmZlckxlbiwgYnVmZmVyQ2FwLCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdhc21FeHBvcnRzLmRlYWxsb2NWZWMoQmlnSW50KGJ1ZmZlclB0ciksIEJpZ0ludChidWZmZXJMZW4pLCBCaWdJbnQoYnVmZmVyQ2FwKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1QYXJhbXNGcm9tUnVzdCA9IChwYXJhbXMpID0+IHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0SW1wbChtZW1vcnksIGRlc3RydWN0b3IsIG11dGFibGVEZXN0cnVjdG9yLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oSlApOiBBbGxvY2F0ZSBidWZmZXJzIG9uIHRoZSB3YXNtIG1lbW9yeSBkaXJlY3RseSBoZXJlLlxuICAgICAgICAgICAgICAgIHNlbGYuY2FsbFJ1c3QgPSAobmFtZSwgcGFyYW1zID0gW10pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEocGFyYW0uYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ29uc2lkZXIgcGFzc2luZyBVaW50OEFycmF5cyBiYWNrZWQgYnkgU2hhcmVkQXJyYXlCdWZmZXIgaW50byBgY2FsbFJ1c3RgIHRvIHByZXZlbnQgY29weWluZyBkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIF93cmZXb3JrZXJScGMuc2VuZChNYWluV29ya2VyQ2hhbm5lbEV2ZW50LkNhbGxSdXN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhKUCk6IFNvbWUgb2YgdGhpcyBjb2RlIGlzIGR1cGxpY2F0ZWQgd2l0aCBjYWxsUnVzdC9jYWxsX2pzOyBzZWUgaWYgd2UgY2FuIHJldXNlIHNvbWUuXG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsUnVzdEluU2FtZVRocmVhZFN5bmMgPSAobmFtZSwgcGFyYW1zID0gW10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgemVyZGVCdWlsZGVyID0gbWFrZVplcmRlQnVpbGRlcihtZW1vcnksIHdhc21FeHBvcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgemVyZGVCdWlsZGVyLnNlbmRTdHJpbmcobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKHBhcmFtcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKFdyZlBhcmFtVHlwZS5TdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kU3RyaW5nKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5idWZmZXIgaW5zdGFuY2VvZiBXcmZCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tWYWxpZFdyZkFycmF5KHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLmJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEucmVhZG9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKGdldFdyZlBhcmFtVHlwZShwYXJhbSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJjUHRyID0gcGFyYW0uYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5hcmNQdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcmZQYXJhbSBwYXJzaW5nIGNvZGUgd2lsbCBjb25zdHJ1Y3QgYW4gQXJjIHdpdGhvdXQgaW5jcmVtZW50aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY291bnQsIHNvIHdlIGRvIGl0IGhlcmUgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc21FeHBvcnRzLmluY3JlbWVudEFyYyhCaWdJbnQoYXJjUHRyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMihhcmNQdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhQYXJhcyk6IFVzZXIgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgYnVmZmVyIGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXNzaW5nIGl0IHRvIFJ1c3QgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3Rlck11dGFibGVCdWZmZXIocGFyYW0uYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKGdldFdyZlBhcmFtVHlwZShwYXJhbSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKHBhcmFtLmJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKHBhcmFtLmJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyTGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKHBhcmFtLmJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyQ2FwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ29uc2lkZXIgcGFzc2luZyBVaW50OEFycmF5cyBiYWNrZWQgYnkgV3JmQnVmZmVyIHRvIHByZXZlbnQgY29weWluZyBkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWNMZW4gPSBwYXJhbS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWNQdHIgPSBjcmVhdGVXYXNtQnVmZmVyKG1lbW9yeSwgd2FzbUV4cG9ydHMsIHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyZGVCdWlsZGVyLnNlbmRVMzIoZ2V0V3JmUGFyYW1UeXBlKHBhcmFtLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMih2ZWNQdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMih2ZWNMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMih2ZWNMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5QdHIgPSB3YXNtRXhwb3J0cy5jYWxsUnVzdEluU2FtZVRocmVhZFN5bmMoYXBwUHRyLCBCaWdJbnQoemVyZGVCdWlsZGVyLmdldERhdGEoKS5ieXRlT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHplcmRlUGFyc2VyID0gbmV3IFplcmRlUGFyc2VyKG1lbW9yeSwgTnVtYmVyKHJldHVyblB0cikpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5QYXJhbXMgPSB6ZXJkZVBhcnNlci5wYXJzZVdyZlBhcmFtcygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3QocmV0dXJuUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlbGYuY3JlYXRlQnVmZmVyID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyTGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJQdHIgPSBjcmVhdGVXYXNtQnVmZmVyKG1lbW9yeSwgd2FzbUV4cG9ydHMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3QoW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVHlwZTogZ2V0V3JmUGFyYW1UeXBlKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJQdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyTGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckNhcDogYnVmZmVyTGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0pWzBdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VsZi5jcmVhdGVSZWFkT25seUJ1ZmZlciA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclB0ciA9IGNyZWF0ZVdhc21CdWZmZXIobWVtb3J5LCB3YXNtRXhwb3J0cywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IGdldFdyZlBhcmFtVHlwZShkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJjUHRyID0gTnVtYmVyKHdhc21FeHBvcnRzLmNyZWF0ZUFyY1ZlYyhCaWdJbnQoYnVmZmVyUHRyKSwgQmlnSW50KGRhdGEubGVuZ3RoKSwgQmlnSW50KHBhcmFtVHlwZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyUHRyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckxlbjogZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyY1B0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0pWzBdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VsZi5pc1dyZkJ1ZmZlciA9IGlzV3JmQnVmZmVyO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oSlApOiBTb21ld2hhdCBkdXBsaWNhdGVkIHdpdGggdGhlIG90aGVyIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICAgIHNlbGYuc2VyaWFsaXplV3JmQXJyYXlGb3JQb3N0TWVzc2FnZSA9ICh3cmZBcnJheSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2Ygd3JmQXJyYXkgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaXNXcmZCdWZmZXIod3JmQXJyYXkuYnVmZmVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgcGFzcyBXcmYgYXJyYXlzIHRvIHNlcmlhbGl6ZVdyZkFycmF5Rm9yUG9zdE1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gd3JmQXJyYXkuYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JmQnVmZmVyLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNtRXhwb3J0cy5pbmNyZW1lbnRBcmMoQmlnSW50KHdyZkJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYXJjUHRyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyTXV0YWJsZUJ1ZmZlcih3cmZCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJEYXRhOiB3cmZCdWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogd3JmQXJyYXkuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IHdyZkFycmF5LmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZWxmLmRlc2VyaWFsaXplV3JmQXJyYXlGcm9tUG9zdE1lc3NhZ2UgPSAocG9zdE1lc3NhZ2VEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyZkJ1ZmZlciA9IGdldFdyZkJ1ZmZlcldhc20obWVtb3J5LCBwb3N0TWVzc2FnZURhdGEuYnVmZmVyRGF0YSwgZGVzdHJ1Y3RvciwgbXV0YWJsZURlc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod3JmQnVmZmVyLCBwb3N0TWVzc2FnZURhdGEuYnl0ZU9mZnNldCwgcG9zdE1lc3NhZ2VEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./wrf_web_worker_runtime.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["rpc_types_ts-wrf_buffer_ts"], () => (__webpack_require__("./test_suite_worker.ts")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"test_suite_worker_ts": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkwrf"] = self["webpackChunkwrf"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return __webpack_require__.e("rpc_types_ts-wrf_buffer_ts").then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});