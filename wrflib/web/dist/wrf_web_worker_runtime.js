/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["wrf"] = factory();
	else
		root["wrf"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./common.ts":
/*!*******************!*\
  !*** ./common.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rpc\": () => (/* binding */ Rpc),\n/* harmony export */   \"mutexLock\": () => (/* binding */ mutexLock),\n/* harmony export */   \"mutexUnlock\": () => (/* binding */ mutexUnlock),\n/* harmony export */   \"TW_SAB_MUTEX_PTR\": () => (/* binding */ TW_SAB_MUTEX_PTR),\n/* harmony export */   \"TW_SAB_MESSAGE_COUNT_PTR\": () => (/* binding */ TW_SAB_MESSAGE_COUNT_PTR),\n/* harmony export */   \"initTaskWorkerSab\": () => (/* binding */ initTaskWorkerSab),\n/* harmony export */   \"initThreadLocalStorageMainWorker\": () => (/* binding */ initThreadLocalStorageMainWorker),\n/* harmony export */   \"makeThreadLocalStorageAndStackDataOnExistingThread\": () => (/* binding */ makeThreadLocalStorageAndStackDataOnExistingThread),\n/* harmony export */   \"initThreadLocalStorageAndStackOtherWorkers\": () => (/* binding */ initThreadLocalStorageAndStackOtherWorkers),\n/* harmony export */   \"copyArrayToRustBuffer\": () => (/* binding */ copyArrayToRustBuffer),\n/* harmony export */   \"getWrfParamType\": () => (/* binding */ getWrfParamType),\n/* harmony export */   \"createWasmBuffer\": () => (/* binding */ createWasmBuffer),\n/* harmony export */   \"makeZerdeBuilder\": () => (/* binding */ makeZerdeBuilder),\n/* harmony export */   \"getWasmEnv\": () => (/* binding */ getWasmEnv),\n/* harmony export */   \"transformParamsFromRustImpl\": () => (/* binding */ transformParamsFromRustImpl),\n/* harmony export */   \"assertNotNull\": () => (/* binding */ assertNotNull)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n/* harmony import */ var _zerde__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zerde */ \"./zerde.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n\n\n\nconst RESPONSE = \"$$RESPONSE\";\nconst ERROR = \"$$ERROR\";\n// helper function to create linked channels for testing\nfunction _createLinkedChannels() {\n    const local = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (remote.onmessage) {\n                remote.onmessage(ev);\n            }\n        },\n    };\n    const remote = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (local.onmessage) {\n                local.onmessage(ev);\n            }\n        },\n    };\n    return { local, remote };\n}\n// This class allows you to hook up bi-directional async calls across web-worker\n// boundaries where a single call to or from a worker can 'wait' on the response.\n// Errors in receivers are propigated back to the caller as a rejection.\n// It also supports returning transferrables over the web-worker postMessage api,\n// which was the main shortcomming with the worker-rpc npm module.\n// To attach rpc to an instance of a worker in the main thread:\n//   const rpc = new Rpc(workerInstace);\n// To attach rpc within an a web worker:\n//   const rpc = new Rpc(global);\n// Check out the tests for more examples.\n// See `rpc_types.ts` for descriptions of how to set up typed interactions.\nclass Rpc {\n    constructor(channel) {\n        this._messageId = 0;\n        this._pendingCallbacks = {};\n        this._receivers = new Map();\n        this._onChannelMessage = (ev) => {\n            const { id, topic, data } = ev.data;\n            if (topic === RESPONSE) {\n                this._pendingCallbacks[id](ev.data);\n                delete this._pendingCallbacks[id];\n                return;\n            }\n            // invoke the receive handler in a promise so if it throws synchronously we can reject\n            new Promise((resolve) => {\n                const handler = this._receivers.get(topic);\n                if (!handler) {\n                    throw new Error(`no receiver registered for ${topic}`);\n                }\n                // This works both when `handler` returns a value or a Promise.\n                resolve(handler(data));\n            })\n                .then((result) => {\n                if (!result) {\n                    this.postMessage({ topic: RESPONSE, id }, []);\n                    return;\n                }\n                const transferrables = result[Rpc.transferrables];\n                delete result[Rpc.transferrables];\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: result,\n                };\n                this.postMessage(message, transferrables);\n            })\n                .catch((err) => {\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: {\n                        [ERROR]: true,\n                        name: err.name,\n                        message: err.message,\n                        stack: err.stack,\n                    },\n                };\n                this.postMessage(message, []);\n            });\n        };\n        this._channel = channel;\n        if (this._channel.onmessage) {\n            throw new Error(\"channel.onmessage is already set. Can only use one Rpc instance per channel.\");\n        }\n        this._channel.onmessage = this._onChannelMessage;\n    }\n    // send a message across the rpc boundary to a receiver on the other side\n    // this returns a promise for the receiver's response.  If there is no registered\n    // receiver for the given topic, this method throws\n    send(topic, data, transfer) {\n        const id = this._messageId++;\n        const message = { topic, id, data };\n        const result = new Promise((resolve, reject) => {\n            this._pendingCallbacks[id] = (info) => {\n                if (info.data && info.data[ERROR]) {\n                    const error = new Error(info.data.message);\n                    error.name = info.data.name;\n                    error.stack = info.data.stack;\n                    reject(error);\n                }\n                else {\n                    resolve(info.data);\n                }\n            };\n        });\n        this.postMessage(message, transfer);\n        return result;\n    }\n    // register a receiver for a given message on a topic\n    // only one receiver can be registered per topic and currently\n    // 'deregistering' a receiver is not supported since this is not common\n    receive(topic, handler) {\n        if (this._receivers.has(topic)) {\n            throw new Error(`Receiver already registered for topic: ${topic}`);\n        }\n        this._receivers.set(topic, handler);\n    }\n    postMessage(message, transfer) {\n        try {\n            this._channel.postMessage(message, transfer);\n        }\n        catch (e) {\n            console.error(\"Rpc postMessage call itself failed: \", e);\n        }\n    }\n}\nRpc.transferrables = \"$$TRANSFERRABLES\";\n////////////////////////////////////////////////////////////////\n// Mutex\n////////////////////////////////////////////////////////////////\nconst MUTEX_UNLOCKED = 0;\nconst MUTEX_LOCKED = 1;\nconst mutexLock = (sabi32, offset) => {\n    // This needs to be in a loop, because between the `wait` and `compareExchange` another thread might\n    // take the Mutex.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (Atomics.compareExchange(sabi32, offset, MUTEX_UNLOCKED, MUTEX_LOCKED) ==\n            MUTEX_UNLOCKED) {\n            return;\n        }\n        Atomics.wait(sabi32, offset, MUTEX_LOCKED);\n    }\n};\nconst mutexUnlock = (sabi32, offset) => {\n    if (Atomics.compareExchange(sabi32, offset, MUTEX_LOCKED, MUTEX_UNLOCKED) !=\n        MUTEX_LOCKED) {\n        throw new Error(\"Called mutex_unlock on an already unlocked mutex\");\n    }\n    Atomics.notify(sabi32, offset, 1);\n};\n////////////////////////////////////////////////////////////////\n// Task worker\n////////////////////////////////////////////////////////////////\nconst TW_SAB_MUTEX_PTR = 0;\nconst TW_SAB_MESSAGE_COUNT_PTR = 1;\n// Initialize a SharedArrayBuffer used to communicate with task_worker.ts. This\n// is a one-way communication channel; use pointers into `memory` for communicating\n// information back.\n//\n// We use this because we typically can't use `postMessage`; see task_worker.ts\n// for more details.\n//\n// Format:\n// * i32 (4 bytes)         - read/write mutex\n// * i32 (4 bytes)         - number of messages in queue (notify on this to wake up the task worker - it will\n//                           read this before taking a mutex, but then reread it after taking the mutex)\n// * n * u32 (n * 4 bytes) - pointers to messages serialized with `ZerdeBuilder`\nconst initTaskWorkerSab = () => {\n    const bufferSizeBytes = 10000;\n    const taskWorkerSab = new SharedArrayBuffer(bufferSizeBytes);\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    taskWorkerSabi32[TW_SAB_MUTEX_PTR] = MUTEX_UNLOCKED;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = 0;\n    return taskWorkerSab;\n};\n// Append a new message pointer to the SharedArrayBuffer used by task_worker.ts,\n// and wake it up so it can process this new message (unless it's currently in polling\n// mode, in that case the `Atomics.notify` will just not do anything).\nconst sendTaskWorkerMessage = (taskWorkerSab, twMessagePtr) => {\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    mutexLock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    const currentNumberOfMessages = taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR];\n    // Use unsigned numbers for the actual pointer, since they can be >2GB.\n    new Uint32Array(taskWorkerSab)[currentNumberOfMessages + 2] = twMessagePtr;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = currentNumberOfMessages + 1;\n    mutexUnlock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    Atomics.notify(taskWorkerSabi32, 1);\n};\n////////////////////////////////////////////////////////////////\n// Wasm Thread initialization\n////////////////////////////////////////////////////////////////\n// Threads in WebAssembly! They are.. fun! Here's what happens.\n//\n// The first Wasm instance we start is in the main worker. It does the following:\n// - It initializes static memory using `__wasm_init_memory`, which is automatically set\n//   by LLVM as the special \"start\" function.\n// - It already has memory allocated for the \"shadow stack\". This is like any stack in a\n//   native program, but in WebAssembly it's called the \"shadow stack\" because WebAssembly\n//   itself also has a notion of a stack built-in. It is however not suitable for all\n//   kinds of data, which is why we need another separate stack.\n// - We allocate Thread Local Storage (TLS) by allocating some memory on the heap (an\n//   operation which by itself should not require TLS; otherwise we'd have a Catch-22\n//   situation..), and calling `initThreadLocalStorageMainWorker` with it.\n//\n// Then, when we make any other WebAssembly threads (e.g. in our own WebWorkers, or in\n// the WebWorkers of users), we do the following:\n// - `__wasm_init_memory` is again called automatically, but will be skipped, since an\n//   (atomic) flag has been set not to initialize static memory again.\n// - We need to initialize memory for both the shadow stack and the Thread Local\n//   Storage (TLS), using `makeThreadLocalStorageAndStackDataOnExistingThread`. We do this\n//   by allocating memory on the heap on an already initialized thread, since allocating memory DOES\n//   require the shadow stack to be initialized.\n// - We then use this memory for both the TLS (on the lower side) and the shadow stack\n//   (on the upper side, since it moves downward), using `initThreadLocalStorageAndStackOtherWorkers`.\n//\n// TODO(JP): This currently leaks memory since we never deallocate the TLS/shadow stack!\n//\n// TODO(JP): Even if we do deallocate the memory, there is currently no way to call TLS\n// destructors; so we'd still leak memory. See https://github.com/rust-lang/rust/issues/77839\n// The \"shadow stack\" size for new threads. Note that the main thread will\n// keep using its own shadow stack size.\nconst WASM_STACK_SIZE_BYTES = 2 * 1024 * 1024; // 2 MB\n// For the main worker, we only need to initialize Thread Local Storage (TLS).\nconst initThreadLocalStorageMainWorker = (wasmExports) => {\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(wasmExports.__tls_size.value));\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    wasmExports.__wasm_init_tls(Number(ptr));\n};\n// For non-main workers, we need to allocate enough data for Thread Local Storage (TLS)\n// and the \"shadow stack\". We allocate this data in the main worker, and then send the\n// pointer + size to other workers.\n//\n// This is easier than trying to allocate the appropriate amount of data in the other\n// itself, which is possible (e.g. using memory.grow) but kind of cumbersome.\nconst makeThreadLocalStorageAndStackDataOnExistingThread = (wasmExports) => {\n    // Align size to 64 bits / 8 bytes.\n    const size = Math.ceil((wasmExports.__tls_size.value + WASM_STACK_SIZE_BYTES) / 8) * 8;\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(size));\n    return { ptr, size };\n};\n// Set the shadow stack pointer and initialize thet Thread Local Storage (TLS).\n//\n// Note that the TLS sits on the lower side of the memory, wheras the shadow stack\n// starts on the upper side of the memory and grows downwards.\n//\n// TODO(JP): __wasm_init_tls takes a Number, which might not work when it is >2GB.\nconst initThreadLocalStorageAndStackOtherWorkers = (wasmExports, tlsAndStackData) => {\n    // Start the shadow stack pointer on the upper side of the memory, though subtract\n    // 8 so we don't overwrite the byte right after the memory, while still keeping it\n    // 64-bit aligned. TODO(JP): Is the 64-bit alignment necessary for the shadow stack?\n    wasmExports.__stack_pointer.value =\n        Number(tlsAndStackData.ptr) + tlsAndStackData.size - 8;\n    wasmExports.__wasm_init_tls(\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    Number(tlsAndStackData.ptr));\n};\n////////////////////////////////////////////////////////////////\n// Common wasm functions\n////////////////////////////////////////////////////////////////\nconst copyArrayToRustBuffer = (inputBuffer, outputBuffer, outputPtr) => {\n    // should be the same type as inputBuffer\n    // @ts-ignore: constructor is getting typed as Function instead of a constructor\n    new inputBuffer.constructor(outputBuffer, outputPtr, inputBuffer.length).set(inputBuffer);\n};\nconst getWrfParamType = (array, readonly) => {\n    if (array instanceof Uint8Array) {\n        return readonly ? _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyU8Buffer : _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.U8Buffer;\n    }\n    else if (array instanceof Float32Array) {\n        return readonly ? _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyF32Buffer : _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.F32Buffer;\n    }\n    else {\n        throw new Error(\"Invalid array type\");\n    }\n};\nconst createWasmBuffer = (memory, exports, data) => {\n    const vecPtr = Number(exports.allocWasmVec(BigInt(data.byteLength)));\n    copyArrayToRustBuffer(data, memory.buffer, vecPtr);\n    return vecPtr;\n};\nconst makeZerdeBuilder = (memory, wasmExports) => {\n    const slots = 1024;\n    // We have get memory.buffer *after* calling `allocWasmMessage`, because\n    // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n    const byteOffset = Number(wasmExports.allocWasmMessage(BigInt(slots * 4)));\n    return new _zerde__WEBPACK_IMPORTED_MODULE_2__.ZerdeBuilder({\n        buffer: memory.buffer,\n        byteOffset: byteOffset,\n        slots,\n        growCallback: (_buffer, oldByteOffset, newBytes) => {\n            const newByteOffset = Number(wasmExports.reallocWasmMessage(BigInt(oldByteOffset), BigInt(newBytes)));\n            // We have get memory.buffer *after* calling `reallocWasmMessage`, because\n            // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n            return { buffer: memory.buffer, byteOffset: newByteOffset };\n        },\n    });\n};\nconst getWasmEnv = ({ getExports, memory, taskWorkerSab, fileHandles, sendEventFromAnyThread, threadSpawn, baseUri, }) => {\n    const fileReaderSync = new FileReaderSync();\n    const parseString = (ptr, len) => {\n        let out = \"\";\n        // Can't use TextDecoder here since it doesn't work with SharedArrayBuffer.\n        // TODO(JP): If it becomes important enough, we can see if making a copy to a regular\n        // ArrayBuffer and then using TextDecoder is faster than what we do here.\n        const array = new Uint32Array(memory.buffer, ptr, len);\n        for (let i = 0; i < len; i++) {\n            out += String.fromCharCode(array[i]);\n        }\n        return out;\n    };\n    return {\n        memory,\n        _consoleLog: (charsPtr, len, error) => {\n            const out = parseString(parseInt(charsPtr), parseInt(len));\n            if (error) {\n                console.error(out);\n            }\n            else {\n                console.log(out);\n            }\n        },\n        readUserFileRange: (userFileId, bufPtr, bufLen, fileOffset) => {\n            const file = fileHandles[userFileId];\n            const start = Number(fileOffset);\n            const end = start + Number(bufLen);\n            if (file.lastReadStart <= start && start < file.lastReadEnd) {\n                console.warn(`Read start (${start}) fell in the range of the last read (${file.lastReadStart}-${file.lastReadEnd}); ` +\n                    \"this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.\");\n            }\n            file.lastReadStart = start;\n            file.lastReadEnd = end;\n            // TODO(JP): This creates a new buffer instead of reading directly into the wasm memory.\n            // Maybe we can avoid this by using a stream with a ReadableStreamBYOBReader, but that is\n            // asynchronous, so we'd have to do a dance with another thread and atomics and all that,\n            // and I don't know if that overhead would be worth it..\n            const buffer = fileReaderSync.readAsArrayBuffer(file.file.slice(start, end));\n            copyArrayToRustBuffer(new Uint8Array(buffer), memory.buffer, Number(bufPtr));\n            return BigInt(buffer.byteLength);\n        },\n        performanceNow: () => {\n            return performance.now();\n        },\n        threadSpawn: (ctxPtr) => {\n            threadSpawn(ctxPtr);\n        },\n        _sendEventFromAnyThread: (eventPtr) => {\n            sendEventFromAnyThread(eventPtr);\n        },\n        readUrlSync: (urlPtr, urlLen, bufPtrOut, bufLenOut) => {\n            const url = parseString(urlPtr, urlLen);\n            const request = new XMLHttpRequest();\n            request.responseType = \"arraybuffer\";\n            request.open(\"GET\", new URL(url, baseUri).href, false /* synchronous */);\n            request.send(null);\n            if (request.status === 200) {\n                const exports = getExports();\n                const outputBufPtr = createWasmBuffer(memory, exports, new Uint8Array(request.response));\n                new Uint32Array(memory.buffer, bufPtrOut, 1)[0] = outputBufPtr;\n                new Uint32Array(memory.buffer, bufLenOut, 1)[0] =\n                    request.response.byteLength;\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        },\n        randomU64: () => new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],\n        sendTaskWorkerMessage: (twMessagePtr) => {\n            sendTaskWorkerMessage(taskWorkerSab, parseInt(twMessagePtr));\n        },\n    };\n};\nfunction transformParamsFromRustImpl(memory, destructor, mutableDestructor, params) {\n    return params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else {\n            const wrfBuffer = (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.getWrfBufferWasm)(memory, param, destructor, mutableDestructor);\n            if (param.paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.String) {\n                throw new Error(\"WrfParam buffer type called with string paramType\");\n            }\n            // These are actually WrfArray types, since we overwrite TypedArrays in overwriteTypedArraysWithWrfArrays()\n            const ArrayConstructor = {\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.U8Buffer]: Uint8Array,\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyU8Buffer]: Uint8Array,\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.F32Buffer]: Float32Array,\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyF32Buffer]: Float32Array,\n            }[param.paramType];\n            return (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.getCachedWrfBuffer)(wrfBuffer, new ArrayConstructor(wrfBuffer, param.bufferPtr, param.bufferLen / ArrayConstructor.BYTES_PER_ELEMENT));\n        }\n    });\n}\nfunction assertNotNull(value, objectName = \"Value\") {\n    if (value === null || value === undefined) {\n        throw new Error(`Assertion failed: ${objectName} is null`);\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21tb24udHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL2NvbW1vbi50cz8yMGIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMS1wcmVzZW50LCBDcnVpc2UgTExDXG4vL1xuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UtQVBBQ0hFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBXcmZQYXJhbVR5cGUsIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGdldENhY2hlZFdyZkJ1ZmZlciwgZ2V0V3JmQnVmZmVyV2FzbSB9IGZyb20gXCIuL3dyZl9idWZmZXJcIjtcbmltcG9ydCB7IFplcmRlQnVpbGRlciB9IGZyb20gXCIuL3plcmRlXCI7XG5jb25zdCBSRVNQT05TRSA9IFwiJCRSRVNQT05TRVwiO1xuY29uc3QgRVJST1IgPSBcIiQkRVJST1JcIjtcbi8vIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbGlua2VkIGNoYW5uZWxzIGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBfY3JlYXRlTGlua2VkQ2hhbm5lbHMoKSB7XG4gICAgY29uc3QgbG9jYWwgPSB7XG4gICAgICAgIG9ubWVzc2FnZSxcbiAgICAgICAgcG9zdE1lc3NhZ2UoZGF0YSwgX3RyYW5zZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBldiA9IG5ldyBNZXNzYWdlRXZlbnQoXCJtZXNzYWdlXCIsIHsgZGF0YSB9KTtcbiAgICAgICAgICAgIGlmIChyZW1vdGUub25tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlLm9ubWVzc2FnZShldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCByZW1vdGUgPSB7XG4gICAgICAgIG9ubWVzc2FnZSxcbiAgICAgICAgcG9zdE1lc3NhZ2UoZGF0YSwgX3RyYW5zZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBldiA9IG5ldyBNZXNzYWdlRXZlbnQoXCJtZXNzYWdlXCIsIHsgZGF0YSB9KTtcbiAgICAgICAgICAgIGlmIChsb2NhbC5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBsb2NhbC5vbm1lc3NhZ2UoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHsgbG9jYWwsIHJlbW90ZSB9O1xufVxuLy8gVGhpcyBjbGFzcyBhbGxvd3MgeW91IHRvIGhvb2sgdXAgYmktZGlyZWN0aW9uYWwgYXN5bmMgY2FsbHMgYWNyb3NzIHdlYi13b3JrZXJcbi8vIGJvdW5kYXJpZXMgd2hlcmUgYSBzaW5nbGUgY2FsbCB0byBvciBmcm9tIGEgd29ya2VyIGNhbiAnd2FpdCcgb24gdGhlIHJlc3BvbnNlLlxuLy8gRXJyb3JzIGluIHJlY2VpdmVycyBhcmUgcHJvcGlnYXRlZCBiYWNrIHRvIHRoZSBjYWxsZXIgYXMgYSByZWplY3Rpb24uXG4vLyBJdCBhbHNvIHN1cHBvcnRzIHJldHVybmluZyB0cmFuc2ZlcnJhYmxlcyBvdmVyIHRoZSB3ZWItd29ya2VyIHBvc3RNZXNzYWdlIGFwaSxcbi8vIHdoaWNoIHdhcyB0aGUgbWFpbiBzaG9ydGNvbW1pbmcgd2l0aCB0aGUgd29ya2VyLXJwYyBucG0gbW9kdWxlLlxuLy8gVG8gYXR0YWNoIHJwYyB0byBhbiBpbnN0YW5jZSBvZiBhIHdvcmtlciBpbiB0aGUgbWFpbiB0aHJlYWQ6XG4vLyAgIGNvbnN0IHJwYyA9IG5ldyBScGMod29ya2VySW5zdGFjZSk7XG4vLyBUbyBhdHRhY2ggcnBjIHdpdGhpbiBhbiBhIHdlYiB3b3JrZXI6XG4vLyAgIGNvbnN0IHJwYyA9IG5ldyBScGMoZ2xvYmFsKTtcbi8vIENoZWNrIG91dCB0aGUgdGVzdHMgZm9yIG1vcmUgZXhhbXBsZXMuXG4vLyBTZWUgYHJwY190eXBlcy50c2AgZm9yIGRlc2NyaXB0aW9ucyBvZiBob3cgdG8gc2V0IHVwIHR5cGVkIGludGVyYWN0aW9ucy5cbmV4cG9ydCBjbGFzcyBScGMge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUlkID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl9yZWNlaXZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX29uQ2hhbm5lbE1lc3NhZ2UgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHRvcGljLCBkYXRhIH0gPSBldi5kYXRhO1xuICAgICAgICAgICAgaWYgKHRvcGljID09PSBSRVNQT05TRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3NbaWRdKGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzW2lkXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbnZva2UgdGhlIHJlY2VpdmUgaGFuZGxlciBpbiBhIHByb21pc2Ugc28gaWYgaXQgdGhyb3dzIHN5bmNocm9ub3VzbHkgd2UgY2FuIHJlamVjdFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcmVjZWl2ZXJzLmdldCh0b3BpYyk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gcmVjZWl2ZXIgcmVnaXN0ZXJlZCBmb3IgJHt0b3BpY31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3b3JrcyBib3RoIHdoZW4gYGhhbmRsZXJgIHJldHVybnMgYSB2YWx1ZSBvciBhIFByb21pc2UuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShoYW5kbGVyKGRhdGEpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2UoeyB0b3BpYzogUkVTUE9OU0UsIGlkIH0sIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlcnJhYmxlcyA9IHJlc3VsdFtScGMudHJhbnNmZXJyYWJsZXNdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbUnBjLnRyYW5zZmVycmFibGVzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3BpYzogUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycmFibGVzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3BpYzogUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbRVJST1JdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXJyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiBlcnIuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFtdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5uZWwub25tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFubmVsLm9ubWVzc2FnZSBpcyBhbHJlYWR5IHNldC4gQ2FuIG9ubHkgdXNlIG9uZSBScGMgaW5zdGFuY2UgcGVyIGNoYW5uZWwuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5uZWwub25tZXNzYWdlID0gdGhpcy5fb25DaGFubmVsTWVzc2FnZTtcbiAgICB9XG4gICAgLy8gc2VuZCBhIG1lc3NhZ2UgYWNyb3NzIHRoZSBycGMgYm91bmRhcnkgdG8gYSByZWNlaXZlciBvbiB0aGUgb3RoZXIgc2lkZVxuICAgIC8vIHRoaXMgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZWNlaXZlcidzIHJlc3BvbnNlLiAgSWYgdGhlcmUgaXMgbm8gcmVnaXN0ZXJlZFxuICAgIC8vIHJlY2VpdmVyIGZvciB0aGUgZ2l2ZW4gdG9waWMsIHRoaXMgbWV0aG9kIHRocm93c1xuICAgIHNlbmQodG9waWMsIGRhdGEsIHRyYW5zZmVyKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fbWVzc2FnZUlkKys7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7IHRvcGljLCBpZCwgZGF0YSB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzW2lkXSA9IChpbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uZGF0YSAmJiBpbmZvLmRhdGFbRVJST1JdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGluZm8uZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IGluZm8uZGF0YS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IGluZm8uZGF0YS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW5mby5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIHJlZ2lzdGVyIGEgcmVjZWl2ZXIgZm9yIGEgZ2l2ZW4gbWVzc2FnZSBvbiBhIHRvcGljXG4gICAgLy8gb25seSBvbmUgcmVjZWl2ZXIgY2FuIGJlIHJlZ2lzdGVyZWQgcGVyIHRvcGljIGFuZCBjdXJyZW50bHlcbiAgICAvLyAnZGVyZWdpc3RlcmluZycgYSByZWNlaXZlciBpcyBub3Qgc3VwcG9ydGVkIHNpbmNlIHRoaXMgaXMgbm90IGNvbW1vblxuICAgIHJlY2VpdmUodG9waWMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlY2VpdmVycy5oYXModG9waWMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVyIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgdG9waWM6ICR7dG9waWN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjZWl2ZXJzLnNldCh0b3BpYywgaGFuZGxlcik7XG4gICAgfVxuICAgIHBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFubmVsLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlJwYyBwb3N0TWVzc2FnZSBjYWxsIGl0c2VsZiBmYWlsZWQ6IFwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblJwYy50cmFuc2ZlcnJhYmxlcyA9IFwiJCRUUkFOU0ZFUlJBQkxFU1wiO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTXV0ZXhcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IE1VVEVYX1VOTE9DS0VEID0gMDtcbmNvbnN0IE1VVEVYX0xPQ0tFRCA9IDE7XG5leHBvcnQgY29uc3QgbXV0ZXhMb2NrID0gKHNhYmkzMiwgb2Zmc2V0KSA9PiB7XG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBpbiBhIGxvb3AsIGJlY2F1c2UgYmV0d2VlbiB0aGUgYHdhaXRgIGFuZCBgY29tcGFyZUV4Y2hhbmdlYCBhbm90aGVyIHRocmVhZCBtaWdodFxuICAgIC8vIHRha2UgdGhlIE11dGV4LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoQXRvbWljcy5jb21wYXJlRXhjaGFuZ2Uoc2FiaTMyLCBvZmZzZXQsIE1VVEVYX1VOTE9DS0VELCBNVVRFWF9MT0NLRUQpID09XG4gICAgICAgICAgICBNVVRFWF9VTkxPQ0tFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEF0b21pY3Mud2FpdChzYWJpMzIsIG9mZnNldCwgTVVURVhfTE9DS0VEKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG11dGV4VW5sb2NrID0gKHNhYmkzMiwgb2Zmc2V0KSA9PiB7XG4gICAgaWYgKEF0b21pY3MuY29tcGFyZUV4Y2hhbmdlKHNhYmkzMiwgb2Zmc2V0LCBNVVRFWF9MT0NLRUQsIE1VVEVYX1VOTE9DS0VEKSAhPVxuICAgICAgICBNVVRFWF9MT0NLRUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIG11dGV4X3VubG9jayBvbiBhbiBhbHJlYWR5IHVubG9ja2VkIG11dGV4XCIpO1xuICAgIH1cbiAgICBBdG9taWNzLm5vdGlmeShzYWJpMzIsIG9mZnNldCwgMSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVGFzayB3b3JrZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjb25zdCBUV19TQUJfTVVURVhfUFRSID0gMDtcbmV4cG9ydCBjb25zdCBUV19TQUJfTUVTU0FHRV9DT1VOVF9QVFIgPSAxO1xuLy8gSW5pdGlhbGl6ZSBhIFNoYXJlZEFycmF5QnVmZmVyIHVzZWQgdG8gY29tbXVuaWNhdGUgd2l0aCB0YXNrX3dvcmtlci50cy4gVGhpc1xuLy8gaXMgYSBvbmUtd2F5IGNvbW11bmljYXRpb24gY2hhbm5lbDsgdXNlIHBvaW50ZXJzIGludG8gYG1lbW9yeWAgZm9yIGNvbW11bmljYXRpbmdcbi8vIGluZm9ybWF0aW9uIGJhY2suXG4vL1xuLy8gV2UgdXNlIHRoaXMgYmVjYXVzZSB3ZSB0eXBpY2FsbHkgY2FuJ3QgdXNlIGBwb3N0TWVzc2FnZWA7IHNlZSB0YXNrX3dvcmtlci50c1xuLy8gZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBGb3JtYXQ6XG4vLyAqIGkzMiAoNCBieXRlcykgICAgICAgICAtIHJlYWQvd3JpdGUgbXV0ZXhcbi8vICogaTMyICg0IGJ5dGVzKSAgICAgICAgIC0gbnVtYmVyIG9mIG1lc3NhZ2VzIGluIHF1ZXVlIChub3RpZnkgb24gdGhpcyB0byB3YWtlIHVwIHRoZSB0YXNrIHdvcmtlciAtIGl0IHdpbGxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZCB0aGlzIGJlZm9yZSB0YWtpbmcgYSBtdXRleCwgYnV0IHRoZW4gcmVyZWFkIGl0IGFmdGVyIHRha2luZyB0aGUgbXV0ZXgpXG4vLyAqIG4gKiB1MzIgKG4gKiA0IGJ5dGVzKSAtIHBvaW50ZXJzIHRvIG1lc3NhZ2VzIHNlcmlhbGl6ZWQgd2l0aCBgWmVyZGVCdWlsZGVyYFxuZXhwb3J0IGNvbnN0IGluaXRUYXNrV29ya2VyU2FiID0gKCkgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlclNpemVCeXRlcyA9IDEwMDAwO1xuICAgIGNvbnN0IHRhc2tXb3JrZXJTYWIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoYnVmZmVyU2l6ZUJ5dGVzKTtcbiAgICBjb25zdCB0YXNrV29ya2VyU2FiaTMyID0gbmV3IEludDMyQXJyYXkodGFza1dvcmtlclNhYik7XG4gICAgdGFza1dvcmtlclNhYmkzMltUV19TQUJfTVVURVhfUFRSXSA9IE1VVEVYX1VOTE9DS0VEO1xuICAgIHRhc2tXb3JrZXJTYWJpMzJbVFdfU0FCX01FU1NBR0VfQ09VTlRfUFRSXSA9IDA7XG4gICAgcmV0dXJuIHRhc2tXb3JrZXJTYWI7XG59O1xuLy8gQXBwZW5kIGEgbmV3IG1lc3NhZ2UgcG9pbnRlciB0byB0aGUgU2hhcmVkQXJyYXlCdWZmZXIgdXNlZCBieSB0YXNrX3dvcmtlci50cyxcbi8vIGFuZCB3YWtlIGl0IHVwIHNvIGl0IGNhbiBwcm9jZXNzIHRoaXMgbmV3IG1lc3NhZ2UgKHVubGVzcyBpdCdzIGN1cnJlbnRseSBpbiBwb2xsaW5nXG4vLyBtb2RlLCBpbiB0aGF0IGNhc2UgdGhlIGBBdG9taWNzLm5vdGlmeWAgd2lsbCBqdXN0IG5vdCBkbyBhbnl0aGluZykuXG5jb25zdCBzZW5kVGFza1dvcmtlck1lc3NhZ2UgPSAodGFza1dvcmtlclNhYiwgdHdNZXNzYWdlUHRyKSA9PiB7XG4gICAgY29uc3QgdGFza1dvcmtlclNhYmkzMiA9IG5ldyBJbnQzMkFycmF5KHRhc2tXb3JrZXJTYWIpO1xuICAgIG11dGV4TG9jayh0YXNrV29ya2VyU2FiaTMyLCBUV19TQUJfTVVURVhfUFRSKTtcbiAgICBjb25zdCBjdXJyZW50TnVtYmVyT2ZNZXNzYWdlcyA9IHRhc2tXb3JrZXJTYWJpMzJbVFdfU0FCX01FU1NBR0VfQ09VTlRfUFRSXTtcbiAgICAvLyBVc2UgdW5zaWduZWQgbnVtYmVycyBmb3IgdGhlIGFjdHVhbCBwb2ludGVyLCBzaW5jZSB0aGV5IGNhbiBiZSA+MkdCLlxuICAgIG5ldyBVaW50MzJBcnJheSh0YXNrV29ya2VyU2FiKVtjdXJyZW50TnVtYmVyT2ZNZXNzYWdlcyArIDJdID0gdHdNZXNzYWdlUHRyO1xuICAgIHRhc2tXb3JrZXJTYWJpMzJbVFdfU0FCX01FU1NBR0VfQ09VTlRfUFRSXSA9IGN1cnJlbnROdW1iZXJPZk1lc3NhZ2VzICsgMTtcbiAgICBtdXRleFVubG9jayh0YXNrV29ya2VyU2FiaTMyLCBUV19TQUJfTVVURVhfUFRSKTtcbiAgICBBdG9taWNzLm5vdGlmeSh0YXNrV29ya2VyU2FiaTMyLCAxKTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXYXNtIFRocmVhZCBpbml0aWFsaXphdGlvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVGhyZWFkcyBpbiBXZWJBc3NlbWJseSEgVGhleSBhcmUuLiBmdW4hIEhlcmUncyB3aGF0IGhhcHBlbnMuXG4vL1xuLy8gVGhlIGZpcnN0IFdhc20gaW5zdGFuY2Ugd2Ugc3RhcnQgaXMgaW4gdGhlIG1haW4gd29ya2VyLiBJdCBkb2VzIHRoZSBmb2xsb3dpbmc6XG4vLyAtIEl0IGluaXRpYWxpemVzIHN0YXRpYyBtZW1vcnkgdXNpbmcgYF9fd2FzbV9pbml0X21lbW9yeWAsIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgc2V0XG4vLyAgIGJ5IExMVk0gYXMgdGhlIHNwZWNpYWwgXCJzdGFydFwiIGZ1bmN0aW9uLlxuLy8gLSBJdCBhbHJlYWR5IGhhcyBtZW1vcnkgYWxsb2NhdGVkIGZvciB0aGUgXCJzaGFkb3cgc3RhY2tcIi4gVGhpcyBpcyBsaWtlIGFueSBzdGFjayBpbiBhXG4vLyAgIG5hdGl2ZSBwcm9ncmFtLCBidXQgaW4gV2ViQXNzZW1ibHkgaXQncyBjYWxsZWQgdGhlIFwic2hhZG93IHN0YWNrXCIgYmVjYXVzZSBXZWJBc3NlbWJseVxuLy8gICBpdHNlbGYgYWxzbyBoYXMgYSBub3Rpb24gb2YgYSBzdGFjayBidWlsdC1pbi4gSXQgaXMgaG93ZXZlciBub3Qgc3VpdGFibGUgZm9yIGFsbFxuLy8gICBraW5kcyBvZiBkYXRhLCB3aGljaCBpcyB3aHkgd2UgbmVlZCBhbm90aGVyIHNlcGFyYXRlIHN0YWNrLlxuLy8gLSBXZSBhbGxvY2F0ZSBUaHJlYWQgTG9jYWwgU3RvcmFnZSAoVExTKSBieSBhbGxvY2F0aW5nIHNvbWUgbWVtb3J5IG9uIHRoZSBoZWFwIChhblxuLy8gICBvcGVyYXRpb24gd2hpY2ggYnkgaXRzZWxmIHNob3VsZCBub3QgcmVxdWlyZSBUTFM7IG90aGVyd2lzZSB3ZSdkIGhhdmUgYSBDYXRjaC0yMlxuLy8gICBzaXR1YXRpb24uLiksIGFuZCBjYWxsaW5nIGBpbml0VGhyZWFkTG9jYWxTdG9yYWdlTWFpbldvcmtlcmAgd2l0aCBpdC5cbi8vXG4vLyBUaGVuLCB3aGVuIHdlIG1ha2UgYW55IG90aGVyIFdlYkFzc2VtYmx5IHRocmVhZHMgKGUuZy4gaW4gb3VyIG93biBXZWJXb3JrZXJzLCBvciBpblxuLy8gdGhlIFdlYldvcmtlcnMgb2YgdXNlcnMpLCB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gLSBgX193YXNtX2luaXRfbWVtb3J5YCBpcyBhZ2FpbiBjYWxsZWQgYXV0b21hdGljYWxseSwgYnV0IHdpbGwgYmUgc2tpcHBlZCwgc2luY2UgYW5cbi8vICAgKGF0b21pYykgZmxhZyBoYXMgYmVlbiBzZXQgbm90IHRvIGluaXRpYWxpemUgc3RhdGljIG1lbW9yeSBhZ2Fpbi5cbi8vIC0gV2UgbmVlZCB0byBpbml0aWFsaXplIG1lbW9yeSBmb3IgYm90aCB0aGUgc2hhZG93IHN0YWNrIGFuZCB0aGUgVGhyZWFkIExvY2FsXG4vLyAgIFN0b3JhZ2UgKFRMUyksIHVzaW5nIGBtYWtlVGhyZWFkTG9jYWxTdG9yYWdlQW5kU3RhY2tEYXRhT25FeGlzdGluZ1RocmVhZGAuIFdlIGRvIHRoaXNcbi8vICAgYnkgYWxsb2NhdGluZyBtZW1vcnkgb24gdGhlIGhlYXAgb24gYW4gYWxyZWFkeSBpbml0aWFsaXplZCB0aHJlYWQsIHNpbmNlIGFsbG9jYXRpbmcgbWVtb3J5IERPRVNcbi8vICAgcmVxdWlyZSB0aGUgc2hhZG93IHN0YWNrIHRvIGJlIGluaXRpYWxpemVkLlxuLy8gLSBXZSB0aGVuIHVzZSB0aGlzIG1lbW9yeSBmb3IgYm90aCB0aGUgVExTIChvbiB0aGUgbG93ZXIgc2lkZSkgYW5kIHRoZSBzaGFkb3cgc3RhY2tcbi8vICAgKG9uIHRoZSB1cHBlciBzaWRlLCBzaW5jZSBpdCBtb3ZlcyBkb3dud2FyZCksIHVzaW5nIGBpbml0VGhyZWFkTG9jYWxTdG9yYWdlQW5kU3RhY2tPdGhlcldvcmtlcnNgLlxuLy9cbi8vIFRPRE8oSlApOiBUaGlzIGN1cnJlbnRseSBsZWFrcyBtZW1vcnkgc2luY2Ugd2UgbmV2ZXIgZGVhbGxvY2F0ZSB0aGUgVExTL3NoYWRvdyBzdGFjayFcbi8vXG4vLyBUT0RPKEpQKTogRXZlbiBpZiB3ZSBkbyBkZWFsbG9jYXRlIHRoZSBtZW1vcnksIHRoZXJlIGlzIGN1cnJlbnRseSBubyB3YXkgdG8gY2FsbCBUTFNcbi8vIGRlc3RydWN0b3JzOyBzbyB3ZSdkIHN0aWxsIGxlYWsgbWVtb3J5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9ydXN0L2lzc3Vlcy83NzgzOVxuLy8gVGhlIFwic2hhZG93IHN0YWNrXCIgc2l6ZSBmb3IgbmV3IHRocmVhZHMuIE5vdGUgdGhhdCB0aGUgbWFpbiB0aHJlYWQgd2lsbFxuLy8ga2VlcCB1c2luZyBpdHMgb3duIHNoYWRvdyBzdGFjayBzaXplLlxuY29uc3QgV0FTTV9TVEFDS19TSVpFX0JZVEVTID0gMiAqIDEwMjQgKiAxMDI0OyAvLyAyIE1CXG4vLyBGb3IgdGhlIG1haW4gd29ya2VyLCB3ZSBvbmx5IG5lZWQgdG8gaW5pdGlhbGl6ZSBUaHJlYWQgTG9jYWwgU3RvcmFnZSAoVExTKS5cbmV4cG9ydCBjb25zdCBpbml0VGhyZWFkTG9jYWxTdG9yYWdlTWFpbldvcmtlciA9ICh3YXNtRXhwb3J0cykgPT4ge1xuICAgIC8vIE5vdGUgdGhhdCBhbGxvY1dhc21NZXNzYWdlIGFsd2F5cyBhbGlnbnMgdG8gNjQgYml0cyAvIDggYnl0ZXMuXG4gICAgY29uc3QgcHRyID0gd2FzbUV4cG9ydHMuYWxsb2NXYXNtTWVzc2FnZShCaWdJbnQod2FzbUV4cG9ydHMuX190bHNfc2l6ZS52YWx1ZSkpO1xuICAgIC8vIFRPRE8oSlApOiBDYXN0IHRvIE51bWJlciBjYW4gY2F1c2UgdHJvdWJsZSA+MkdCLlxuICAgIHdhc21FeHBvcnRzLl9fd2FzbV9pbml0X3RscyhOdW1iZXIocHRyKSk7XG59O1xuLy8gRm9yIG5vbi1tYWluIHdvcmtlcnMsIHdlIG5lZWQgdG8gYWxsb2NhdGUgZW5vdWdoIGRhdGEgZm9yIFRocmVhZCBMb2NhbCBTdG9yYWdlIChUTFMpXG4vLyBhbmQgdGhlIFwic2hhZG93IHN0YWNrXCIuIFdlIGFsbG9jYXRlIHRoaXMgZGF0YSBpbiB0aGUgbWFpbiB3b3JrZXIsIGFuZCB0aGVuIHNlbmQgdGhlXG4vLyBwb2ludGVyICsgc2l6ZSB0byBvdGhlciB3b3JrZXJzLlxuLy9cbi8vIFRoaXMgaXMgZWFzaWVyIHRoYW4gdHJ5aW5nIHRvIGFsbG9jYXRlIHRoZSBhcHByb3ByaWF0ZSBhbW91bnQgb2YgZGF0YSBpbiB0aGUgb3RoZXJcbi8vIGl0c2VsZiwgd2hpY2ggaXMgcG9zc2libGUgKGUuZy4gdXNpbmcgbWVtb3J5Lmdyb3cpIGJ1dCBraW5kIG9mIGN1bWJlcnNvbWUuXG5leHBvcnQgY29uc3QgbWFrZVRocmVhZExvY2FsU3RvcmFnZUFuZFN0YWNrRGF0YU9uRXhpc3RpbmdUaHJlYWQgPSAod2FzbUV4cG9ydHMpID0+IHtcbiAgICAvLyBBbGlnbiBzaXplIHRvIDY0IGJpdHMgLyA4IGJ5dGVzLlxuICAgIGNvbnN0IHNpemUgPSBNYXRoLmNlaWwoKHdhc21FeHBvcnRzLl9fdGxzX3NpemUudmFsdWUgKyBXQVNNX1NUQUNLX1NJWkVfQllURVMpIC8gOCkgKiA4O1xuICAgIC8vIE5vdGUgdGhhdCBhbGxvY1dhc21NZXNzYWdlIGFsd2F5cyBhbGlnbnMgdG8gNjQgYml0cyAvIDggYnl0ZXMuXG4gICAgY29uc3QgcHRyID0gd2FzbUV4cG9ydHMuYWxsb2NXYXNtTWVzc2FnZShCaWdJbnQoc2l6ZSkpO1xuICAgIHJldHVybiB7IHB0ciwgc2l6ZSB9O1xufTtcbi8vIFNldCB0aGUgc2hhZG93IHN0YWNrIHBvaW50ZXIgYW5kIGluaXRpYWxpemUgdGhldCBUaHJlYWQgTG9jYWwgU3RvcmFnZSAoVExTKS5cbi8vXG4vLyBOb3RlIHRoYXQgdGhlIFRMUyBzaXRzIG9uIHRoZSBsb3dlciBzaWRlIG9mIHRoZSBtZW1vcnksIHdoZXJhcyB0aGUgc2hhZG93IHN0YWNrXG4vLyBzdGFydHMgb24gdGhlIHVwcGVyIHNpZGUgb2YgdGhlIG1lbW9yeSBhbmQgZ3Jvd3MgZG93bndhcmRzLlxuLy9cbi8vIFRPRE8oSlApOiBfX3dhc21faW5pdF90bHMgdGFrZXMgYSBOdW1iZXIsIHdoaWNoIG1pZ2h0IG5vdCB3b3JrIHdoZW4gaXQgaXMgPjJHQi5cbmV4cG9ydCBjb25zdCBpbml0VGhyZWFkTG9jYWxTdG9yYWdlQW5kU3RhY2tPdGhlcldvcmtlcnMgPSAod2FzbUV4cG9ydHMsIHRsc0FuZFN0YWNrRGF0YSkgPT4ge1xuICAgIC8vIFN0YXJ0IHRoZSBzaGFkb3cgc3RhY2sgcG9pbnRlciBvbiB0aGUgdXBwZXIgc2lkZSBvZiB0aGUgbWVtb3J5LCB0aG91Z2ggc3VidHJhY3RcbiAgICAvLyA4IHNvIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgYnl0ZSByaWdodCBhZnRlciB0aGUgbWVtb3J5LCB3aGlsZSBzdGlsbCBrZWVwaW5nIGl0XG4gICAgLy8gNjQtYml0IGFsaWduZWQuIFRPRE8oSlApOiBJcyB0aGUgNjQtYml0IGFsaWdubWVudCBuZWNlc3NhcnkgZm9yIHRoZSBzaGFkb3cgc3RhY2s/XG4gICAgd2FzbUV4cG9ydHMuX19zdGFja19wb2ludGVyLnZhbHVlID1cbiAgICAgICAgTnVtYmVyKHRsc0FuZFN0YWNrRGF0YS5wdHIpICsgdGxzQW5kU3RhY2tEYXRhLnNpemUgLSA4O1xuICAgIHdhc21FeHBvcnRzLl9fd2FzbV9pbml0X3RscyhcbiAgICAvLyBUT0RPKEpQKTogQ2FzdCB0byBOdW1iZXIgY2FuIGNhdXNlIHRyb3VibGUgPjJHQi5cbiAgICBOdW1iZXIodGxzQW5kU3RhY2tEYXRhLnB0cikpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENvbW1vbiB3YXNtIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGNvcHlBcnJheVRvUnVzdEJ1ZmZlciA9IChpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBvdXRwdXRQdHIpID0+IHtcbiAgICAvLyBzaG91bGQgYmUgdGhlIHNhbWUgdHlwZSBhcyBpbnB1dEJ1ZmZlclxuICAgIC8vIEB0cy1pZ25vcmU6IGNvbnN0cnVjdG9yIGlzIGdldHRpbmcgdHlwZWQgYXMgRnVuY3Rpb24gaW5zdGVhZCBvZiBhIGNvbnN0cnVjdG9yXG4gICAgbmV3IGlucHV0QnVmZmVyLmNvbnN0cnVjdG9yKG91dHB1dEJ1ZmZlciwgb3V0cHV0UHRyLCBpbnB1dEJ1ZmZlci5sZW5ndGgpLnNldChpbnB1dEJ1ZmZlcik7XG59O1xuZXhwb3J0IGNvbnN0IGdldFdyZlBhcmFtVHlwZSA9IChhcnJheSwgcmVhZG9ubHkpID0+IHtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiByZWFkb25seSA/IFdyZlBhcmFtVHlwZS5SZWFkT25seVU4QnVmZmVyIDogV3JmUGFyYW1UeXBlLlU4QnVmZmVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgICByZXR1cm4gcmVhZG9ubHkgPyBXcmZQYXJhbVR5cGUuUmVhZE9ubHlGMzJCdWZmZXIgOiBXcmZQYXJhbVR5cGUuRjMyQnVmZmVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcnJheSB0eXBlXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgY3JlYXRlV2FzbUJ1ZmZlciA9IChtZW1vcnksIGV4cG9ydHMsIGRhdGEpID0+IHtcbiAgICBjb25zdCB2ZWNQdHIgPSBOdW1iZXIoZXhwb3J0cy5hbGxvY1dhc21WZWMoQmlnSW50KGRhdGEuYnl0ZUxlbmd0aCkpKTtcbiAgICBjb3B5QXJyYXlUb1J1c3RCdWZmZXIoZGF0YSwgbWVtb3J5LmJ1ZmZlciwgdmVjUHRyKTtcbiAgICByZXR1cm4gdmVjUHRyO1xufTtcbmV4cG9ydCBjb25zdCBtYWtlWmVyZGVCdWlsZGVyID0gKG1lbW9yeSwgd2FzbUV4cG9ydHMpID0+IHtcbiAgICBjb25zdCBzbG90cyA9IDEwMjQ7XG4gICAgLy8gV2UgaGF2ZSBnZXQgbWVtb3J5LmJ1ZmZlciAqYWZ0ZXIqIGNhbGxpbmcgYGFsbG9jV2FzbU1lc3NhZ2VgLCBiZWNhdXNlXG4gICAgLy8gdGhlcmUncyBhIGdvb2QgY2hhbmNlIGl0J2xsIGdldCBzd2FwcGVkIG91dCAoaWYgaXQgbmVlZGVkIHRvIGdyb3cgdGhlIGJ1ZmZlcikuXG4gICAgY29uc3QgYnl0ZU9mZnNldCA9IE51bWJlcih3YXNtRXhwb3J0cy5hbGxvY1dhc21NZXNzYWdlKEJpZ0ludChzbG90cyAqIDQpKSk7XG4gICAgcmV0dXJuIG5ldyBaZXJkZUJ1aWxkZXIoe1xuICAgICAgICBidWZmZXI6IG1lbW9yeS5idWZmZXIsXG4gICAgICAgIGJ5dGVPZmZzZXQ6IGJ5dGVPZmZzZXQsXG4gICAgICAgIHNsb3RzLFxuICAgICAgICBncm93Q2FsbGJhY2s6IChfYnVmZmVyLCBvbGRCeXRlT2Zmc2V0LCBuZXdCeXRlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Qnl0ZU9mZnNldCA9IE51bWJlcih3YXNtRXhwb3J0cy5yZWFsbG9jV2FzbU1lc3NhZ2UoQmlnSW50KG9sZEJ5dGVPZmZzZXQpLCBCaWdJbnQobmV3Qnl0ZXMpKSk7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGdldCBtZW1vcnkuYnVmZmVyICphZnRlciogY2FsbGluZyBgcmVhbGxvY1dhc21NZXNzYWdlYCwgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhlcmUncyBhIGdvb2QgY2hhbmNlIGl0J2xsIGdldCBzd2FwcGVkIG91dCAoaWYgaXQgbmVlZGVkIHRvIGdyb3cgdGhlIGJ1ZmZlcikuXG4gICAgICAgICAgICByZXR1cm4geyBidWZmZXI6IG1lbW9yeS5idWZmZXIsIGJ5dGVPZmZzZXQ6IG5ld0J5dGVPZmZzZXQgfTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgZ2V0V2FzbUVudiA9ICh7IGdldEV4cG9ydHMsIG1lbW9yeSwgdGFza1dvcmtlclNhYiwgZmlsZUhhbmRsZXMsIHNlbmRFdmVudEZyb21BbnlUaHJlYWQsIHRocmVhZFNwYXduLCBiYXNlVXJpLCB9KSA9PiB7XG4gICAgY29uc3QgZmlsZVJlYWRlclN5bmMgPSBuZXcgRmlsZVJlYWRlclN5bmMoKTtcbiAgICBjb25zdCBwYXJzZVN0cmluZyA9IChwdHIsIGxlbikgPT4ge1xuICAgICAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICAgICAgLy8gQ2FuJ3QgdXNlIFRleHREZWNvZGVyIGhlcmUgc2luY2UgaXQgZG9lc24ndCB3b3JrIHdpdGggU2hhcmVkQXJyYXlCdWZmZXIuXG4gICAgICAgIC8vIFRPRE8oSlApOiBJZiBpdCBiZWNvbWVzIGltcG9ydGFudCBlbm91Z2gsIHdlIGNhbiBzZWUgaWYgbWFraW5nIGEgY29weSB0byBhIHJlZ3VsYXJcbiAgICAgICAgLy8gQXJyYXlCdWZmZXIgYW5kIHRoZW4gdXNpbmcgVGV4dERlY29kZXIgaXMgZmFzdGVyIHRoYW4gd2hhdCB3ZSBkbyBoZXJlLlxuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCBwdHIsIGxlbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVtb3J5LFxuICAgICAgICBfY29uc29sZUxvZzogKGNoYXJzUHRyLCBsZW4sIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdXQgPSBwYXJzZVN0cmluZyhwYXJzZUludChjaGFyc1B0ciksIHBhcnNlSW50KGxlbikpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cob3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZFVzZXJGaWxlUmFuZ2U6ICh1c2VyRmlsZUlkLCBidWZQdHIsIGJ1ZkxlbiwgZmlsZU9mZnNldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVIYW5kbGVzW3VzZXJGaWxlSWRdO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBOdW1iZXIoZmlsZU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIE51bWJlcihidWZMZW4pO1xuICAgICAgICAgICAgaWYgKGZpbGUubGFzdFJlYWRTdGFydCA8PSBzdGFydCAmJiBzdGFydCA8IGZpbGUubGFzdFJlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJlYWQgc3RhcnQgKCR7c3RhcnR9KSBmZWxsIGluIHRoZSByYW5nZSBvZiB0aGUgbGFzdCByZWFkICgke2ZpbGUubGFzdFJlYWRTdGFydH0tJHtmaWxlLmxhc3RSZWFkRW5kfSk7IGAgK1xuICAgICAgICAgICAgICAgICAgICBcInRoaXMgdXN1YWxseSBoYXBwZW5zIGlmIHlvdSBkb24ndCB1c2UgQnVmUmVhZGVyIG9yIGlmIHlvdSBkb24ndCB1c2UgQnVmUmVhZGVyLnNlZWtfcmVsYXRpdmUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZS5sYXN0UmVhZFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBmaWxlLmxhc3RSZWFkRW5kID0gZW5kO1xuICAgICAgICAgICAgLy8gVE9ETyhKUCk6IFRoaXMgY3JlYXRlcyBhIG5ldyBidWZmZXIgaW5zdGVhZCBvZiByZWFkaW5nIGRpcmVjdGx5IGludG8gdGhlIHdhc20gbWVtb3J5LlxuICAgICAgICAgICAgLy8gTWF5YmUgd2UgY2FuIGF2b2lkIHRoaXMgYnkgdXNpbmcgYSBzdHJlYW0gd2l0aCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciwgYnV0IHRoYXQgaXNcbiAgICAgICAgICAgIC8vIGFzeW5jaHJvbm91cywgc28gd2UnZCBoYXZlIHRvIGRvIGEgZGFuY2Ugd2l0aCBhbm90aGVyIHRocmVhZCBhbmQgYXRvbWljcyBhbmQgYWxsIHRoYXQsXG4gICAgICAgICAgICAvLyBhbmQgSSBkb24ndCBrbm93IGlmIHRoYXQgb3ZlcmhlYWQgd291bGQgYmUgd29ydGggaXQuLlxuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZmlsZVJlYWRlclN5bmMucmVhZEFzQXJyYXlCdWZmZXIoZmlsZS5maWxlLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGNvcHlBcnJheVRvUnVzdEJ1ZmZlcihuZXcgVWludDhBcnJheShidWZmZXIpLCBtZW1vcnkuYnVmZmVyLCBOdW1iZXIoYnVmUHRyKSk7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVyZm9ybWFuY2VOb3c6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhyZWFkU3Bhd246IChjdHhQdHIpID0+IHtcbiAgICAgICAgICAgIHRocmVhZFNwYXduKGN0eFB0cik7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZW5kRXZlbnRGcm9tQW55VGhyZWFkOiAoZXZlbnRQdHIpID0+IHtcbiAgICAgICAgICAgIHNlbmRFdmVudEZyb21BbnlUaHJlYWQoZXZlbnRQdHIpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkVXJsU3luYzogKHVybFB0ciwgdXJsTGVuLCBidWZQdHJPdXQsIGJ1Zkxlbk91dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gcGFyc2VTdHJpbmcodXJsUHRyLCB1cmxMZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgbmV3IFVSTCh1cmwsIGJhc2VVcmkpLmhyZWYsIGZhbHNlIC8qIHN5bmNocm9ub3VzICovKTtcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0cyA9IGdldEV4cG9ydHMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRCdWZQdHIgPSBjcmVhdGVXYXNtQnVmZmVyKG1lbW9yeSwgZXhwb3J0cywgbmV3IFVpbnQ4QXJyYXkocmVxdWVzdC5yZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCBidWZQdHJPdXQsIDEpWzBdID0gb3V0cHV0QnVmUHRyO1xuICAgICAgICAgICAgICAgIG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCBidWZMZW5PdXQsIDEpWzBdID1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJhbmRvbVU2NDogKCkgPT4gbmV3IEJpZ1VpbnQ2NEFycmF5KHNlbGYuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpLmJ1ZmZlcilbMF0sXG4gICAgICAgIHNlbmRUYXNrV29ya2VyTWVzc2FnZTogKHR3TWVzc2FnZVB0cikgPT4ge1xuICAgICAgICAgICAgc2VuZFRhc2tXb3JrZXJNZXNzYWdlKHRhc2tXb3JrZXJTYWIsIHBhcnNlSW50KHR3TWVzc2FnZVB0cikpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0SW1wbChtZW1vcnksIGRlc3RydWN0b3IsIG11dGFibGVEZXN0cnVjdG9yLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gZ2V0V3JmQnVmZmVyV2FzbShtZW1vcnksIHBhcmFtLCBkZXN0cnVjdG9yLCBtdXRhYmxlRGVzdHJ1Y3Rvcik7XG4gICAgICAgICAgICBpZiAocGFyYW0ucGFyYW1UeXBlID09PSBXcmZQYXJhbVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JmUGFyYW0gYnVmZmVyIHR5cGUgY2FsbGVkIHdpdGggc3RyaW5nIHBhcmFtVHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBhY3R1YWxseSBXcmZBcnJheSB0eXBlcywgc2luY2Ugd2Ugb3ZlcndyaXRlIFR5cGVkQXJyYXlzIGluIG92ZXJ3cml0ZVR5cGVkQXJyYXlzV2l0aFdyZkFycmF5cygpXG4gICAgICAgICAgICBjb25zdCBBcnJheUNvbnN0cnVjdG9yID0ge1xuICAgICAgICAgICAgICAgIFtXcmZQYXJhbVR5cGUuVThCdWZmZXJdOiBVaW50OEFycmF5LFxuICAgICAgICAgICAgICAgIFtXcmZQYXJhbVR5cGUuUmVhZE9ubHlVOEJ1ZmZlcl06IFVpbnQ4QXJyYXksXG4gICAgICAgICAgICAgICAgW1dyZlBhcmFtVHlwZS5GMzJCdWZmZXJdOiBGbG9hdDMyQXJyYXksXG4gICAgICAgICAgICAgICAgW1dyZlBhcmFtVHlwZS5SZWFkT25seUYzMkJ1ZmZlcl06IEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAgIH1bcGFyYW0ucGFyYW1UeXBlXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDYWNoZWRXcmZCdWZmZXIod3JmQnVmZmVyLCBuZXcgQXJyYXlDb25zdHJ1Y3Rvcih3cmZCdWZmZXIsIHBhcmFtLmJ1ZmZlclB0ciwgcGFyYW0uYnVmZmVyTGVuIC8gQXJyYXlDb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVCkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm90TnVsbCh2YWx1ZSwgb2JqZWN0TmFtZSA9IFwiVmFsdWVcIikge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXJ0aW9uIGZhaWxlZDogJHtvYmplY3ROYW1lfSBpcyBudWxsYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./common.ts\n");

/***/ }),

/***/ "./rpc_types.ts":
/*!**********************!*\
  !*** ./rpc_types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WorkerEvent\": () => (/* binding */ WorkerEvent),\n/* harmony export */   \"TaskWorkerEvent\": () => (/* binding */ TaskWorkerEvent),\n/* harmony export */   \"AsyncWorkerEvent\": () => (/* binding */ AsyncWorkerEvent),\n/* harmony export */   \"MainWorkerChannelEvent\": () => (/* binding */ MainWorkerChannelEvent)\n/* harmony export */ });\nvar WorkerEvent;\n(function (WorkerEvent) {\n    WorkerEvent[\"CallRust\"] = \"WorkerEvent.CallRust\";\n    WorkerEvent[\"CreateBuffer\"] = \"WorkerEvent.CreateBuffer\";\n    WorkerEvent[\"CreateReadOnlyBuffer\"] = \"WorkerEvent.CreateReadOnlyBuffer\";\n    WorkerEvent[\"BindMainWorkerPort\"] = \"WorkerEvent.BindMainWorkerPort\";\n    WorkerEvent[\"DecrementArc\"] = \"WorkerEvent.DecrementArc\";\n    WorkerEvent[\"DeallocVec\"] = \"WorkerEvent.DeallocVec\";\n    WorkerEvent[\"IncrementArc\"] = \"WorkerEvent.IncrementArc\";\n    WorkerEvent[\"DragEnter\"] = \"WorkerEvent.DragEnter\";\n    WorkerEvent[\"DragOver\"] = \"WorkerEvent.DragOver\";\n    WorkerEvent[\"DragLeave\"] = \"WorkerEvent.DragLeave\";\n    WorkerEvent[\"Drop\"] = \"WorkerEvent.Drop\";\n    WorkerEvent[\"WindowMouseUp\"] = \"WorkerEvent.WindowMouseUp\";\n    WorkerEvent[\"CanvasMouseDown\"] = \"WorkerEvent.CanvasMouseDown\";\n    WorkerEvent[\"WindowMouseMove\"] = \"WorkerEvent.WindowMouseMove\";\n    WorkerEvent[\"WindowMouseOut\"] = \"WorkerEvent.WindowMouseOut\";\n    WorkerEvent[\"WindowFocus\"] = \"WorkerEvent.WindowFocus\";\n    WorkerEvent[\"WindowBlur\"] = \"WorkerEvent.WindowBlur\";\n    WorkerEvent[\"ScreenResize\"] = \"WorkerEvent.ScreenResize\";\n    WorkerEvent[\"CanvasWheel\"] = \"WorkerEvent.CanvasWheel\";\n    WorkerEvent[\"ShowIncompatibleBrowserNotification\"] = \"WorkerEvent.ShowIncompatibleBrowserNotification\";\n    WorkerEvent[\"RemoveLoadingIndicators\"] = \"WorkerEvent.RemoveLoadingIndicators\";\n    WorkerEvent[\"SetDocumentTitle\"] = \"WorkerEvent.SetDocumentTitle\";\n    WorkerEvent[\"SetMouseCursor\"] = \"WorkerEvent.SetMouseCursor\";\n    WorkerEvent[\"Fullscreen\"] = \"WorkerEvent.Fullscreen\";\n    WorkerEvent[\"Normalscreen\"] = \"WorkerEvent.Normalscreen\";\n    WorkerEvent[\"TextCopyResponse\"] = \"WorkerEvent.TextCopyResponse\";\n    WorkerEvent[\"EnableGlobalFileDropTarget\"] = \"WorkerEvent.EnableGlobalFileDropTarget\";\n    WorkerEvent[\"CallJs\"] = \"WorkerEvent.CallJs\";\n    WorkerEvent[\"ShowTextIME\"] = \"WorkerEvent.ShowTextIME\";\n    WorkerEvent[\"TextInput\"] = \"WorkerEvent.TextInput\";\n    WorkerEvent[\"TextCopy\"] = \"WorkerEvent.TextCopy\";\n    WorkerEvent[\"KeyDown\"] = \"WorkerEvent.KeyDown\";\n    WorkerEvent[\"KeyUp\"] = \"WorkerEvent.KeyUp\";\n    WorkerEvent[\"Init\"] = \"WorkerEvent.Init\";\n    WorkerEvent[\"RunWebGL\"] = \"WorkerEvent.RunWebGL\";\n    WorkerEvent[\"ThreadSpawn\"] = \"WorkerEvent.ThreadSpawn\";\n    WorkerEvent[\"WindowTouchStart\"] = \"WorkerEvent.WindowTouchStart\";\n    WorkerEvent[\"WindowTouchMove\"] = \"WorkerEvent.WindowTouchMove\";\n    WorkerEvent[\"WindowTouchEndCancelLeave\"] = \"WorkerEvent.WindowTouchEndCancelLeave\";\n})(WorkerEvent || (WorkerEvent = {}));\nvar TaskWorkerEvent;\n(function (TaskWorkerEvent) {\n    TaskWorkerEvent[\"Init\"] = \"TaskWorkerEvent.Init\";\n})(TaskWorkerEvent || (TaskWorkerEvent = {}));\nvar AsyncWorkerEvent;\n(function (AsyncWorkerEvent) {\n    AsyncWorkerEvent[\"Run\"] = \"AsyncWorkerEvent.Run\";\n    AsyncWorkerEvent[\"ThreadSpawn\"] = \"AsyncWorkerEvent.ThreadSpawn\";\n})(AsyncWorkerEvent || (AsyncWorkerEvent = {}));\nvar MainWorkerChannelEvent;\n(function (MainWorkerChannelEvent) {\n    MainWorkerChannelEvent[\"Init\"] = \"MainWorkerChannelEvent.Init\";\n    MainWorkerChannelEvent[\"BindMainWorkerPort\"] = \"MainWorkerChannelEvent.BindMainWorkerPort\";\n    MainWorkerChannelEvent[\"CallRust\"] = \"MainWorkerChannelEvent.CallRust\";\n    MainWorkerChannelEvent[\"SendEventFromAnyThread\"] = \"MainWorkerChannelEvent.SendEventFromAnyThread\";\n})(MainWorkerChannelEvent || (MainWorkerChannelEvent = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ycGNfdHlwZXMudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vcnBjX3R5cGVzLnRzPzg4M2IiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBXb3JrZXJFdmVudDtcbihmdW5jdGlvbiAoV29ya2VyRXZlbnQpIHtcbiAgICBXb3JrZXJFdmVudFtcIkNhbGxSdXN0XCJdID0gXCJXb3JrZXJFdmVudC5DYWxsUnVzdFwiO1xuICAgIFdvcmtlckV2ZW50W1wiQ3JlYXRlQnVmZmVyXCJdID0gXCJXb3JrZXJFdmVudC5DcmVhdGVCdWZmZXJcIjtcbiAgICBXb3JrZXJFdmVudFtcIkNyZWF0ZVJlYWRPbmx5QnVmZmVyXCJdID0gXCJXb3JrZXJFdmVudC5DcmVhdGVSZWFkT25seUJ1ZmZlclwiO1xuICAgIFdvcmtlckV2ZW50W1wiQmluZE1haW5Xb3JrZXJQb3J0XCJdID0gXCJXb3JrZXJFdmVudC5CaW5kTWFpbldvcmtlclBvcnRcIjtcbiAgICBXb3JrZXJFdmVudFtcIkRlY3JlbWVudEFyY1wiXSA9IFwiV29ya2VyRXZlbnQuRGVjcmVtZW50QXJjXCI7XG4gICAgV29ya2VyRXZlbnRbXCJEZWFsbG9jVmVjXCJdID0gXCJXb3JrZXJFdmVudC5EZWFsbG9jVmVjXCI7XG4gICAgV29ya2VyRXZlbnRbXCJJbmNyZW1lbnRBcmNcIl0gPSBcIldvcmtlckV2ZW50LkluY3JlbWVudEFyY1wiO1xuICAgIFdvcmtlckV2ZW50W1wiRHJhZ0VudGVyXCJdID0gXCJXb3JrZXJFdmVudC5EcmFnRW50ZXJcIjtcbiAgICBXb3JrZXJFdmVudFtcIkRyYWdPdmVyXCJdID0gXCJXb3JrZXJFdmVudC5EcmFnT3ZlclwiO1xuICAgIFdvcmtlckV2ZW50W1wiRHJhZ0xlYXZlXCJdID0gXCJXb3JrZXJFdmVudC5EcmFnTGVhdmVcIjtcbiAgICBXb3JrZXJFdmVudFtcIkRyb3BcIl0gPSBcIldvcmtlckV2ZW50LkRyb3BcIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd01vdXNlVXBcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd01vdXNlVXBcIjtcbiAgICBXb3JrZXJFdmVudFtcIkNhbnZhc01vdXNlRG93blwiXSA9IFwiV29ya2VyRXZlbnQuQ2FudmFzTW91c2VEb3duXCI7XG4gICAgV29ya2VyRXZlbnRbXCJXaW5kb3dNb3VzZU1vdmVcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd01vdXNlTW92ZVwiO1xuICAgIFdvcmtlckV2ZW50W1wiV2luZG93TW91c2VPdXRcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd01vdXNlT3V0XCI7XG4gICAgV29ya2VyRXZlbnRbXCJXaW5kb3dGb2N1c1wiXSA9IFwiV29ya2VyRXZlbnQuV2luZG93Rm9jdXNcIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd0JsdXJcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd0JsdXJcIjtcbiAgICBXb3JrZXJFdmVudFtcIlNjcmVlblJlc2l6ZVwiXSA9IFwiV29ya2VyRXZlbnQuU2NyZWVuUmVzaXplXCI7XG4gICAgV29ya2VyRXZlbnRbXCJDYW52YXNXaGVlbFwiXSA9IFwiV29ya2VyRXZlbnQuQ2FudmFzV2hlZWxcIjtcbiAgICBXb3JrZXJFdmVudFtcIlNob3dJbmNvbXBhdGlibGVCcm93c2VyTm90aWZpY2F0aW9uXCJdID0gXCJXb3JrZXJFdmVudC5TaG93SW5jb21wYXRpYmxlQnJvd3Nlck5vdGlmaWNhdGlvblwiO1xuICAgIFdvcmtlckV2ZW50W1wiUmVtb3ZlTG9hZGluZ0luZGljYXRvcnNcIl0gPSBcIldvcmtlckV2ZW50LlJlbW92ZUxvYWRpbmdJbmRpY2F0b3JzXCI7XG4gICAgV29ya2VyRXZlbnRbXCJTZXREb2N1bWVudFRpdGxlXCJdID0gXCJXb3JrZXJFdmVudC5TZXREb2N1bWVudFRpdGxlXCI7XG4gICAgV29ya2VyRXZlbnRbXCJTZXRNb3VzZUN1cnNvclwiXSA9IFwiV29ya2VyRXZlbnQuU2V0TW91c2VDdXJzb3JcIjtcbiAgICBXb3JrZXJFdmVudFtcIkZ1bGxzY3JlZW5cIl0gPSBcIldvcmtlckV2ZW50LkZ1bGxzY3JlZW5cIjtcbiAgICBXb3JrZXJFdmVudFtcIk5vcm1hbHNjcmVlblwiXSA9IFwiV29ya2VyRXZlbnQuTm9ybWFsc2NyZWVuXCI7XG4gICAgV29ya2VyRXZlbnRbXCJUZXh0Q29weVJlc3BvbnNlXCJdID0gXCJXb3JrZXJFdmVudC5UZXh0Q29weVJlc3BvbnNlXCI7XG4gICAgV29ya2VyRXZlbnRbXCJFbmFibGVHbG9iYWxGaWxlRHJvcFRhcmdldFwiXSA9IFwiV29ya2VyRXZlbnQuRW5hYmxlR2xvYmFsRmlsZURyb3BUYXJnZXRcIjtcbiAgICBXb3JrZXJFdmVudFtcIkNhbGxKc1wiXSA9IFwiV29ya2VyRXZlbnQuQ2FsbEpzXCI7XG4gICAgV29ya2VyRXZlbnRbXCJTaG93VGV4dElNRVwiXSA9IFwiV29ya2VyRXZlbnQuU2hvd1RleHRJTUVcIjtcbiAgICBXb3JrZXJFdmVudFtcIlRleHRJbnB1dFwiXSA9IFwiV29ya2VyRXZlbnQuVGV4dElucHV0XCI7XG4gICAgV29ya2VyRXZlbnRbXCJUZXh0Q29weVwiXSA9IFwiV29ya2VyRXZlbnQuVGV4dENvcHlcIjtcbiAgICBXb3JrZXJFdmVudFtcIktleURvd25cIl0gPSBcIldvcmtlckV2ZW50LktleURvd25cIjtcbiAgICBXb3JrZXJFdmVudFtcIktleVVwXCJdID0gXCJXb3JrZXJFdmVudC5LZXlVcFwiO1xuICAgIFdvcmtlckV2ZW50W1wiSW5pdFwiXSA9IFwiV29ya2VyRXZlbnQuSW5pdFwiO1xuICAgIFdvcmtlckV2ZW50W1wiUnVuV2ViR0xcIl0gPSBcIldvcmtlckV2ZW50LlJ1bldlYkdMXCI7XG4gICAgV29ya2VyRXZlbnRbXCJUaHJlYWRTcGF3blwiXSA9IFwiV29ya2VyRXZlbnQuVGhyZWFkU3Bhd25cIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd1RvdWNoU3RhcnRcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd1RvdWNoU3RhcnRcIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd1RvdWNoTW92ZVwiXSA9IFwiV29ya2VyRXZlbnQuV2luZG93VG91Y2hNb3ZlXCI7XG4gICAgV29ya2VyRXZlbnRbXCJXaW5kb3dUb3VjaEVuZENhbmNlbExlYXZlXCJdID0gXCJXb3JrZXJFdmVudC5XaW5kb3dUb3VjaEVuZENhbmNlbExlYXZlXCI7XG59KShXb3JrZXJFdmVudCB8fCAoV29ya2VyRXZlbnQgPSB7fSkpO1xuZXhwb3J0IHZhciBUYXNrV29ya2VyRXZlbnQ7XG4oZnVuY3Rpb24gKFRhc2tXb3JrZXJFdmVudCkge1xuICAgIFRhc2tXb3JrZXJFdmVudFtcIkluaXRcIl0gPSBcIlRhc2tXb3JrZXJFdmVudC5Jbml0XCI7XG59KShUYXNrV29ya2VyRXZlbnQgfHwgKFRhc2tXb3JrZXJFdmVudCA9IHt9KSk7XG5leHBvcnQgdmFyIEFzeW5jV29ya2VyRXZlbnQ7XG4oZnVuY3Rpb24gKEFzeW5jV29ya2VyRXZlbnQpIHtcbiAgICBBc3luY1dvcmtlckV2ZW50W1wiUnVuXCJdID0gXCJBc3luY1dvcmtlckV2ZW50LlJ1blwiO1xuICAgIEFzeW5jV29ya2VyRXZlbnRbXCJUaHJlYWRTcGF3blwiXSA9IFwiQXN5bmNXb3JrZXJFdmVudC5UaHJlYWRTcGF3blwiO1xufSkoQXN5bmNXb3JrZXJFdmVudCB8fCAoQXN5bmNXb3JrZXJFdmVudCA9IHt9KSk7XG5leHBvcnQgdmFyIE1haW5Xb3JrZXJDaGFubmVsRXZlbnQ7XG4oZnVuY3Rpb24gKE1haW5Xb3JrZXJDaGFubmVsRXZlbnQpIHtcbiAgICBNYWluV29ya2VyQ2hhbm5lbEV2ZW50W1wiSW5pdFwiXSA9IFwiTWFpbldvcmtlckNoYW5uZWxFdmVudC5Jbml0XCI7XG4gICAgTWFpbldvcmtlckNoYW5uZWxFdmVudFtcIkJpbmRNYWluV29ya2VyUG9ydFwiXSA9IFwiTWFpbldvcmtlckNoYW5uZWxFdmVudC5CaW5kTWFpbldvcmtlclBvcnRcIjtcbiAgICBNYWluV29ya2VyQ2hhbm5lbEV2ZW50W1wiQ2FsbFJ1c3RcIl0gPSBcIk1haW5Xb3JrZXJDaGFubmVsRXZlbnQuQ2FsbFJ1c3RcIjtcbiAgICBNYWluV29ya2VyQ2hhbm5lbEV2ZW50W1wiU2VuZEV2ZW50RnJvbUFueVRocmVhZFwiXSA9IFwiTWFpbldvcmtlckNoYW5uZWxFdmVudC5TZW5kRXZlbnRGcm9tQW55VGhyZWFkXCI7XG59KShNYWluV29ya2VyQ2hhbm5lbEV2ZW50IHx8IChNYWluV29ya2VyQ2hhbm5lbEV2ZW50ID0ge30pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./rpc_types.ts\n");

/***/ }),

/***/ "./type_of_runtime.ts":
/*!****************************!*\
  !*** ./type_of_runtime.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jsRuntime\": () => (/* binding */ jsRuntime)\n/* harmony export */ });\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// We only define `cefCallRust` if in CEF, so we can use this for environment detection.\n// This should only be used at the top level `wrf_runtime` file or in test, since we want to keep\n// CEF and WASM code separate for bundle size.\nconst jsRuntime = \"cefCallRust\" in self ? \"cef\" : \"wasm\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90eXBlX29mX3J1bnRpbWUudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3R5cGVfb2ZfcnVudGltZS50cz9kNzJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMS1wcmVzZW50LCBDcnVpc2UgTExDXG4vL1xuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UtQVBBQ0hFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBXZSBvbmx5IGRlZmluZSBgY2VmQ2FsbFJ1c3RgIGlmIGluIENFRiwgc28gd2UgY2FuIHVzZSB0aGlzIGZvciBlbnZpcm9ubWVudCBkZXRlY3Rpb24uXG4vLyBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgYXQgdGhlIHRvcCBsZXZlbCBgd3JmX3J1bnRpbWVgIGZpbGUgb3IgaW4gdGVzdCwgc2luY2Ugd2Ugd2FudCB0byBrZWVwXG4vLyBDRUYgYW5kIFdBU00gY29kZSBzZXBhcmF0ZSBmb3IgYnVuZGxlIHNpemUuXG5leHBvcnQgY29uc3QganNSdW50aW1lID0gXCJjZWZDYWxsUnVzdFwiIGluIHNlbGYgPyBcImNlZlwiIDogXCJ3YXNtXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./type_of_runtime.ts\n");

/***/ }),

/***/ "./types.ts":
/*!******************!*\
  !*** ./types.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WrfParamType\": () => (/* binding */ WrfParamType)\n/* harmony export */ });\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Keep in sync with `param.rs`\nvar WrfParamType;\n(function (WrfParamType) {\n    WrfParamType[WrfParamType[\"String\"] = 0] = \"String\";\n    WrfParamType[WrfParamType[\"ReadOnlyU8Buffer\"] = 1] = \"ReadOnlyU8Buffer\";\n    WrfParamType[WrfParamType[\"U8Buffer\"] = 2] = \"U8Buffer\";\n    WrfParamType[WrfParamType[\"F32Buffer\"] = 3] = \"F32Buffer\";\n    WrfParamType[WrfParamType[\"ReadOnlyF32Buffer\"] = 4] = \"ReadOnlyF32Buffer\";\n})(WrfParamType || (WrfParamType = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90eXBlcy50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3R5cGVzLnRzPzVmNTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIEtlZXAgaW4gc3luYyB3aXRoIGBwYXJhbS5yc2BcbmV4cG9ydCB2YXIgV3JmUGFyYW1UeXBlO1xuKGZ1bmN0aW9uIChXcmZQYXJhbVR5cGUpIHtcbiAgICBXcmZQYXJhbVR5cGVbV3JmUGFyYW1UeXBlW1wiU3RyaW5nXCJdID0gMF0gPSBcIlN0cmluZ1wiO1xuICAgIFdyZlBhcmFtVHlwZVtXcmZQYXJhbVR5cGVbXCJSZWFkT25seVU4QnVmZmVyXCJdID0gMV0gPSBcIlJlYWRPbmx5VThCdWZmZXJcIjtcbiAgICBXcmZQYXJhbVR5cGVbV3JmUGFyYW1UeXBlW1wiVThCdWZmZXJcIl0gPSAyXSA9IFwiVThCdWZmZXJcIjtcbiAgICBXcmZQYXJhbVR5cGVbV3JmUGFyYW1UeXBlW1wiRjMyQnVmZmVyXCJdID0gM10gPSBcIkYzMkJ1ZmZlclwiO1xuICAgIFdyZlBhcmFtVHlwZVtXcmZQYXJhbVR5cGVbXCJSZWFkT25seUYzMkJ1ZmZlclwiXSA9IDRdID0gXCJSZWFkT25seUYzMkJ1ZmZlclwiO1xufSkoV3JmUGFyYW1UeXBlIHx8IChXcmZQYXJhbVR5cGUgPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./types.ts\n");

/***/ }),

/***/ "./wrf_buffer.ts":
/*!***********************!*\
  !*** ./wrf_buffer.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WrfBuffer\": () => (/* binding */ WrfBuffer),\n/* harmony export */   \"classesToExtend\": () => (/* binding */ classesToExtend),\n/* harmony export */   \"containsWrfBuffer\": () => (/* binding */ containsWrfBuffer),\n/* harmony export */   \"overwriteTypedArraysWithWrfArrays\": () => (/* binding */ overwriteTypedArraysWithWrfArrays),\n/* harmony export */   \"getCachedWrfBuffer\": () => (/* binding */ getCachedWrfBuffer),\n/* harmony export */   \"isWrfBuffer\": () => (/* binding */ isWrfBuffer),\n/* harmony export */   \"checkValidWrfArray\": () => (/* binding */ checkValidWrfArray),\n/* harmony export */   \"allocatedArcs\": () => (/* binding */ allocatedArcs),\n/* harmony export */   \"allocatedVecs\": () => (/* binding */ allocatedVecs),\n/* harmony export */   \"getWrfBufferWasm\": () => (/* binding */ getWrfBufferWasm),\n/* harmony export */   \"unregisterMutableBuffer\": () => (/* binding */ unregisterMutableBuffer),\n/* harmony export */   \"getWrfBufferCef\": () => (/* binding */ getWrfBufferCef)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n/* harmony import */ var _wrf_test__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrf_test */ \"./wrf_test.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Wrapper around SharedArrayBuffer to encapsulate ownership of particular segments of it\n\n\n\n// TODO(Paras) - Make sure we monkeypatch on web workers as well\nclass WrfBuffer extends SharedArrayBuffer {\n    constructor(buffer, bufferData) {\n        super(0);\n        this.__wrflibWasmBuffer = buffer;\n        this.__wrflibBufferData = bufferData;\n    }\n    // TODO(Paras): Actually enforce this flag and prevent mutation of WrfArrays marked as readonly.\n    // Potentially, we can do this by hashing read only buffer data and periodically checking in debug\n    // builds if they have been modified/raising errors.\n    get readonly() {\n        return this.__wrflibBufferData.readonly;\n    }\n    // The only 2 methods on SharedArrayBuffer class to override:\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#instance_properties\n    get byteLength() {\n        return this.__wrflibWasmBuffer.byteLength;\n    }\n    slice(...args) {\n        return this.__wrflibWasmBuffer.slice(...args);\n    }\n}\n// This class is a drop-in replacement for all typed arrays\n// It uses WrfBuffer as a handle for underlying buffer as the object that keeps underlying data around\n// Requirements:\n//  * The underlying typed array behaves like it was created over the original view\n//  * When the new typed array (potentially with different class name) is created from the buffer of the original one,\n//  they share the same handle\n//\n// The Rust side assumes that underlying data buffer is immutable,\n// however it still could be accidentally modified on JS side leading to weird behavior\n// TODO(Dmitry): Throw an error if there is mutation of the data\nfunction wrfBufferExtends(cls) {\n    return class WrfTypedArray extends cls {\n        constructor(...args) {\n            const buffer = args[0];\n            if (typeof buffer === \"object\" && buffer instanceof WrfBuffer) {\n                // Fill in byteOffset if that's omitted.\n                if (args.length < 2) {\n                    args[1] = buffer.__wrflibBufferData.bufferPtr;\n                }\n                // Fill in length (in elements, not in bytes) if that's omitted.\n                if (args.length < 3) {\n                    args[2] = Math.floor((buffer.__wrflibBufferData.bufferPtr +\n                        buffer.__wrflibBufferData.bufferLen -\n                        args[1]) /\n                        cls.BYTES_PER_ELEMENT);\n                }\n                if (args[1] < buffer.__wrflibBufferData.bufferPtr) {\n                    throw new Error(`Byte_offset ${args[1]} is out of bounds`);\n                }\n                if (args[1] + args[2] * cls.BYTES_PER_ELEMENT >\n                    buffer.__wrflibBufferData.bufferPtr +\n                        buffer.__wrflibBufferData.bufferLen) {\n                    throw new Error(`Byte_offset ${args[1]} + length ${args[2]} is out of bounds`);\n                }\n                // Whenever we create WrfUintArray using WrfBuffer as first argument\n                // pass the underlying full wasm_buffer further\n                args[0] = buffer.__wrflibWasmBuffer;\n                super(...args);\n                this.__wrflibBuffer = buffer;\n            }\n            else {\n                super(...args);\n            }\n        }\n        get buffer() {\n            return this.__wrflibBuffer || super.buffer;\n        }\n        subarray(begin = 0, end = this.length) {\n            if (begin < 0) {\n                begin = this.length + begin;\n            }\n            if (end < 0) {\n                end = this.length + end;\n            }\n            if (end < begin) {\n                end = begin;\n            }\n            return new WrfTypedArray(this.buffer, this.byteOffset + begin * this.BYTES_PER_ELEMENT, end - begin);\n        }\n    };\n}\n// Extending all typed arrays\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#indexed_collections\nconst classesToExtend = {\n    Int8Array: \"WrfInt8Array\",\n    Uint8Array: \"WrfUint8Array\",\n    Uint8ClampedArray: \"WrfUint8ClampedArray\",\n    Int16Array: \"WrfInt16Array\",\n    Uint16Array: \"WrfUint16Array\",\n    Uint16ClampedArray: \"WrfUint16ClampedArray\",\n    Int32Array: \"WrfInt32Array\",\n    Uint32Array: \"WrfUint32Array\",\n    Float32Array: \"WrfFloat32Array\",\n    Float64Array: \"WrfFloat64Array\",\n    BigInt64Array: \"WrfBigInt64Array\",\n    BigUint64Array: \"WrfBigUint64Array\",\n    DataView: \"WrfDataView\",\n};\nfor (const [cls, wrfCls] of Object.entries(classesToExtend)) {\n    // Get a new type name by prefixing old one with \"Wrf\".\n    // e.g. Uint8Array is extended by WrfUint8Array, etc\n    if (cls in self) {\n        // @ts-ignore\n        self[wrfCls] = wrfBufferExtends(self[cls]);\n    }\n}\n// Checks if the given object itself or recursively contains WrfBuffers.\n// Exported for tests.\nfunction containsWrfBuffer(object) {\n    if (typeof object != \"object\" || object === null) {\n        return false;\n    }\n    if (Object.prototype.hasOwnProperty.call(object, \"__wrflibBuffer\")) {\n        return true;\n    }\n    // Only supporting nesting for arrays, plain objects, maps and sets similar to StructuredClone algorithm\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types\n    if (Array.isArray(object) || object instanceof Set || object instanceof Map) {\n        for (const entry of object) {\n            if (containsWrfBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    else if (Object.getPrototypeOf(object) === Object.getPrototypeOf({})) {\n        for (const entry of Object.entries(object)) {\n            if (containsWrfBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction patchPostMessage(cls) {\n    const origPostMessage = cls.postMessage;\n    // Explicitly NOT a fat arrow (=>) since we want to keep the original `this`.\n    cls.postMessage = function (...args) {\n        if (containsWrfBuffer(args[0])) {\n            // TODO(Dmitry): add a better error message showing the exact location of typed arrays\n            throw new Error(\"Sending WrfBuffers to/from workers is not supported - \" +\n                \"use .slice() on typed array instead to make an explicit copy\");\n        }\n        origPostMessage.apply(this, args);\n    };\n}\nfunction overwriteTypedArraysWithWrfArrays() {\n    for (const [cls, wrfCls] of Object.entries(classesToExtend)) {\n        if (cls in self) {\n            // @ts-ignore\n            self[cls] = self[wrfCls];\n        }\n    }\n    patchPostMessage(self);\n    patchPostMessage(self.Worker);\n    patchPostMessage(self.MessagePort);\n}\nconst wrfBufferCache = new WeakMap();\nfunction getCachedWrfBuffer(wrfBuffer, fallbackArray) {\n    var _a;\n    if (!(\n    // Overwrite the cached value if we return a pointer to a buffer of a different type\n    // For example, Rust code may cast a float to an u8 and return the same buffer pointer.\n    (((_a = wrfBufferCache.get(wrfBuffer)) === null || _a === void 0 ? void 0 : _a.BYTES_PER_ELEMENT) ===\n        fallbackArray.BYTES_PER_ELEMENT))) {\n        wrfBufferCache.set(wrfBuffer, fallbackArray);\n    }\n    return wrfBufferCache.get(wrfBuffer);\n}\nfunction isWrfBuffer(potentialWrfBuffer) {\n    return (typeof potentialWrfBuffer === \"object\" &&\n        potentialWrfBuffer instanceof WrfBuffer);\n}\nfunction checkValidWrfArray(wrfArray) {\n    if (!isWrfBuffer(wrfArray.buffer)) {\n        throw new Error(\"wrfArray.buffer is not a WrfBuffer in checkValidWrfArray\");\n    }\n    const buffer = wrfArray.buffer;\n    const bufferCoversWrfBuffer = wrfArray.byteOffset === buffer.__wrflibBufferData.bufferPtr &&\n        wrfArray.byteLength === buffer.__wrflibBufferData.bufferLen;\n    if (!bufferCoversWrfBuffer) {\n        throw new Error(\"Called Rust with a buffer that does not span the entire underlying WrfBuffer\");\n    }\n    const paramType = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(wrfArray, buffer.readonly);\n    if (paramType !== buffer.__wrflibBufferData.paramType) {\n        throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${_types__WEBPACK_IMPORTED_MODULE_1__.WrfParamType[buffer.__wrflibBufferData.paramType]} but got ${_types__WEBPACK_IMPORTED_MODULE_1__.WrfParamType[paramType]}`);\n    }\n}\n// Cache WrfBuffers so that we have a stable identity for WrfBuffers pointing to the same\n// Arc. This is useful for any downstream caches in user code.\nconst bufferCache = {};\nconst allocatedArcs = {};\nconst allocatedVecs = {};\nconst bufferRegistry = new FinalizationRegistry(({ arcPtr, destructor, }) => {\n    if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n        if (allocatedArcs[arcPtr] === false) {\n            throw new Error(`Deallocating an already deallocated arcPtr ${arcPtr}`);\n        }\n        else if (allocatedArcs[arcPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated arcPtr ${arcPtr}`);\n        }\n        allocatedArcs[arcPtr] = false;\n    }\n    delete bufferCache[arcPtr];\n    if (destructor)\n        destructor(arcPtr);\n});\nconst mutableWrfBufferRegistry = new FinalizationRegistry(({ bufferData, destructor, }) => {\n    if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n        const { bufferPtr } = bufferData;\n        if (allocatedVecs[bufferPtr] === false) {\n            throw new Error(`Deallocating an already deallocated bufferPtr ${bufferPtr}`);\n        }\n        else if (allocatedVecs[bufferPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated bufferPtr ${bufferPtr}`);\n        }\n        allocatedVecs[bufferPtr] = false;\n    }\n    destructor(bufferData);\n});\n// Return a buffer with a stable identity based on arcPtr.\n// Register callbacks so we de-allocate the buffer when it goes out of scope.\nconst getWrfBufferWasm = (wasmMemory, bufferData, destructor, mutableDestructor) => {\n    var _a;\n    if (bufferData.readonly) {\n        if (!((_a = bufferCache[bufferData.arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n                allocatedArcs[bufferData.arcPtr] = true;\n            }\n            const wrfBuffer = new WrfBuffer(wasmMemory.buffer, bufferData);\n            bufferRegistry.register(wrfBuffer, {\n                arcPtr: bufferData.arcPtr,\n                destructor,\n                /* no unregisterToken here since we never need to unregister */\n            });\n            bufferCache[bufferData.arcPtr] = new WeakRef(wrfBuffer);\n        }\n        else {\n            // If we already hold a reference, decrement the Arc we were just given;\n            // otherwise we leak memory.\n            destructor(bufferData.arcPtr);\n        }\n        return bufferCache[bufferData.arcPtr].deref();\n    }\n    else {\n        if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n            allocatedVecs[bufferData.bufferPtr] = true;\n        }\n        const wrfBuffer = new WrfBuffer(wasmMemory.buffer, bufferData);\n        mutableWrfBufferRegistry.register(wrfBuffer, {\n            bufferData,\n            destructor: mutableDestructor,\n        }, wrfBuffer);\n        return wrfBuffer;\n    }\n};\n// Remove mutable WrfBuffers without running destructors. This is useful\n// when transferring ownership of buffers to Rust without deallocating data.\nconst unregisterMutableBuffer = (wrfBuffer) => {\n    if (wrfBuffer.readonly) {\n        throw new Error(\"`unregisterMutableBuffer` should only be called on mutable WrfBuffers\");\n    }\n    mutableWrfBufferRegistry.unregister(wrfBuffer);\n    if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n        allocatedVecs[wrfBuffer.__wrflibBufferData.bufferPtr] = false;\n    }\n};\n// Return a buffer with a stable identity based on arcPtr\nconst getWrfBufferCef = (buffer, arcPtr, paramType) => {\n    var _a;\n    if (arcPtr) {\n        if (!((_a = bufferCache[arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            const wrfBuffer = new WrfBuffer(buffer, {\n                bufferPtr: 0,\n                bufferLen: buffer.byteLength,\n                readonly: true,\n                paramType,\n                // TODO(Paras): These fields below do not apply to CEF\n                arcPtr: -1,\n            });\n            bufferRegistry.register(wrfBuffer, { arcPtr });\n            bufferCache[arcPtr] = new WeakRef(wrfBuffer);\n        }\n        return bufferCache[arcPtr].deref();\n    }\n    else {\n        return new WrfBuffer(buffer, {\n            bufferPtr: 0,\n            bufferLen: buffer.byteLength,\n            bufferCap: buffer.byteLength,\n            paramType,\n            readonly: false,\n        });\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfYnVmZmVyLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cmYvLi93cmZfYnVmZmVyLnRzP2JiMGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFdyYXBwZXIgYXJvdW5kIFNoYXJlZEFycmF5QnVmZmVyIHRvIGVuY2Fwc3VsYXRlIG93bmVyc2hpcCBvZiBwYXJ0aWN1bGFyIHNlZ21lbnRzIG9mIGl0XG5pbXBvcnQgeyBnZXRXcmZQYXJhbVR5cGUgfSBmcm9tIFwiLi9jb21tb25cIjtcbmltcG9ydCB7IFdyZlBhcmFtVHlwZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBpblRlc3QgfSBmcm9tIFwiLi93cmZfdGVzdFwiO1xuLy8gVE9ETyhQYXJhcykgLSBNYWtlIHN1cmUgd2UgbW9ua2V5cGF0Y2ggb24gd2ViIHdvcmtlcnMgYXMgd2VsbFxuZXhwb3J0IGNsYXNzIFdyZkJ1ZmZlciBleHRlbmRzIFNoYXJlZEFycmF5QnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGJ1ZmZlckRhdGEpIHtcbiAgICAgICAgc3VwZXIoMCk7XG4gICAgICAgIHRoaXMuX193cmZsaWJXYXNtQnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLl9fd3JmbGliQnVmZmVyRGF0YSA9IGJ1ZmZlckRhdGE7XG4gICAgfVxuICAgIC8vIFRPRE8oUGFyYXMpOiBBY3R1YWxseSBlbmZvcmNlIHRoaXMgZmxhZyBhbmQgcHJldmVudCBtdXRhdGlvbiBvZiBXcmZBcnJheXMgbWFya2VkIGFzIHJlYWRvbmx5LlxuICAgIC8vIFBvdGVudGlhbGx5LCB3ZSBjYW4gZG8gdGhpcyBieSBoYXNoaW5nIHJlYWQgb25seSBidWZmZXIgZGF0YSBhbmQgcGVyaW9kaWNhbGx5IGNoZWNraW5nIGluIGRlYnVnXG4gICAgLy8gYnVpbGRzIGlmIHRoZXkgaGF2ZSBiZWVuIG1vZGlmaWVkL3JhaXNpbmcgZXJyb3JzLlxuICAgIGdldCByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJCdWZmZXJEYXRhLnJlYWRvbmx5O1xuICAgIH1cbiAgICAvLyBUaGUgb25seSAyIG1ldGhvZHMgb24gU2hhcmVkQXJyYXlCdWZmZXIgY2xhc3MgdG8gb3ZlcnJpZGU6XG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1NoYXJlZEFycmF5QnVmZmVyI2luc3RhbmNlX3Byb3BlcnRpZXNcbiAgICBnZXQgYnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJXYXNtQnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHNsaWNlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJXYXNtQnVmZmVyLnNsaWNlKC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8vIFRoaXMgY2xhc3MgaXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciBhbGwgdHlwZWQgYXJyYXlzXG4vLyBJdCB1c2VzIFdyZkJ1ZmZlciBhcyBhIGhhbmRsZSBmb3IgdW5kZXJseWluZyBidWZmZXIgYXMgdGhlIG9iamVjdCB0aGF0IGtlZXBzIHVuZGVybHlpbmcgZGF0YSBhcm91bmRcbi8vIFJlcXVpcmVtZW50czpcbi8vICAqIFRoZSB1bmRlcmx5aW5nIHR5cGVkIGFycmF5IGJlaGF2ZXMgbGlrZSBpdCB3YXMgY3JlYXRlZCBvdmVyIHRoZSBvcmlnaW5hbCB2aWV3XG4vLyAgKiBXaGVuIHRoZSBuZXcgdHlwZWQgYXJyYXkgKHBvdGVudGlhbGx5IHdpdGggZGlmZmVyZW50IGNsYXNzIG5hbWUpIGlzIGNyZWF0ZWQgZnJvbSB0aGUgYnVmZmVyIG9mIHRoZSBvcmlnaW5hbCBvbmUsXG4vLyAgdGhleSBzaGFyZSB0aGUgc2FtZSBoYW5kbGVcbi8vXG4vLyBUaGUgUnVzdCBzaWRlIGFzc3VtZXMgdGhhdCB1bmRlcmx5aW5nIGRhdGEgYnVmZmVyIGlzIGltbXV0YWJsZSxcbi8vIGhvd2V2ZXIgaXQgc3RpbGwgY291bGQgYmUgYWNjaWRlbnRhbGx5IG1vZGlmaWVkIG9uIEpTIHNpZGUgbGVhZGluZyB0byB3ZWlyZCBiZWhhdmlvclxuLy8gVE9ETyhEbWl0cnkpOiBUaHJvdyBhbiBlcnJvciBpZiB0aGVyZSBpcyBtdXRhdGlvbiBvZiB0aGUgZGF0YVxuZnVuY3Rpb24gd3JmQnVmZmVyRXh0ZW5kcyhjbHMpIHtcbiAgICByZXR1cm4gY2xhc3MgV3JmVHlwZWRBcnJheSBleHRlbmRzIGNscyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gXCJvYmplY3RcIiAmJiBidWZmZXIgaW5zdGFuY2VvZiBXcmZCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIGluIGJ5dGVPZmZzZXQgaWYgdGhhdCdzIG9taXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICBhcmdzWzFdID0gYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5idWZmZXJQdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbGwgaW4gbGVuZ3RoIChpbiBlbGVtZW50cywgbm90IGluIGJ5dGVzKSBpZiB0aGF0J3Mgb21pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMl0gPSBNYXRoLmZsb29yKChidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlclB0ciArXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlckxlbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzFdKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJnc1sxXSA8IGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQnl0ZV9vZmZzZXQgJHthcmdzWzFdfSBpcyBvdXQgb2YgYm91bmRzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzFdICsgYXJnc1syXSAqIGNscy5CWVRFU19QRVJfRUxFTUVOVCA+XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQnl0ZV9vZmZzZXQgJHthcmdzWzFdfSArIGxlbmd0aCAke2FyZ3NbMl19IGlzIG91dCBvZiBib3VuZHNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbmV2ZXIgd2UgY3JlYXRlIFdyZlVpbnRBcnJheSB1c2luZyBXcmZCdWZmZXIgYXMgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAvLyBwYXNzIHRoZSB1bmRlcmx5aW5nIGZ1bGwgd2FzbV9idWZmZXIgZnVydGhlclxuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBidWZmZXIuX193cmZsaWJXYXNtQnVmZmVyO1xuICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX193cmZsaWJCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgYnVmZmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJCdWZmZXIgfHwgc3VwZXIuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHN1YmFycmF5KGJlZ2luID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDApIHtcbiAgICAgICAgICAgICAgICBiZWdpbiA9IHRoaXMubGVuZ3RoICsgYmVnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoICsgZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA8IGJlZ2luKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gYmVnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyZlR5cGVkQXJyYXkodGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIGJlZ2luICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVCwgZW5kIC0gYmVnaW4pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIEV4dGVuZGluZyBhbGwgdHlwZWQgYXJyYXlzXG4vLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMjaW5kZXhlZF9jb2xsZWN0aW9uc1xuZXhwb3J0IGNvbnN0IGNsYXNzZXNUb0V4dGVuZCA9IHtcbiAgICBJbnQ4QXJyYXk6IFwiV3JmSW50OEFycmF5XCIsXG4gICAgVWludDhBcnJheTogXCJXcmZVaW50OEFycmF5XCIsXG4gICAgVWludDhDbGFtcGVkQXJyYXk6IFwiV3JmVWludDhDbGFtcGVkQXJyYXlcIixcbiAgICBJbnQxNkFycmF5OiBcIldyZkludDE2QXJyYXlcIixcbiAgICBVaW50MTZBcnJheTogXCJXcmZVaW50MTZBcnJheVwiLFxuICAgIFVpbnQxNkNsYW1wZWRBcnJheTogXCJXcmZVaW50MTZDbGFtcGVkQXJyYXlcIixcbiAgICBJbnQzMkFycmF5OiBcIldyZkludDMyQXJyYXlcIixcbiAgICBVaW50MzJBcnJheTogXCJXcmZVaW50MzJBcnJheVwiLFxuICAgIEZsb2F0MzJBcnJheTogXCJXcmZGbG9hdDMyQXJyYXlcIixcbiAgICBGbG9hdDY0QXJyYXk6IFwiV3JmRmxvYXQ2NEFycmF5XCIsXG4gICAgQmlnSW50NjRBcnJheTogXCJXcmZCaWdJbnQ2NEFycmF5XCIsXG4gICAgQmlnVWludDY0QXJyYXk6IFwiV3JmQmlnVWludDY0QXJyYXlcIixcbiAgICBEYXRhVmlldzogXCJXcmZEYXRhVmlld1wiLFxufTtcbmZvciAoY29uc3QgW2Nscywgd3JmQ2xzXSBvZiBPYmplY3QuZW50cmllcyhjbGFzc2VzVG9FeHRlbmQpKSB7XG4gICAgLy8gR2V0IGEgbmV3IHR5cGUgbmFtZSBieSBwcmVmaXhpbmcgb2xkIG9uZSB3aXRoIFwiV3JmXCIuXG4gICAgLy8gZS5nLiBVaW50OEFycmF5IGlzIGV4dGVuZGVkIGJ5IFdyZlVpbnQ4QXJyYXksIGV0Y1xuICAgIGlmIChjbHMgaW4gc2VsZikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHNlbGZbd3JmQ2xzXSA9IHdyZkJ1ZmZlckV4dGVuZHMoc2VsZltjbHNdKTtcbiAgICB9XG59XG4vLyBDaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBpdHNlbGYgb3IgcmVjdXJzaXZlbHkgY29udGFpbnMgV3JmQnVmZmVycy5cbi8vIEV4cG9ydGVkIGZvciB0ZXN0cy5cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1dyZkJ1ZmZlcihvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPSBcIm9iamVjdFwiIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBcIl9fd3JmbGliQnVmZmVyXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBPbmx5IHN1cHBvcnRpbmcgbmVzdGluZyBmb3IgYXJyYXlzLCBwbGFpbiBvYmplY3RzLCBtYXBzIGFuZCBzZXRzIHNpbWlsYXIgdG8gU3RydWN0dXJlZENsb25lIGFsZ29yaXRobVxuICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1dvcmtlcnNfQVBJL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtI3N1cHBvcnRlZF90eXBlc1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgfHwgb2JqZWN0IGluc3RhbmNlb2YgU2V0IHx8IG9iamVjdCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zV3JmQnVmZmVyKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0KSkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zV3JmQnVmZmVyKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhdGNoUG9zdE1lc3NhZ2UoY2xzKSB7XG4gICAgY29uc3Qgb3JpZ1Bvc3RNZXNzYWdlID0gY2xzLnBvc3RNZXNzYWdlO1xuICAgIC8vIEV4cGxpY2l0bHkgTk9UIGEgZmF0IGFycm93ICg9Pikgc2luY2Ugd2Ugd2FudCB0byBrZWVwIHRoZSBvcmlnaW5hbCBgdGhpc2AuXG4gICAgY2xzLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zV3JmQnVmZmVyKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAvLyBUT0RPKERtaXRyeSk6IGFkZCBhIGJldHRlciBlcnJvciBtZXNzYWdlIHNob3dpbmcgdGhlIGV4YWN0IGxvY2F0aW9uIG9mIHR5cGVkIGFycmF5c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZGluZyBXcmZCdWZmZXJzIHRvL2Zyb20gd29ya2VycyBpcyBub3Qgc3VwcG9ydGVkIC0gXCIgK1xuICAgICAgICAgICAgICAgIFwidXNlIC5zbGljZSgpIG9uIHR5cGVkIGFycmF5IGluc3RlYWQgdG8gbWFrZSBhbiBleHBsaWNpdCBjb3B5XCIpO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdQb3N0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJ3cml0ZVR5cGVkQXJyYXlzV2l0aFdyZkFycmF5cygpIHtcbiAgICBmb3IgKGNvbnN0IFtjbHMsIHdyZkNsc10gb2YgT2JqZWN0LmVudHJpZXMoY2xhc3Nlc1RvRXh0ZW5kKSkge1xuICAgICAgICBpZiAoY2xzIGluIHNlbGYpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHNlbGZbY2xzXSA9IHNlbGZbd3JmQ2xzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRjaFBvc3RNZXNzYWdlKHNlbGYpO1xuICAgIHBhdGNoUG9zdE1lc3NhZ2Uoc2VsZi5Xb3JrZXIpO1xuICAgIHBhdGNoUG9zdE1lc3NhZ2Uoc2VsZi5NZXNzYWdlUG9ydCk7XG59XG5jb25zdCB3cmZCdWZmZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVkV3JmQnVmZmVyKHdyZkJ1ZmZlciwgZmFsbGJhY2tBcnJheSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIShcbiAgICAvLyBPdmVyd3JpdGUgdGhlIGNhY2hlZCB2YWx1ZSBpZiB3ZSByZXR1cm4gYSBwb2ludGVyIHRvIGEgYnVmZmVyIG9mIGEgZGlmZmVyZW50IHR5cGVcbiAgICAvLyBGb3IgZXhhbXBsZSwgUnVzdCBjb2RlIG1heSBjYXN0IGEgZmxvYXQgdG8gYW4gdTggYW5kIHJldHVybiB0aGUgc2FtZSBidWZmZXIgcG9pbnRlci5cbiAgICAoKChfYSA9IHdyZkJ1ZmZlckNhY2hlLmdldCh3cmZCdWZmZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuQllURVNfUEVSX0VMRU1FTlQpID09PVxuICAgICAgICBmYWxsYmFja0FycmF5LkJZVEVTX1BFUl9FTEVNRU5UKSkpIHtcbiAgICAgICAgd3JmQnVmZmVyQ2FjaGUuc2V0KHdyZkJ1ZmZlciwgZmFsbGJhY2tBcnJheSk7XG4gICAgfVxuICAgIHJldHVybiB3cmZCdWZmZXJDYWNoZS5nZXQod3JmQnVmZmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1dyZkJ1ZmZlcihwb3RlbnRpYWxXcmZCdWZmZXIpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwb3RlbnRpYWxXcmZCdWZmZXIgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcG90ZW50aWFsV3JmQnVmZmVyIGluc3RhbmNlb2YgV3JmQnVmZmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZhbGlkV3JmQXJyYXkod3JmQXJyYXkpIHtcbiAgICBpZiAoIWlzV3JmQnVmZmVyKHdyZkFycmF5LmJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3JmQXJyYXkuYnVmZmVyIGlzIG5vdCBhIFdyZkJ1ZmZlciBpbiBjaGVja1ZhbGlkV3JmQXJyYXlcIik7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IHdyZkFycmF5LmJ1ZmZlcjtcbiAgICBjb25zdCBidWZmZXJDb3ZlcnNXcmZCdWZmZXIgPSB3cmZBcnJheS5ieXRlT2Zmc2V0ID09PSBidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlclB0ciAmJlxuICAgICAgICB3cmZBcnJheS5ieXRlTGVuZ3RoID09PSBidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlckxlbjtcbiAgICBpZiAoIWJ1ZmZlckNvdmVyc1dyZkJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgUnVzdCB3aXRoIGEgYnVmZmVyIHRoYXQgZG9lcyBub3Qgc3BhbiB0aGUgZW50aXJlIHVuZGVybHlpbmcgV3JmQnVmZmVyXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbVR5cGUgPSBnZXRXcmZQYXJhbVR5cGUod3JmQXJyYXksIGJ1ZmZlci5yZWFkb25seSk7XG4gICAgaWYgKHBhcmFtVHlwZSAhPT0gYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5wYXJhbVR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY2FsbCBSdXN0IHdpdGggYSBidWZmZXIgd2hpY2ggaGFzIGJlZW4gY2FzdCB0byBhIGRpZmZlcmVudCB0eXBlLiBFeHBlY3RlZCAke1dyZlBhcmFtVHlwZVtidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLnBhcmFtVHlwZV19IGJ1dCBnb3QgJHtXcmZQYXJhbVR5cGVbcGFyYW1UeXBlXX1gKTtcbiAgICB9XG59XG4vLyBDYWNoZSBXcmZCdWZmZXJzIHNvIHRoYXQgd2UgaGF2ZSBhIHN0YWJsZSBpZGVudGl0eSBmb3IgV3JmQnVmZmVycyBwb2ludGluZyB0byB0aGUgc2FtZVxuLy8gQXJjLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYW55IGRvd25zdHJlYW0gY2FjaGVzIGluIHVzZXIgY29kZS5cbmNvbnN0IGJ1ZmZlckNhY2hlID0ge307XG5leHBvcnQgY29uc3QgYWxsb2NhdGVkQXJjcyA9IHt9O1xuZXhwb3J0IGNvbnN0IGFsbG9jYXRlZFZlY3MgPSB7fTtcbmNvbnN0IGJ1ZmZlclJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCh7IGFyY1B0ciwgZGVzdHJ1Y3RvciwgfSkgPT4ge1xuICAgIGlmIChpblRlc3QpIHtcbiAgICAgICAgaWYgKGFsbG9jYXRlZEFyY3NbYXJjUHRyXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVhbGxvY2F0aW5nIGFuIGFscmVhZHkgZGVhbGxvY2F0ZWQgYXJjUHRyICR7YXJjUHRyfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG9jYXRlZEFyY3NbYXJjUHRyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlYWxsb2NhdGluZyBhbiB1bmFsbG9jYXRlZCBhcmNQdHIgJHthcmNQdHJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsb2NhdGVkQXJjc1thcmNQdHJdID0gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSBidWZmZXJDYWNoZVthcmNQdHJdO1xuICAgIGlmIChkZXN0cnVjdG9yKVxuICAgICAgICBkZXN0cnVjdG9yKGFyY1B0cik7XG59KTtcbmNvbnN0IG11dGFibGVXcmZCdWZmZXJSZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoeyBidWZmZXJEYXRhLCBkZXN0cnVjdG9yLCB9KSA9PiB7XG4gICAgaWYgKGluVGVzdCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlclB0ciB9ID0gYnVmZmVyRGF0YTtcbiAgICAgICAgaWYgKGFsbG9jYXRlZFZlY3NbYnVmZmVyUHRyXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVhbGxvY2F0aW5nIGFuIGFscmVhZHkgZGVhbGxvY2F0ZWQgYnVmZmVyUHRyICR7YnVmZmVyUHRyfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG9jYXRlZFZlY3NbYnVmZmVyUHRyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlYWxsb2NhdGluZyBhbiB1bmFsbG9jYXRlZCBidWZmZXJQdHIgJHtidWZmZXJQdHJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsb2NhdGVkVmVjc1tidWZmZXJQdHJdID0gZmFsc2U7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoYnVmZmVyRGF0YSk7XG59KTtcbi8vIFJldHVybiBhIGJ1ZmZlciB3aXRoIGEgc3RhYmxlIGlkZW50aXR5IGJhc2VkIG9uIGFyY1B0ci5cbi8vIFJlZ2lzdGVyIGNhbGxiYWNrcyBzbyB3ZSBkZS1hbGxvY2F0ZSB0aGUgYnVmZmVyIHdoZW4gaXQgZ29lcyBvdXQgb2Ygc2NvcGUuXG5leHBvcnQgY29uc3QgZ2V0V3JmQnVmZmVyV2FzbSA9ICh3YXNtTWVtb3J5LCBidWZmZXJEYXRhLCBkZXN0cnVjdG9yLCBtdXRhYmxlRGVzdHJ1Y3RvcikgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYnVmZmVyRGF0YS5yZWFkb25seSkge1xuICAgICAgICBpZiAoISgoX2EgPSBidWZmZXJDYWNoZVtidWZmZXJEYXRhLmFyY1B0cl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXJlZigpKSkge1xuICAgICAgICAgICAgaWYgKGluVGVzdCkge1xuICAgICAgICAgICAgICAgIGFsbG9jYXRlZEFyY3NbYnVmZmVyRGF0YS5hcmNQdHJdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdyZkJ1ZmZlciA9IG5ldyBXcmZCdWZmZXIod2FzbU1lbW9yeS5idWZmZXIsIGJ1ZmZlckRhdGEpO1xuICAgICAgICAgICAgYnVmZmVyUmVnaXN0cnkucmVnaXN0ZXIod3JmQnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgYXJjUHRyOiBidWZmZXJEYXRhLmFyY1B0cixcbiAgICAgICAgICAgICAgICBkZXN0cnVjdG9yLFxuICAgICAgICAgICAgICAgIC8qIG5vIHVucmVnaXN0ZXJUb2tlbiBoZXJlIHNpbmNlIHdlIG5ldmVyIG5lZWQgdG8gdW5yZWdpc3RlciAqL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBidWZmZXJDYWNoZVtidWZmZXJEYXRhLmFyY1B0cl0gPSBuZXcgV2Vha1JlZih3cmZCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBob2xkIGEgcmVmZXJlbmNlLCBkZWNyZW1lbnQgdGhlIEFyYyB3ZSB3ZXJlIGp1c3QgZ2l2ZW47XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbGVhayBtZW1vcnkuXG4gICAgICAgICAgICBkZXN0cnVjdG9yKGJ1ZmZlckRhdGEuYXJjUHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyQ2FjaGVbYnVmZmVyRGF0YS5hcmNQdHJdLmRlcmVmKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5UZXN0KSB7XG4gICAgICAgICAgICBhbGxvY2F0ZWRWZWNzW2J1ZmZlckRhdGEuYnVmZmVyUHRyXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gbmV3IFdyZkJ1ZmZlcih3YXNtTWVtb3J5LmJ1ZmZlciwgYnVmZmVyRGF0YSk7XG4gICAgICAgIG11dGFibGVXcmZCdWZmZXJSZWdpc3RyeS5yZWdpc3Rlcih3cmZCdWZmZXIsIHtcbiAgICAgICAgICAgIGJ1ZmZlckRhdGEsXG4gICAgICAgICAgICBkZXN0cnVjdG9yOiBtdXRhYmxlRGVzdHJ1Y3RvcixcbiAgICAgICAgfSwgd3JmQnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHdyZkJ1ZmZlcjtcbiAgICB9XG59O1xuLy8gUmVtb3ZlIG11dGFibGUgV3JmQnVmZmVycyB3aXRob3V0IHJ1bm5pbmcgZGVzdHJ1Y3RvcnMuIFRoaXMgaXMgdXNlZnVsXG4vLyB3aGVuIHRyYW5zZmVycmluZyBvd25lcnNoaXAgb2YgYnVmZmVycyB0byBSdXN0IHdpdGhvdXQgZGVhbGxvY2F0aW5nIGRhdGEuXG5leHBvcnQgY29uc3QgdW5yZWdpc3Rlck11dGFibGVCdWZmZXIgPSAod3JmQnVmZmVyKSA9PiB7XG4gICAgaWYgKHdyZkJ1ZmZlci5yZWFkb25seSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdW5yZWdpc3Rlck11dGFibGVCdWZmZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBtdXRhYmxlIFdyZkJ1ZmZlcnNcIik7XG4gICAgfVxuICAgIG11dGFibGVXcmZCdWZmZXJSZWdpc3RyeS51bnJlZ2lzdGVyKHdyZkJ1ZmZlcik7XG4gICAgaWYgKGluVGVzdCkge1xuICAgICAgICBhbGxvY2F0ZWRWZWNzW3dyZkJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyXSA9IGZhbHNlO1xuICAgIH1cbn07XG4vLyBSZXR1cm4gYSBidWZmZXIgd2l0aCBhIHN0YWJsZSBpZGVudGl0eSBiYXNlZCBvbiBhcmNQdHJcbmV4cG9ydCBjb25zdCBnZXRXcmZCdWZmZXJDZWYgPSAoYnVmZmVyLCBhcmNQdHIsIHBhcmFtVHlwZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYXJjUHRyKSB7XG4gICAgICAgIGlmICghKChfYSA9IGJ1ZmZlckNhY2hlW2FyY1B0cl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXJlZigpKSkge1xuICAgICAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gbmV3IFdyZkJ1ZmZlcihidWZmZXIsIHtcbiAgICAgICAgICAgICAgICBidWZmZXJQdHI6IDAsXG4gICAgICAgICAgICAgICAgYnVmZmVyTGVuOiBidWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJhbVR5cGUsXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhQYXJhcyk6IFRoZXNlIGZpZWxkcyBiZWxvdyBkbyBub3QgYXBwbHkgdG8gQ0VGXG4gICAgICAgICAgICAgICAgYXJjUHRyOiAtMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnVmZmVyUmVnaXN0cnkucmVnaXN0ZXIod3JmQnVmZmVyLCB7IGFyY1B0ciB9KTtcbiAgICAgICAgICAgIGJ1ZmZlckNhY2hlW2FyY1B0cl0gPSBuZXcgV2Vha1JlZih3cmZCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXJDYWNoZVthcmNQdHJdLmRlcmVmKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFdyZkJ1ZmZlcihidWZmZXIsIHtcbiAgICAgICAgICAgIGJ1ZmZlclB0cjogMCxcbiAgICAgICAgICAgIGJ1ZmZlckxlbjogYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBidWZmZXJDYXA6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgcGFyYW1UeXBlLFxuICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./wrf_buffer.ts\n");

/***/ }),

/***/ "./wrf_test.ts":
/*!*********************!*\
  !*** ./wrf_test.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"expect\": () => (/* binding */ expect),\n/* harmony export */   \"expectThrow\": () => (/* binding */ expectThrow),\n/* harmony export */   \"expectThrowAsync\": () => (/* binding */ expectThrowAsync),\n/* harmony export */   \"expectDeallocationOrUnregister\": () => (/* binding */ expectDeallocationOrUnregister),\n/* harmony export */   \"inTest\": () => (/* binding */ inTest),\n/* harmony export */   \"setInTest\": () => (/* binding */ setInTest)\n/* harmony export */ });\n/* harmony import */ var _type_of_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type_of_runtime */ \"./type_of_runtime.ts\");\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst expect = (actual, expected) => {\n    if (expected === actual) {\n        console.debug(`Success: Got ${actual}, Expected ${expected}`);\n    }\n    else {\n        throw new Error(`Failure: Got ${actual}, Expected ${expected}`);\n    }\n};\n// TODO(Paras): Would be nice to combine the two functions below at some point.\nconst expectThrow = (f, expectedMessage) => {\n    let error;\n    try {\n        f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n};\nconst expectThrowAsync = (f, expectedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n    let error;\n    try {\n        yield f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n});\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst checkConditionTimeout = (condition, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n    const startTime = performance.now();\n    while (!condition() && performance.now() < startTime + timeout) {\n        yield sleep(10);\n    }\n    return condition();\n});\n// Generate some dummy data and then delete it. This usually triggers the garbage collector.\nconst generateGarbage = () => {\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        self[\"garbage_\" + i] = { i };\n    }\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        delete self[\"garbage_\" + i];\n    }\n};\nconst arcAllocated = (callRust, buffer) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!buffer.__wrflibBufferData.readonly)\n        throw new Error(\"arcAllocated called on mutable buffer\");\n    const arcPtr = buffer.__wrflibBufferData.arcPtr;\n    // We still have the buffer here! So it should still be allocated.\n    expect(_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedArcs[arcPtr], true);\n    const [result] = yield callRust(\"check_arc_count\", [`${BigInt(arcPtr)}`]);\n    const [countBeforeDeallocation] = result;\n    expect(countBeforeDeallocation, 1);\n    return arcPtr;\n});\nconst arcDeallocated = (arcPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // From here on out we don't refer to `buffer` any more, so it should get\n    // deallocated, if the garbage collector is any good.\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedArcs[arcPtr] === false;\n    }, 20000), true);\n});\nconst vecDeallocated = (bufferPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // Even though we have the buffer, it might have already been unregistered\n    // when passed to Rust. We shouldn't read/write to it any more. If this is the\n    // case, let's just bail.\n    if (!_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedVecs[bufferPtr])\n        return;\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedVecs[bufferPtr] === false;\n    }, 20000), true);\n});\n// Test that WrfBuffers were deallocated at some point in the next 20 seconds.\n// This is a bit brittle given that there are no guarantees for garbage collection during this time,\n// but observationally this ends up being enough time. The caller must also ensure that the buffer will go out of scope\n// shortly after calling this.\n// We have to pass in `callRust` because we can call this function from a variety of runtimes.\n// Note that assertions on garbage collection are extremely sensitive to exactly how these functions are written,\n// and can easily break if you restucture the function, use a different/newer browser, etc!\nconst expectDeallocationOrUnregister = (callRust, wrfArray) => {\n    // Deallocation code is only run in WASM for now.\n    if (_type_of_runtime__WEBPACK_IMPORTED_MODULE_0__.jsRuntime === \"cef\")\n        return Promise.resolve();\n    const buffer = wrfArray.buffer;\n    return buffer.readonly\n        ? arcAllocated(callRust, buffer).then((arcPtr) => arcDeallocated(arcPtr))\n        : vecDeallocated(buffer.__wrflibBufferData.bufferPtr);\n};\nlet inTest = false;\n// Set this to true to enable testing code\nconst setInTest = (v) => {\n    inTest = v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfdGVzdC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vd3JmX3Rlc3QudHM/MzI5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjEtcHJlc2VudCwgQ3J1aXNlIExMQ1xuLy9cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCxcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFLUFQQUNIRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBqc1J1bnRpbWUgfSBmcm9tIFwiLi90eXBlX29mX3J1bnRpbWVcIjtcbmltcG9ydCB7IGFsbG9jYXRlZEFyY3MsIGFsbG9jYXRlZFZlY3MgfSBmcm9tIFwiLi93cmZfYnVmZmVyXCI7XG5leHBvcnQgY29uc3QgZXhwZWN0ID0gKGFjdHVhbCwgZXhwZWN0ZWQpID0+IHtcbiAgICBpZiAoZXhwZWN0ZWQgPT09IGFjdHVhbCkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKGBTdWNjZXNzOiBHb3QgJHthY3R1YWx9LCBFeHBlY3RlZCAke2V4cGVjdGVkfWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsdXJlOiBHb3QgJHthY3R1YWx9LCBFeHBlY3RlZCAke2V4cGVjdGVkfWApO1xuICAgIH1cbn07XG4vLyBUT0RPKFBhcmFzKTogV291bGQgYmUgbmljZSB0byBjb21iaW5lIHRoZSB0d28gZnVuY3Rpb25zIGJlbG93IGF0IHNvbWUgcG9pbnQuXG5leHBvcnQgY29uc3QgZXhwZWN0VGhyb3cgPSAoZiwgZXhwZWN0ZWRNZXNzYWdlKSA9PiB7XG4gICAgbGV0IGVycm9yO1xuICAgIHRyeSB7XG4gICAgICAgIGYoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgIH1cbiAgICBleHBlY3QoISFlcnJvciwgdHJ1ZSk7XG4gICAgaWYgKGVycm9yICYmIGV4cGVjdGVkTWVzc2FnZSkge1xuICAgICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSwgZXhwZWN0ZWRNZXNzYWdlKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGV4cGVjdFRocm93QXN5bmMgPSAoZiwgZXhwZWN0ZWRNZXNzYWdlKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgICAgeWllbGQgZigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvciA9IGU7XG4gICAgfVxuICAgIGV4cGVjdCghIWVycm9yLCB0cnVlKTtcbiAgICBpZiAoZXJyb3IgJiYgZXhwZWN0ZWRNZXNzYWdlKSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlLCBleHBlY3RlZE1lc3NhZ2UpO1xuICAgIH1cbn0pO1xuY29uc3Qgc2xlZXAgPSAobXMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5jb25zdCBjaGVja0NvbmRpdGlvblRpbWVvdXQgPSAoY29uZGl0aW9uLCB0aW1lb3V0KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB3aGlsZSAoIWNvbmRpdGlvbigpICYmIHBlcmZvcm1hbmNlLm5vdygpIDwgc3RhcnRUaW1lICsgdGltZW91dCkge1xuICAgICAgICB5aWVsZCBzbGVlcCgxMCk7XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb24oKTtcbn0pO1xuLy8gR2VuZXJhdGUgc29tZSBkdW1teSBkYXRhIGFuZCB0aGVuIGRlbGV0ZSBpdC4gVGhpcyB1c3VhbGx5IHRyaWdnZXJzIHRoZSBnYXJiYWdlIGNvbGxlY3Rvci5cbmNvbnN0IGdlbmVyYXRlR2FyYmFnZSA9ICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDAwOyBpKyspIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzZWxmW1wiZ2FyYmFnZV9cIiArIGldID0geyBpIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDA7IGkrKykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGV0ZSBzZWxmW1wiZ2FyYmFnZV9cIiArIGldO1xuICAgIH1cbn07XG5jb25zdCBhcmNBbGxvY2F0ZWQgPSAoY2FsbFJ1c3QsIGJ1ZmZlcikgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKCFidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLnJlYWRvbmx5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcmNBbGxvY2F0ZWQgY2FsbGVkIG9uIG11dGFibGUgYnVmZmVyXCIpO1xuICAgIGNvbnN0IGFyY1B0ciA9IGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYXJjUHRyO1xuICAgIC8vIFdlIHN0aWxsIGhhdmUgdGhlIGJ1ZmZlciBoZXJlISBTbyBpdCBzaG91bGQgc3RpbGwgYmUgYWxsb2NhdGVkLlxuICAgIGV4cGVjdChhbGxvY2F0ZWRBcmNzW2FyY1B0cl0sIHRydWUpO1xuICAgIGNvbnN0IFtyZXN1bHRdID0geWllbGQgY2FsbFJ1c3QoXCJjaGVja19hcmNfY291bnRcIiwgW2Ake0JpZ0ludChhcmNQdHIpfWBdKTtcbiAgICBjb25zdCBbY291bnRCZWZvcmVEZWFsbG9jYXRpb25dID0gcmVzdWx0O1xuICAgIGV4cGVjdChjb3VudEJlZm9yZURlYWxsb2NhdGlvbiwgMSk7XG4gICAgcmV0dXJuIGFyY1B0cjtcbn0pO1xuY29uc3QgYXJjRGVhbGxvY2F0ZWQgPSAoYXJjUHRyKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAvLyBGcm9tIGhlcmUgb24gb3V0IHdlIGRvbid0IHJlZmVyIHRvIGBidWZmZXJgIGFueSBtb3JlLCBzbyBpdCBzaG91bGQgZ2V0XG4gICAgLy8gZGVhbGxvY2F0ZWQsIGlmIHRoZSBnYXJiYWdlIGNvbGxlY3RvciBpcyBhbnkgZ29vZC5cbiAgICBleHBlY3QoeWllbGQgY2hlY2tDb25kaXRpb25UaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGVHYXJiYWdlKCk7XG4gICAgICAgIHJldHVybiBhbGxvY2F0ZWRBcmNzW2FyY1B0cl0gPT09IGZhbHNlO1xuICAgIH0sIDIwMDAwKSwgdHJ1ZSk7XG59KTtcbmNvbnN0IHZlY0RlYWxsb2NhdGVkID0gKGJ1ZmZlclB0cikgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgLy8gRXZlbiB0aG91Z2ggd2UgaGF2ZSB0aGUgYnVmZmVyLCBpdCBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiB1bnJlZ2lzdGVyZWRcbiAgICAvLyB3aGVuIHBhc3NlZCB0byBSdXN0LiBXZSBzaG91bGRuJ3QgcmVhZC93cml0ZSB0byBpdCBhbnkgbW9yZS4gSWYgdGhpcyBpcyB0aGVcbiAgICAvLyBjYXNlLCBsZXQncyBqdXN0IGJhaWwuXG4gICAgaWYgKCFhbGxvY2F0ZWRWZWNzW2J1ZmZlclB0cl0pXG4gICAgICAgIHJldHVybjtcbiAgICBleHBlY3QoeWllbGQgY2hlY2tDb25kaXRpb25UaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGVHYXJiYWdlKCk7XG4gICAgICAgIHJldHVybiBhbGxvY2F0ZWRWZWNzW2J1ZmZlclB0cl0gPT09IGZhbHNlO1xuICAgIH0sIDIwMDAwKSwgdHJ1ZSk7XG59KTtcbi8vIFRlc3QgdGhhdCBXcmZCdWZmZXJzIHdlcmUgZGVhbGxvY2F0ZWQgYXQgc29tZSBwb2ludCBpbiB0aGUgbmV4dCAyMCBzZWNvbmRzLlxuLy8gVGhpcyBpcyBhIGJpdCBicml0dGxlIGdpdmVuIHRoYXQgdGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBkdXJpbmcgdGhpcyB0aW1lLFxuLy8gYnV0IG9ic2VydmF0aW9uYWxseSB0aGlzIGVuZHMgdXAgYmVpbmcgZW5vdWdoIHRpbWUuIFRoZSBjYWxsZXIgbXVzdCBhbHNvIGVuc3VyZSB0aGF0IHRoZSBidWZmZXIgd2lsbCBnbyBvdXQgb2Ygc2NvcGVcbi8vIHNob3J0bHkgYWZ0ZXIgY2FsbGluZyB0aGlzLlxuLy8gV2UgaGF2ZSB0byBwYXNzIGluIGBjYWxsUnVzdGAgYmVjYXVzZSB3ZSBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uIGZyb20gYSB2YXJpZXR5IG9mIHJ1bnRpbWVzLlxuLy8gTm90ZSB0aGF0IGFzc2VydGlvbnMgb24gZ2FyYmFnZSBjb2xsZWN0aW9uIGFyZSBleHRyZW1lbHkgc2Vuc2l0aXZlIHRvIGV4YWN0bHkgaG93IHRoZXNlIGZ1bmN0aW9ucyBhcmUgd3JpdHRlbixcbi8vIGFuZCBjYW4gZWFzaWx5IGJyZWFrIGlmIHlvdSByZXN0dWN0dXJlIHRoZSBmdW5jdGlvbiwgdXNlIGEgZGlmZmVyZW50L25ld2VyIGJyb3dzZXIsIGV0YyFcbmV4cG9ydCBjb25zdCBleHBlY3REZWFsbG9jYXRpb25PclVucmVnaXN0ZXIgPSAoY2FsbFJ1c3QsIHdyZkFycmF5KSA9PiB7XG4gICAgLy8gRGVhbGxvY2F0aW9uIGNvZGUgaXMgb25seSBydW4gaW4gV0FTTSBmb3Igbm93LlxuICAgIGlmIChqc1J1bnRpbWUgPT09IFwiY2VmXCIpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCBidWZmZXIgPSB3cmZBcnJheS5idWZmZXI7XG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkb25seVxuICAgICAgICA/IGFyY0FsbG9jYXRlZChjYWxsUnVzdCwgYnVmZmVyKS50aGVuKChhcmNQdHIpID0+IGFyY0RlYWxsb2NhdGVkKGFyY1B0cikpXG4gICAgICAgIDogdmVjRGVhbGxvY2F0ZWQoYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5idWZmZXJQdHIpO1xufTtcbmV4cG9ydCBsZXQgaW5UZXN0ID0gZmFsc2U7XG4vLyBTZXQgdGhpcyB0byB0cnVlIHRvIGVuYWJsZSB0ZXN0aW5nIGNvZGVcbmV4cG9ydCBjb25zdCBzZXRJblRlc3QgPSAodikgPT4ge1xuICAgIGluVGVzdCA9IHY7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./wrf_test.ts\n");

/***/ }),

/***/ "./wrf_web_worker_runtime.ts":
/*!***********************************!*\
  !*** ./wrf_web_worker_runtime.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n/* harmony import */ var _rpc_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc_types */ \"./rpc_types.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n/* harmony import */ var _zerde__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zerde */ \"./zerde.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n(0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.overwriteTypedArraysWithWrfArrays)();\nlet _wrfWorkerRpc;\nself.initWrfUserWorkerRuntime = (wrfWorkerPort) => {\n    if (self.wrfInitialized) {\n        throw new Error(\"Don't call initWrfUserWorkerRuntime twice\");\n    }\n    self.wrfInitialized = new Promise((resolve) => {\n        _wrfWorkerRpc = new _common__WEBPACK_IMPORTED_MODULE_0__.Rpc(wrfWorkerPort);\n        self.wrfNewWorkerPort = () => {\n            const channel = new MessageChannel();\n            _wrfWorkerRpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_1__.MainWorkerChannelEvent.BindMainWorkerPort, channel.port1, [channel.port1]);\n            return channel.port2;\n        };\n        _wrfWorkerRpc\n            .send(_rpc_types__WEBPACK_IMPORTED_MODULE_1__.MainWorkerChannelEvent.Init)\n            .then(({ wasmModule, memory, taskWorkerSab, baseUri, appPtr, tlsAndStackData, }) => {\n            let wasmExports;\n            function getExports() {\n                return wasmExports;\n            }\n            const env = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getWasmEnv)({\n                getExports,\n                memory,\n                taskWorkerSab,\n                fileHandles: [],\n                sendEventFromAnyThread: (eventPtr) => {\n                    _wrfWorkerRpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_1__.MainWorkerChannelEvent.SendEventFromAnyThread, eventPtr);\n                },\n                threadSpawn: () => {\n                    throw new Error(\"Not yet implemented\");\n                },\n                baseUri,\n            });\n            WebAssembly.instantiate(wasmModule, { env }).then((instance) => {\n                wasmExports = instance.exports;\n                (0,_common__WEBPACK_IMPORTED_MODULE_0__.initThreadLocalStorageAndStackOtherWorkers)(wasmExports, tlsAndStackData);\n                const destructor = (arcPtr) => {\n                    wasmExports.decrementArc(BigInt(arcPtr));\n                };\n                const mutableDestructor = ({ bufferPtr, bufferLen, bufferCap, }) => {\n                    wasmExports.deallocVec(BigInt(bufferPtr), BigInt(bufferLen), BigInt(bufferCap));\n                };\n                const transformParamsFromRust = (params) => (0,_common__WEBPACK_IMPORTED_MODULE_0__.transformParamsFromRustImpl)(memory, destructor, mutableDestructor, params);\n                // TODO(JP): Allocate buffers on the wasm memory directly here.\n                self.callRust = (name, params = []) => __awaiter(void 0, void 0, void 0, function* () {\n                    for (const param of params) {\n                        if (typeof param !== \"string\" &&\n                            !(param.buffer instanceof SharedArrayBuffer)) {\n                            console.warn(\"Consider passing Uint8Arrays backed by SharedArrayBuffer into `callRust` to prevent copying data\");\n                        }\n                    }\n                    const result = yield _wrfWorkerRpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_1__.MainWorkerChannelEvent.CallRust, {\n                        name,\n                        params,\n                    });\n                    return transformParamsFromRust(result);\n                });\n                // TODO(JP): Some of this code is duplicated with callRust/call_js; see if we can reuse some.\n                self.callRustInSameThreadSync = (name, params = []) => {\n                    const zerdeBuilder = (0,_common__WEBPACK_IMPORTED_MODULE_0__.makeZerdeBuilder)(memory, wasmExports);\n                    zerdeBuilder.sendString(name);\n                    zerdeBuilder.sendU32(params.length);\n                    for (const param of params) {\n                        if (typeof param === \"string\") {\n                            zerdeBuilder.sendU32(_types__WEBPACK_IMPORTED_MODULE_2__.WrfParamType.String);\n                            zerdeBuilder.sendString(param);\n                        }\n                        else {\n                            if (param.buffer instanceof _wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.WrfBuffer) {\n                                (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.checkValidWrfArray)(param);\n                                if (param.buffer.__wrflibBufferData.readonly) {\n                                    zerdeBuilder.sendU32((0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(param, true));\n                                    const arcPtr = param.buffer.__wrflibBufferData.arcPtr;\n                                    // WrfParam parsing code will construct an Arc without incrementing\n                                    // the count, so we do it here ahead of time.\n                                    wasmExports.incrementArc(BigInt(arcPtr));\n                                    zerdeBuilder.sendU32(arcPtr);\n                                }\n                                else {\n                                    // TODO(Paras): User should not be able to access the buffer after\n                                    // passing it to Rust here\n                                    (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.unregisterMutableBuffer)(param.buffer);\n                                    zerdeBuilder.sendU32((0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(param, false));\n                                    zerdeBuilder.sendU32(param.buffer.__wrflibBufferData.bufferPtr);\n                                    zerdeBuilder.sendU32(param.buffer.__wrflibBufferData.bufferLen);\n                                    zerdeBuilder.sendU32(param.buffer.__wrflibBufferData.bufferCap);\n                                }\n                            }\n                            else {\n                                console.warn(\"Consider passing Uint8Arrays backed by WrfBuffer to prevent copying data\");\n                                const vecLen = param.byteLength;\n                                const vecPtr = (0,_common__WEBPACK_IMPORTED_MODULE_0__.createWasmBuffer)(memory, wasmExports, param);\n                                zerdeBuilder.sendU32((0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(param, false));\n                                zerdeBuilder.sendU32(vecPtr);\n                                zerdeBuilder.sendU32(vecLen);\n                                zerdeBuilder.sendU32(vecLen);\n                            }\n                        }\n                    }\n                    const returnPtr = wasmExports.callRustInSameThreadSync(appPtr, BigInt(zerdeBuilder.getData().byteOffset));\n                    const zerdeParser = new _zerde__WEBPACK_IMPORTED_MODULE_4__.ZerdeParser(memory, Number(returnPtr));\n                    const returnParams = zerdeParser.parseWrfParams();\n                    return transformParamsFromRust(returnParams);\n                };\n                self.createBuffer = (data) => {\n                    const bufferLen = data.byteLength;\n                    const bufferPtr = (0,_common__WEBPACK_IMPORTED_MODULE_0__.createWasmBuffer)(memory, wasmExports, data);\n                    return transformParamsFromRust([\n                        {\n                            paramType: (0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(data, false),\n                            bufferPtr,\n                            bufferLen,\n                            bufferCap: bufferLen,\n                            readonly: false,\n                        },\n                    ])[0];\n                };\n                self.createReadOnlyBuffer = (data) => {\n                    const bufferPtr = (0,_common__WEBPACK_IMPORTED_MODULE_0__.createWasmBuffer)(memory, wasmExports, data);\n                    const paramType = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(data, true);\n                    const arcPtr = Number(wasmExports.createArcVec(BigInt(bufferPtr), BigInt(data.length), BigInt(paramType)));\n                    return transformParamsFromRust([\n                        {\n                            paramType,\n                            bufferPtr,\n                            bufferLen: data.byteLength,\n                            arcPtr,\n                            readonly: true,\n                        },\n                    ])[0];\n                };\n                self.isWrfBuffer = _wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.isWrfBuffer;\n                // TODO(JP): Somewhat duplicated with the other implementation.\n                self.serializeWrfArrayForPostMessage = (wrfArray) => {\n                    if (!(typeof wrfArray === \"object\" &&\n                        self.isWrfBuffer(wrfArray.buffer))) {\n                        throw new Error(\"Only pass Wrf arrays to serializeWrfArrayForPostMessage\");\n                    }\n                    const wrfBuffer = wrfArray.buffer;\n                    if (wrfBuffer.readonly) {\n                        wasmExports.incrementArc(BigInt(wrfBuffer.__wrflibBufferData.arcPtr));\n                    }\n                    else {\n                        (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.unregisterMutableBuffer)(wrfBuffer);\n                    }\n                    return {\n                        bufferData: wrfBuffer.__wrflibBufferData,\n                        byteOffset: wrfArray.byteOffset,\n                        byteLength: wrfArray.byteLength,\n                    };\n                };\n                self.deserializeWrfArrayFromPostMessage = (postMessageData) => {\n                    const wrfBuffer = (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_3__.getWrfBufferWasm)(memory, postMessageData.bufferData, destructor, mutableDestructor);\n                    return new Uint8Array(wrfBuffer, postMessageData.byteOffset, postMessageData.byteLength);\n                };\n                resolve();\n            });\n        });\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfd2ViX3dvcmtlcl9ydW50aW1lLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cmYvLi93cmZfd2ViX3dvcmtlcl9ydW50aW1lLnRzPzEwMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgY3JlYXRlV2FzbUJ1ZmZlciwgZ2V0V2FzbUVudiwgZ2V0V3JmUGFyYW1UeXBlLCBpbml0VGhyZWFkTG9jYWxTdG9yYWdlQW5kU3RhY2tPdGhlcldvcmtlcnMsIG1ha2VaZXJkZUJ1aWxkZXIsIFJwYywgdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3RJbXBsLCB9IGZyb20gXCIuL2NvbW1vblwiO1xuaW1wb3J0IHsgTWFpbldvcmtlckNoYW5uZWxFdmVudCB9IGZyb20gXCIuL3JwY190eXBlc1wiO1xuaW1wb3J0IHsgV3JmUGFyYW1UeXBlLCB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRXcmZCdWZmZXJXYXNtLCBpc1dyZkJ1ZmZlciwgb3ZlcndyaXRlVHlwZWRBcnJheXNXaXRoV3JmQXJyYXlzLCB1bnJlZ2lzdGVyTXV0YWJsZUJ1ZmZlciwgV3JmQnVmZmVyLCBjaGVja1ZhbGlkV3JmQXJyYXksIH0gZnJvbSBcIi4vd3JmX2J1ZmZlclwiO1xuaW1wb3J0IHsgWmVyZGVQYXJzZXIgfSBmcm9tIFwiLi96ZXJkZVwiO1xub3ZlcndyaXRlVHlwZWRBcnJheXNXaXRoV3JmQXJyYXlzKCk7XG5sZXQgX3dyZldvcmtlclJwYztcbnNlbGYuaW5pdFdyZlVzZXJXb3JrZXJSdW50aW1lID0gKHdyZldvcmtlclBvcnQpID0+IHtcbiAgICBpZiAoc2VsZi53cmZJbml0aWFsaXplZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCBjYWxsIGluaXRXcmZVc2VyV29ya2VyUnVudGltZSB0d2ljZVwiKTtcbiAgICB9XG4gICAgc2VsZi53cmZJbml0aWFsaXplZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF93cmZXb3JrZXJScGMgPSBuZXcgUnBjKHdyZldvcmtlclBvcnQpO1xuICAgICAgICBzZWxmLndyZk5ld1dvcmtlclBvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBfd3JmV29ya2VyUnBjLnNlbmQoTWFpbldvcmtlckNoYW5uZWxFdmVudC5CaW5kTWFpbldvcmtlclBvcnQsIGNoYW5uZWwucG9ydDEsIFtjaGFubmVsLnBvcnQxXSk7XG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbC5wb3J0MjtcbiAgICAgICAgfTtcbiAgICAgICAgX3dyZldvcmtlclJwY1xuICAgICAgICAgICAgLnNlbmQoTWFpbldvcmtlckNoYW5uZWxFdmVudC5Jbml0KVxuICAgICAgICAgICAgLnRoZW4oKHsgd2FzbU1vZHVsZSwgbWVtb3J5LCB0YXNrV29ya2VyU2FiLCBiYXNlVXJpLCBhcHBQdHIsIHRsc0FuZFN0YWNrRGF0YSwgfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHdhc21FeHBvcnRzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RXhwb3J0cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FzbUV4cG9ydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbnYgPSBnZXRXYXNtRW52KHtcbiAgICAgICAgICAgICAgICBnZXRFeHBvcnRzLFxuICAgICAgICAgICAgICAgIG1lbW9yeSxcbiAgICAgICAgICAgICAgICB0YXNrV29ya2VyU2FiLFxuICAgICAgICAgICAgICAgIGZpbGVIYW5kbGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRGcm9tQW55VGhyZWFkOiAoZXZlbnRQdHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgX3dyZldvcmtlclJwYy5zZW5kKE1haW5Xb3JrZXJDaGFubmVsRXZlbnQuU2VuZEV2ZW50RnJvbUFueVRocmVhZCwgZXZlbnRQdHIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhyZWFkU3Bhd246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhc2VVcmksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21Nb2R1bGUsIHsgZW52IH0pLnRoZW4oKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgd2FzbUV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgICAgICAgICAgICAgIGluaXRUaHJlYWRMb2NhbFN0b3JhZ2VBbmRTdGFja090aGVyV29ya2Vycyh3YXNtRXhwb3J0cywgdGxzQW5kU3RhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXN0cnVjdG9yID0gKGFyY1B0cikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3YXNtRXhwb3J0cy5kZWNyZW1lbnRBcmMoQmlnSW50KGFyY1B0cikpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbXV0YWJsZURlc3RydWN0b3IgPSAoeyBidWZmZXJQdHIsIGJ1ZmZlckxlbiwgYnVmZmVyQ2FwLCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdhc21FeHBvcnRzLmRlYWxsb2NWZWMoQmlnSW50KGJ1ZmZlclB0ciksIEJpZ0ludChidWZmZXJMZW4pLCBCaWdJbnQoYnVmZmVyQ2FwKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1QYXJhbXNGcm9tUnVzdCA9IChwYXJhbXMpID0+IHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0SW1wbChtZW1vcnksIGRlc3RydWN0b3IsIG11dGFibGVEZXN0cnVjdG9yLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oSlApOiBBbGxvY2F0ZSBidWZmZXJzIG9uIHRoZSB3YXNtIG1lbW9yeSBkaXJlY3RseSBoZXJlLlxuICAgICAgICAgICAgICAgIHNlbGYuY2FsbFJ1c3QgPSAobmFtZSwgcGFyYW1zID0gW10pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEocGFyYW0uYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ29uc2lkZXIgcGFzc2luZyBVaW50OEFycmF5cyBiYWNrZWQgYnkgU2hhcmVkQXJyYXlCdWZmZXIgaW50byBgY2FsbFJ1c3RgIHRvIHByZXZlbnQgY29weWluZyBkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIF93cmZXb3JrZXJScGMuc2VuZChNYWluV29ya2VyQ2hhbm5lbEV2ZW50LkNhbGxSdXN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhKUCk6IFNvbWUgb2YgdGhpcyBjb2RlIGlzIGR1cGxpY2F0ZWQgd2l0aCBjYWxsUnVzdC9jYWxsX2pzOyBzZWUgaWYgd2UgY2FuIHJldXNlIHNvbWUuXG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsUnVzdEluU2FtZVRocmVhZFN5bmMgPSAobmFtZSwgcGFyYW1zID0gW10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgemVyZGVCdWlsZGVyID0gbWFrZVplcmRlQnVpbGRlcihtZW1vcnksIHdhc21FeHBvcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgemVyZGVCdWlsZGVyLnNlbmRTdHJpbmcobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKHBhcmFtcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKFdyZlBhcmFtVHlwZS5TdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kU3RyaW5nKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5idWZmZXIgaW5zdGFuY2VvZiBXcmZCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tWYWxpZFdyZkFycmF5KHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLmJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEucmVhZG9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKGdldFdyZlBhcmFtVHlwZShwYXJhbSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJjUHRyID0gcGFyYW0uYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5hcmNQdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcmZQYXJhbSBwYXJzaW5nIGNvZGUgd2lsbCBjb25zdHJ1Y3QgYW4gQXJjIHdpdGhvdXQgaW5jcmVtZW50aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY291bnQsIHNvIHdlIGRvIGl0IGhlcmUgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc21FeHBvcnRzLmluY3JlbWVudEFyYyhCaWdJbnQoYXJjUHRyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMihhcmNQdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhQYXJhcyk6IFVzZXIgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgYnVmZmVyIGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXNzaW5nIGl0IHRvIFJ1c3QgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3Rlck11dGFibGVCdWZmZXIocGFyYW0uYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKGdldFdyZlBhcmFtVHlwZShwYXJhbSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKHBhcmFtLmJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKHBhcmFtLmJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyTGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKHBhcmFtLmJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyQ2FwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ29uc2lkZXIgcGFzc2luZyBVaW50OEFycmF5cyBiYWNrZWQgYnkgV3JmQnVmZmVyIHRvIHByZXZlbnQgY29weWluZyBkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWNMZW4gPSBwYXJhbS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWNQdHIgPSBjcmVhdGVXYXNtQnVmZmVyKG1lbW9yeSwgd2FzbUV4cG9ydHMsIHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyZGVCdWlsZGVyLnNlbmRVMzIoZ2V0V3JmUGFyYW1UeXBlKHBhcmFtLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMih2ZWNQdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMih2ZWNMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMih2ZWNMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5QdHIgPSB3YXNtRXhwb3J0cy5jYWxsUnVzdEluU2FtZVRocmVhZFN5bmMoYXBwUHRyLCBCaWdJbnQoemVyZGVCdWlsZGVyLmdldERhdGEoKS5ieXRlT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHplcmRlUGFyc2VyID0gbmV3IFplcmRlUGFyc2VyKG1lbW9yeSwgTnVtYmVyKHJldHVyblB0cikpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5QYXJhbXMgPSB6ZXJkZVBhcnNlci5wYXJzZVdyZlBhcmFtcygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3QocmV0dXJuUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlbGYuY3JlYXRlQnVmZmVyID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyTGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJQdHIgPSBjcmVhdGVXYXNtQnVmZmVyKG1lbW9yeSwgd2FzbUV4cG9ydHMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3QoW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVHlwZTogZ2V0V3JmUGFyYW1UeXBlKGRhdGEsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJQdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyTGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckNhcDogYnVmZmVyTGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0pWzBdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VsZi5jcmVhdGVSZWFkT25seUJ1ZmZlciA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclB0ciA9IGNyZWF0ZVdhc21CdWZmZXIobWVtb3J5LCB3YXNtRXhwb3J0cywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IGdldFdyZlBhcmFtVHlwZShkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJjUHRyID0gTnVtYmVyKHdhc21FeHBvcnRzLmNyZWF0ZUFyY1ZlYyhCaWdJbnQoYnVmZmVyUHRyKSwgQmlnSW50KGRhdGEubGVuZ3RoKSwgQmlnSW50KHBhcmFtVHlwZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyUHRyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckxlbjogZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyY1B0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0pWzBdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VsZi5pc1dyZkJ1ZmZlciA9IGlzV3JmQnVmZmVyO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oSlApOiBTb21ld2hhdCBkdXBsaWNhdGVkIHdpdGggdGhlIG90aGVyIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICAgIHNlbGYuc2VyaWFsaXplV3JmQXJyYXlGb3JQb3N0TWVzc2FnZSA9ICh3cmZBcnJheSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2Ygd3JmQXJyYXkgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaXNXcmZCdWZmZXIod3JmQXJyYXkuYnVmZmVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgcGFzcyBXcmYgYXJyYXlzIHRvIHNlcmlhbGl6ZVdyZkFycmF5Rm9yUG9zdE1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gd3JmQXJyYXkuYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JmQnVmZmVyLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNtRXhwb3J0cy5pbmNyZW1lbnRBcmMoQmlnSW50KHdyZkJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYXJjUHRyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyTXV0YWJsZUJ1ZmZlcih3cmZCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJEYXRhOiB3cmZCdWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogd3JmQXJyYXkuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IHdyZkFycmF5LmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZWxmLmRlc2VyaWFsaXplV3JmQXJyYXlGcm9tUG9zdE1lc3NhZ2UgPSAocG9zdE1lc3NhZ2VEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyZkJ1ZmZlciA9IGdldFdyZkJ1ZmZlcldhc20obWVtb3J5LCBwb3N0TWVzc2FnZURhdGEuYnVmZmVyRGF0YSwgZGVzdHJ1Y3RvciwgbXV0YWJsZURlc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod3JmQnVmZmVyLCBwb3N0TWVzc2FnZURhdGEuYnl0ZU9mZnNldCwgcG9zdE1lc3NhZ2VEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./wrf_web_worker_runtime.ts\n");

/***/ }),

/***/ "./zerde.ts":
/*!******************!*\
  !*** ./zerde.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZerdeBuilder\": () => (/* binding */ ZerdeBuilder),\n/* harmony export */   \"ZerdeParser\": () => (/* binding */ ZerdeParser)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Zerde is our lightweight manual serialization/deserialization system.\n//\n// Keep in sync with zerde.rs, and see there for more information.\n\n// Construct a buffer that can be read in Rust, using the corresponding `ZerderParser` struct in Rust.\nclass ZerdeBuilder {\n    constructor({ buffer, byteOffset, slots, growCallback, }) {\n        this._buffer = buffer;\n        this._byteOffset = byteOffset;\n        this._slots = slots;\n        this._growCallback = growCallback;\n        this._used = 2; // Skip 8 byte header which contains the size.\n        this._updateRefs();\n    }\n    _updateRefs() {\n        this._f32 = new Float32Array(this._buffer, this._byteOffset, this._slots);\n        this._u32 = new Uint32Array(this._buffer, this._byteOffset, this._slots);\n        this._f64 = new Float64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64 = new BigUint64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64[0] = BigInt(this._slots) * BigInt(4); // Write size to header.\n    }\n    _fit(slots) {\n        if (this._used + slots > this._slots) {\n            let newSlots = Math.max(this._used + slots, this._slots * 2); // Exponential growth\n            if (newSlots & 1)\n                newSlots++; // 64-bit align it\n            const newBytes = newSlots * 4;\n            const { buffer, byteOffset } = this._growCallback(this._buffer, this._byteOffset, newBytes);\n            this._buffer = buffer;\n            this._byteOffset = byteOffset;\n            this._slots = newSlots;\n            this._updateRefs();\n        }\n        const pos = this._used;\n        this._used += slots;\n        return pos;\n    }\n    sendF32(value) {\n        const pos = this._fit(1);\n        this._f32[pos] = value;\n    }\n    sendU32(value) {\n        const pos = this._fit(1);\n        this._u32[pos] = value;\n    }\n    sendF64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._f64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._f64[pos >> 1] = value;\n        }\n    }\n    sendU64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._u64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._u64[pos >> 1] = value;\n        }\n    }\n    sendString(str) {\n        let pos = this._fit(str.length + 1);\n        this._u32[pos++] = str.length;\n        for (let i = 0; i < str.length; i++) {\n            this._u32[pos++] = str.charCodeAt(i);\n        }\n    }\n    getData() {\n        return { buffer: this._buffer, byteOffset: this._byteOffset };\n    }\n}\nclass ZerdeParser {\n    constructor(memory, zerdePtr) {\n        this._memory = memory;\n        // set up local shortcuts to the zerde memory chunk for faster parsing\n        this._usedSlots = 2; // skip the 8 byte header\n        this._f32 = new Float32Array(this._memory.buffer, zerdePtr);\n        this._u32 = new Uint32Array(this._memory.buffer, zerdePtr);\n        this._f64 = new Float64Array(this._memory.buffer, zerdePtr);\n        this._u64 = new BigUint64Array(this._memory.buffer, zerdePtr);\n    }\n    parseU32() {\n        return this._u32[this._usedSlots++];\n    }\n    parseF32() {\n        return this._f32[this._usedSlots++];\n    }\n    parseF64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._f64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseU64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._u64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseString() {\n        let str = \"\";\n        const len = this.parseU32();\n        for (let i = 0; i < len; i++) {\n            const c = this.parseU32();\n            if (c != 0)\n                str += String.fromCharCode(c);\n        }\n        return str;\n    }\n    parseU8Slice() {\n        const u8Len = this.parseU32();\n        const len = u8Len >> 2;\n        const data = new Uint8Array(u8Len);\n        const spare = u8Len & 3;\n        for (let i = 0; i < len; i++) {\n            const u8Pos = i << 2;\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n            data[u8Pos + 3] = (u32 >> 24) & 0xff;\n        }\n        const u8Pos = len << 2;\n        if (spare == 1) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n        }\n        else if (spare == 2) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n        }\n        else if (spare == 3) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n        }\n        return data;\n    }\n    parseWrfParams() {\n        const len = this.parseU32();\n        const params = [];\n        for (let i = 0; i < len; ++i) {\n            const paramType = this.parseU32();\n            if (paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.String) {\n                params.push(this.parseString());\n            }\n            else if (paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyU8Buffer ||\n                paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyF32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const arcPtr = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    arcPtr,\n                    readonly: true,\n                });\n            }\n            else if (paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.U8Buffer ||\n                paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.F32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const bufferCap = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    bufferCap,\n                    readonly: false,\n                });\n            }\n            else {\n                throw new Error(`Unknown WrfParam type: ${paramType}`);\n            }\n        }\n        return params;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi96ZXJkZS50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3plcmRlLnRzPzNjNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFplcmRlIGlzIG91ciBsaWdodHdlaWdodCBtYW51YWwgc2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRpb24gc3lzdGVtLlxuLy9cbi8vIEtlZXAgaW4gc3luYyB3aXRoIHplcmRlLnJzLCBhbmQgc2VlIHRoZXJlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuaW1wb3J0IHsgV3JmUGFyYW1UeXBlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbi8vIENvbnN0cnVjdCBhIGJ1ZmZlciB0aGF0IGNhbiBiZSByZWFkIGluIFJ1c3QsIHVzaW5nIHRoZSBjb3JyZXNwb25kaW5nIGBaZXJkZXJQYXJzZXJgIHN0cnVjdCBpbiBSdXN0LlxuZXhwb3J0IGNsYXNzIFplcmRlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoeyBidWZmZXIsIGJ5dGVPZmZzZXQsIHNsb3RzLCBncm93Q2FsbGJhY2ssIH0pIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLl9ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgdGhpcy5fc2xvdHMgPSBzbG90cztcbiAgICAgICAgdGhpcy5fZ3Jvd0NhbGxiYWNrID0gZ3Jvd0NhbGxiYWNrO1xuICAgICAgICB0aGlzLl91c2VkID0gMjsgLy8gU2tpcCA4IGJ5dGUgaGVhZGVyIHdoaWNoIGNvbnRhaW5zIHRoZSBzaXplLlxuICAgICAgICB0aGlzLl91cGRhdGVSZWZzKCk7XG4gICAgfVxuICAgIF91cGRhdGVSZWZzKCkge1xuICAgICAgICB0aGlzLl9mMzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5fYnl0ZU9mZnNldCwgdGhpcy5fc2xvdHMpO1xuICAgICAgICB0aGlzLl91MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0LCB0aGlzLl9zbG90cyk7XG4gICAgICAgIHRoaXMuX2Y2NCA9IG5ldyBGbG9hdDY0QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0LCB0aGlzLl9zbG90cyA+PiAxKTtcbiAgICAgICAgdGhpcy5fdTY0ID0gbmV3IEJpZ1VpbnQ2NEFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5fYnl0ZU9mZnNldCwgdGhpcy5fc2xvdHMgPj4gMSk7XG4gICAgICAgIHRoaXMuX3U2NFswXSA9IEJpZ0ludCh0aGlzLl9zbG90cykgKiBCaWdJbnQoNCk7IC8vIFdyaXRlIHNpemUgdG8gaGVhZGVyLlxuICAgIH1cbiAgICBfZml0KHNsb3RzKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VkICsgc2xvdHMgPiB0aGlzLl9zbG90cykge1xuICAgICAgICAgICAgbGV0IG5ld1Nsb3RzID0gTWF0aC5tYXgodGhpcy5fdXNlZCArIHNsb3RzLCB0aGlzLl9zbG90cyAqIDIpOyAvLyBFeHBvbmVudGlhbCBncm93dGhcbiAgICAgICAgICAgIGlmIChuZXdTbG90cyAmIDEpXG4gICAgICAgICAgICAgICAgbmV3U2xvdHMrKzsgLy8gNjQtYml0IGFsaWduIGl0XG4gICAgICAgICAgICBjb25zdCBuZXdCeXRlcyA9IG5ld1Nsb3RzICogNDtcbiAgICAgICAgICAgIGNvbnN0IHsgYnVmZmVyLCBieXRlT2Zmc2V0IH0gPSB0aGlzLl9ncm93Q2FsbGJhY2sodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0LCBuZXdCeXRlcyk7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB0aGlzLl9ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX3Nsb3RzID0gbmV3U2xvdHM7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSZWZzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fdXNlZDtcbiAgICAgICAgdGhpcy5fdXNlZCArPSBzbG90cztcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc2VuZEYzMih2YWx1ZSkge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9maXQoMSk7XG4gICAgICAgIHRoaXMuX2YzMltwb3NdID0gdmFsdWU7XG4gICAgfVxuICAgIHNlbmRVMzIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fZml0KDEpO1xuICAgICAgICB0aGlzLl91MzJbcG9zXSA9IHZhbHVlO1xuICAgIH1cbiAgICBzZW5kRjY0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VkICYgMSkge1xuICAgICAgICAgICAgLy8gNjQtYml0IGFsaWdubWVudC5cbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2ZpdCgzKSArIDE7XG4gICAgICAgICAgICB0aGlzLl9mNjRbcG9zID4+IDFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9maXQoMik7XG4gICAgICAgICAgICB0aGlzLl9mNjRbcG9zID4+IDFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZFU2NCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fdXNlZCAmIDEpIHtcbiAgICAgICAgICAgIC8vIDY0LWJpdCBhbGlnbm1lbnQuXG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9maXQoMykgKyAxO1xuICAgICAgICAgICAgdGhpcy5fdTY0W3BvcyA+PiAxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fZml0KDIpO1xuICAgICAgICAgICAgdGhpcy5fdTY0W3BvcyA+PiAxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRTdHJpbmcoc3RyKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLl9maXQoc3RyLmxlbmd0aCArIDEpO1xuICAgICAgICB0aGlzLl91MzJbcG9zKytdID0gc3RyLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3UzMltwb3MrK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4geyBidWZmZXI6IHRoaXMuX2J1ZmZlciwgYnl0ZU9mZnNldDogdGhpcy5fYnl0ZU9mZnNldCB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBaZXJkZVBhcnNlciB7XG4gICAgY29uc3RydWN0b3IobWVtb3J5LCB6ZXJkZVB0cikge1xuICAgICAgICB0aGlzLl9tZW1vcnkgPSBtZW1vcnk7XG4gICAgICAgIC8vIHNldCB1cCBsb2NhbCBzaG9ydGN1dHMgdG8gdGhlIHplcmRlIG1lbW9yeSBjaHVuayBmb3IgZmFzdGVyIHBhcnNpbmdcbiAgICAgICAgdGhpcy5fdXNlZFNsb3RzID0gMjsgLy8gc2tpcCB0aGUgOCBieXRlIGhlYWRlclxuICAgICAgICB0aGlzLl9mMzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX21lbW9yeS5idWZmZXIsIHplcmRlUHRyKTtcbiAgICAgICAgdGhpcy5fdTMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX21lbW9yeS5idWZmZXIsIHplcmRlUHRyKTtcbiAgICAgICAgdGhpcy5fZjY0ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLl9tZW1vcnkuYnVmZmVyLCB6ZXJkZVB0cik7XG4gICAgICAgIHRoaXMuX3U2NCA9IG5ldyBCaWdVaW50NjRBcnJheSh0aGlzLl9tZW1vcnkuYnVmZmVyLCB6ZXJkZVB0cik7XG4gICAgfVxuICAgIHBhcnNlVTMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdTMyW3RoaXMuX3VzZWRTbG90cysrXTtcbiAgICB9XG4gICAgcGFyc2VGMzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mMzJbdGhpcy5fdXNlZFNsb3RzKytdO1xuICAgIH1cbiAgICBwYXJzZUY2NCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZWRTbG90cyAmIDEpIHtcbiAgICAgICAgICAgIC8vIDY0LWJpdCBhbGlnbm1lbnQuXG4gICAgICAgICAgICB0aGlzLl91c2VkU2xvdHMrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzLl9mNjRbdGhpcy5fdXNlZFNsb3RzID4+IDFdO1xuICAgICAgICB0aGlzLl91c2VkU2xvdHMgKz0gMjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcGFyc2VVNjQoKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VkU2xvdHMgJiAxKSB7XG4gICAgICAgICAgICAvLyA2NC1iaXQgYWxpZ25tZW50LlxuICAgICAgICAgICAgdGhpcy5fdXNlZFNsb3RzKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5fdTY0W3RoaXMuX3VzZWRTbG90cyA+PiAxXTtcbiAgICAgICAgdGhpcy5fdXNlZFNsb3RzICs9IDI7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHBhcnNlU3RyaW5nKCkge1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgaWYgKGMgIT0gMClcbiAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBwYXJzZVU4U2xpY2UoKSB7XG4gICAgICAgIGNvbnN0IHU4TGVuID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICBjb25zdCBsZW4gPSB1OExlbiA+PiAyO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodThMZW4pO1xuICAgICAgICBjb25zdCBzcGFyZSA9IHU4TGVuICYgMztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdThQb3MgPSBpIDw8IDI7XG4gICAgICAgICAgICBjb25zdCB1MzIgPSB0aGlzLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgMF0gPSB1MzIgJiAweGZmO1xuICAgICAgICAgICAgZGF0YVt1OFBvcyArIDFdID0gKHUzMiA+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgMl0gPSAodTMyID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgM10gPSAodTMyID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdThQb3MgPSBsZW4gPDwgMjtcbiAgICAgICAgaWYgKHNwYXJlID09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHUzMiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAwXSA9IHUzMiAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3BhcmUgPT0gMikge1xuICAgICAgICAgICAgY29uc3QgdTMyID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgZGF0YVt1OFBvcyArIDBdID0gdTMyICYgMHhmZjtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAxXSA9ICh1MzIgPj4gOCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNwYXJlID09IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUzMiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAwXSA9IHUzMiAmIDB4ZmY7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgMV0gPSAodTMyID4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAyXSA9ICh1MzIgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcGFyc2VXcmZQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGlmIChwYXJhbVR5cGUgPT09IFdyZlBhcmFtVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh0aGlzLnBhcnNlU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1UeXBlID09PSBXcmZQYXJhbVR5cGUuUmVhZE9ubHlVOEJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgIHBhcmFtVHlwZSA9PT0gV3JmUGFyYW1UeXBlLlJlYWRPbmx5RjMyQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyUHRyID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckxlbiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmNQdHIgPSB0aGlzLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclB0cixcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyTGVuLFxuICAgICAgICAgICAgICAgICAgICBhcmNQdHIsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1UeXBlID09PSBXcmZQYXJhbVR5cGUuVThCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICBwYXJhbVR5cGUgPT09IFdyZlBhcmFtVHlwZS5GMzJCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJQdHIgPSB0aGlzLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyTGVuID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckNhcCA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUHRyLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXJMZW4sXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckNhcCxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFdyZlBhcmFtIHR5cGU6ICR7cGFyYW1UeXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./zerde.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./wrf_web_worker_runtime.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});