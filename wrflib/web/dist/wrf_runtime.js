/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["wrf"] = factory();
	else
		root["wrf"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./wrf.css":
/*!*******************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./wrf.css ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/sourceMaps.js */ \"./node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"* {\\n    user-select: none;\\n}\\nhtml, body {\\n    overflow: hidden;\\n    background-color: #333;\\n}\\nbody {\\n    margin: 0;\\n    position: fixed;\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.cx_webgl {\\n    position: absolute; /* For z-index */\\n    top: 0;\\n    left: 0;\\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\\n    z-index: 2147483647;\\n    width: 100%;\\n    height: 100%;\\n    pointer-events: none;\\n    user-select: none;\\n    touch-action: pan-x pan-y; /* Mobile Safari doesn't support \\\"none\\\" */\\n}\\n.cx_webgl_loader {\\n    position: fixed;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    color: #666;\\n    font-size: 40px;\\n}\\n#js_root {\\n    position: absolute; /* For z-index */\\n    z-index: 0; /* New stacking context */\\n    left: 0;\\n    right: 0;\\n    top: 0;\\n    bottom: 0;\\n}\\n\\n.cx_webgl_loader > span {\\n    display: inline-block;\\n    animation-name: wiggle;\\n    animation-duration: 1000ms;\\n    animation-iteration-count: infinite;\\n    animation-timing-function: ease-in-out;\\n}\\n@keyframes wiggle {\\n  0% {transform: rotate(0deg);}\\n  10% {transform: rotate(10deg);}\\n  30% {transform: rotate(-10deg);}\\n  50% {transform: rotate(20deg);}\\n  70% {transform: rotate(-5deg);}\\n  90% {transform: rotate(2deg);}\\n  95% {transform: rotate(0deg);}\\n}\\n\\n.cx_webgl_loader > div {\\n    position: absolute;\\n    width: max-content;\\n    left: 50%;\\n    top: 50%;\\n    transform: translate(-50%, 40px);\\n    font-family: Verdana, Arial Black;\\n    font-weight: bold;\\n    font-size: 28px;\\n\\n\\tbackground: #222 -webkit-gradient(linear, left top, right top, from(#222), to(#222), color-stop(0.5, #fff)) 0 0 no-repeat;\\n\\tbackground-image: -webkit-linear-gradient(-40deg, transparent 0%, transparent 40%, #fff 50%, transparent 60%, transparent 100%);\\n\\tbackground-size: 200px;\\n\\t-webkit-background-clip: text;\\n\\tbackground-clip: text;\\n\\tanimation-name: shine;\\n\\tanimation-duration: 1s;\\n\\tanimation-iteration-count: infinite;\\n\\ttext-shadow: 0 0px 0px rgba(255, 255, 255, 0.5);\\n}\\n@keyframes shine {\\n\\t0% {\\n\\t\\tbackground-position: -200px 0;\\n\\t}\\n\\t100% {\\n\\t\\tbackground-position: 250px 0;\\n\\t}\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./wrf.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,iBAAiB;AACrB;AACA;IACI,gBAAgB;IAChB,sBAAsB;AAC1B;AACA;IACI,SAAS;IACT,eAAe;IACf,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,kBAAkB,EAAE,gBAAgB;IACpC,MAAM;IACN,OAAO;IACP,uHAAuH;IACvH,mBAAmB;IACnB,WAAW;IACX,YAAY;IACZ,oBAAoB;IACpB,iBAAiB;IACjB,yBAAyB,EAAE,yCAAyC;AACxE;AACA;IACI,eAAe;IACf,QAAQ;IACR,SAAS;IACT,gCAAgC;IAChC,WAAW;IACX,eAAe;AACnB;AACA;IACI,kBAAkB,EAAE,gBAAgB;IACpC,UAAU,EAAE,yBAAyB;IACrC,OAAO;IACP,QAAQ;IACR,MAAM;IACN,SAAS;AACb;;AAEA;IACI,qBAAqB;IACrB,sBAAsB;IACtB,0BAA0B;IAC1B,mCAAmC;IACnC,sCAAsC;AAC1C;AACA;EACE,IAAI,uBAAuB,CAAC;EAC5B,KAAK,wBAAwB,CAAC;EAC9B,KAAK,yBAAyB,CAAC;EAC/B,KAAK,wBAAwB,CAAC;EAC9B,KAAK,wBAAwB,CAAC;EAC9B,KAAK,uBAAuB,CAAC;EAC7B,KAAK,uBAAuB,CAAC;AAC/B;;AAEA;IACI,kBAAkB;IAClB,kBAAkB;IAClB,SAAS;IACT,QAAQ;IACR,gCAAgC;IAChC,iCAAiC;IACjC,iBAAiB;IACjB,eAAe;;CAElB,yHAAyH;CACzH,+HAA+H;CAC/H,sBAAsB;CACtB,6BAA6B;CAC7B,qBAAqB;CACrB,qBAAqB;CACrB,sBAAsB;CACtB,mCAAmC;CACnC,+CAA+C;AAChD;AACA;CACC;EACC,6BAA6B;CAC9B;CACA;EACC,4BAA4B;CAC7B;AACD\",\"sourcesContent\":[\"* {\\n    user-select: none;\\n}\\nhtml, body {\\n    overflow: hidden;\\n    background-color: #333;\\n}\\nbody {\\n    margin: 0;\\n    position: fixed;\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.cx_webgl {\\n    position: absolute; /* For z-index */\\n    top: 0;\\n    left: 0;\\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\\n    z-index: 2147483647;\\n    width: 100%;\\n    height: 100%;\\n    pointer-events: none;\\n    user-select: none;\\n    touch-action: pan-x pan-y; /* Mobile Safari doesn't support \\\"none\\\" */\\n}\\n.cx_webgl_loader {\\n    position: fixed;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    color: #666;\\n    font-size: 40px;\\n}\\n#js_root {\\n    position: absolute; /* For z-index */\\n    z-index: 0; /* New stacking context */\\n    left: 0;\\n    right: 0;\\n    top: 0;\\n    bottom: 0;\\n}\\n\\n.cx_webgl_loader > span {\\n    display: inline-block;\\n    animation-name: wiggle;\\n    animation-duration: 1000ms;\\n    animation-iteration-count: infinite;\\n    animation-timing-function: ease-in-out;\\n}\\n@keyframes wiggle {\\n  0% {transform: rotate(0deg);}\\n  10% {transform: rotate(10deg);}\\n  30% {transform: rotate(-10deg);}\\n  50% {transform: rotate(20deg);}\\n  70% {transform: rotate(-5deg);}\\n  90% {transform: rotate(2deg);}\\n  95% {transform: rotate(0deg);}\\n}\\n\\n.cx_webgl_loader > div {\\n    position: absolute;\\n    width: max-content;\\n    left: 50%;\\n    top: 50%;\\n    transform: translate(-50%, 40px);\\n    font-family: Verdana, Arial Black;\\n    font-weight: bold;\\n    font-size: 28px;\\n\\n\\tbackground: #222 -webkit-gradient(linear, left top, right top, from(#222), to(#222), color-stop(0.5, #fff)) 0 0 no-repeat;\\n\\tbackground-image: -webkit-linear-gradient(-40deg, transparent 0%, transparent 40%, #fff 50%, transparent 60%, transparent 100%);\\n\\tbackground-size: 200px;\\n\\t-webkit-background-clip: text;\\n\\tbackground-clip: text;\\n\\tanimation-name: shine;\\n\\tanimation-duration: 1s;\\n\\tanimation-iteration-count: infinite;\\n\\ttext-shadow: 0 0px 0px rgba(255, 255, 255, 0.5);\\n}\\n@keyframes shine {\\n\\t0% {\\n\\t\\tbackground-position: -200px 0;\\n\\t}\\n\\t100% {\\n\\t\\tbackground-position: 250px 0;\\n\\t}\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3dyZi5jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vd3JmLmNzcz8wMWZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIioge1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuaHRtbCwgYm9keSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XFxufVxcbmJvZHkge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLmN4X3dlYmdsIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlOyAvKiBGb3Igei1pbmRleCAqL1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIC8qIE1heCB2YWx1ZSB0byBiZSBzdXBlciBzdXJlIHRoYXQgaXQgcmVhbGx5IGlzIG9uIHRvcCBvZiBldmVyeXRoaW5nLCBpbiBjYXNlIEpTIGNyZWF0ZXMgZWxlbWVudHMgb3V0c2lkZSBvZiAjanMtcm9vdCAqL1xcbiAgICB6LWluZGV4OiAyMTQ3NDgzNjQ3O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIHRvdWNoLWFjdGlvbjogcGFuLXggcGFuLXk7IC8qIE1vYmlsZSBTYWZhcmkgZG9lc24ndCBzdXBwb3J0IFxcXCJub25lXFxcIiAqL1xcbn1cXG4uY3hfd2ViZ2xfbG9hZGVyIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgbGVmdDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gICAgY29sb3I6ICM2NjY7XFxuICAgIGZvbnQtc2l6ZTogNDBweDtcXG59XFxuI2pzX3Jvb3Qge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7IC8qIEZvciB6LWluZGV4ICovXFxuICAgIHotaW5kZXg6IDA7IC8qIE5ldyBzdGFja2luZyBjb250ZXh0ICovXFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG59XFxuXFxuLmN4X3dlYmdsX2xvYWRlciA+IHNwYW4ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIGFuaW1hdGlvbi1uYW1lOiB3aWdnbGU7XFxuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMTAwMG1zO1xcbiAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XFxufVxcbkBrZXlmcmFtZXMgd2lnZ2xlIHtcXG4gIDAlIHt0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTt9XFxuICAxMCUge3RyYW5zZm9ybTogcm90YXRlKDEwZGVnKTt9XFxuICAzMCUge3RyYW5zZm9ybTogcm90YXRlKC0xMGRlZyk7fVxcbiAgNTAlIHt0cmFuc2Zvcm06IHJvdGF0ZSgyMGRlZyk7fVxcbiAgNzAlIHt0cmFuc2Zvcm06IHJvdGF0ZSgtNWRlZyk7fVxcbiAgOTAlIHt0cmFuc2Zvcm06IHJvdGF0ZSgyZGVnKTt9XFxuICA5NSUge3RyYW5zZm9ybTogcm90YXRlKDBkZWcpO31cXG59XFxuXFxuLmN4X3dlYmdsX2xvYWRlciA+IGRpdiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IG1heC1jb250ZW50O1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRvcDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCA0MHB4KTtcXG4gICAgZm9udC1mYW1pbHk6IFZlcmRhbmEsIEFyaWFsIEJsYWNrO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgZm9udC1zaXplOiAyOHB4O1xcblxcblxcdGJhY2tncm91bmQ6ICMyMjIgLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIGxlZnQgdG9wLCByaWdodCB0b3AsIGZyb20oIzIyMiksIHRvKCMyMjIpLCBjb2xvci1zdG9wKDAuNSwgI2ZmZikpIDAgMCBuby1yZXBlYXQ7XFxuXFx0YmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoLTQwZGVnLCB0cmFuc3BhcmVudCAwJSwgdHJhbnNwYXJlbnQgNDAlLCAjZmZmIDUwJSwgdHJhbnNwYXJlbnQgNjAlLCB0cmFuc3BhcmVudCAxMDAlKTtcXG5cXHRiYWNrZ3JvdW5kLXNpemU6IDIwMHB4O1xcblxcdC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1xcblxcdGJhY2tncm91bmQtY2xpcDogdGV4dDtcXG5cXHRhbmltYXRpb24tbmFtZTogc2hpbmU7XFxuXFx0YW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcXG5cXHRhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXG5cXHR0ZXh0LXNoYWRvdzogMCAwcHggMHB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG59XFxuQGtleWZyYW1lcyBzaGluZSB7XFxuXFx0MCUge1xcblxcdFxcdGJhY2tncm91bmQtcG9zaXRpb246IC0yMDBweCAwO1xcblxcdH1cXG5cXHQxMDAlIHtcXG5cXHRcXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiAyNTBweCAwO1xcblxcdH1cXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vd3JmLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLGlCQUFpQjtBQUNyQjtBQUNBO0lBQ0ksZ0JBQWdCO0lBQ2hCLHNCQUFzQjtBQUMxQjtBQUNBO0lBQ0ksU0FBUztJQUNULGVBQWU7SUFDZixXQUFXO0lBQ1gsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLGtCQUFrQixFQUFFLGdCQUFnQjtJQUNwQyxNQUFNO0lBQ04sT0FBTztJQUNQLHVIQUF1SDtJQUN2SCxtQkFBbUI7SUFDbkIsV0FBVztJQUNYLFlBQVk7SUFDWixvQkFBb0I7SUFDcEIsaUJBQWlCO0lBQ2pCLHlCQUF5QixFQUFFLHlDQUF5QztBQUN4RTtBQUNBO0lBQ0ksZUFBZTtJQUNmLFFBQVE7SUFDUixTQUFTO0lBQ1QsZ0NBQWdDO0lBQ2hDLFdBQVc7SUFDWCxlQUFlO0FBQ25CO0FBQ0E7SUFDSSxrQkFBa0IsRUFBRSxnQkFBZ0I7SUFDcEMsVUFBVSxFQUFFLHlCQUF5QjtJQUNyQyxPQUFPO0lBQ1AsUUFBUTtJQUNSLE1BQU07SUFDTixTQUFTO0FBQ2I7O0FBRUE7SUFDSSxxQkFBcUI7SUFDckIsc0JBQXNCO0lBQ3RCLDBCQUEwQjtJQUMxQixtQ0FBbUM7SUFDbkMsc0NBQXNDO0FBQzFDO0FBQ0E7RUFDRSxJQUFJLHVCQUF1QixDQUFDO0VBQzVCLEtBQUssd0JBQXdCLENBQUM7RUFDOUIsS0FBSyx5QkFBeUIsQ0FBQztFQUMvQixLQUFLLHdCQUF3QixDQUFDO0VBQzlCLEtBQUssd0JBQXdCLENBQUM7RUFDOUIsS0FBSyx1QkFBdUIsQ0FBQztFQUM3QixLQUFLLHVCQUF1QixDQUFDO0FBQy9COztBQUVBO0lBQ0ksa0JBQWtCO0lBQ2xCLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsUUFBUTtJQUNSLGdDQUFnQztJQUNoQyxpQ0FBaUM7SUFDakMsaUJBQWlCO0lBQ2pCLGVBQWU7O0NBRWxCLHlIQUF5SDtDQUN6SCwrSEFBK0g7Q0FDL0gsc0JBQXNCO0NBQ3RCLDZCQUE2QjtDQUM3QixxQkFBcUI7Q0FDckIscUJBQXFCO0NBQ3JCLHNCQUFzQjtDQUN0QixtQ0FBbUM7Q0FDbkMsK0NBQStDO0FBQ2hEO0FBQ0E7Q0FDQztFQUNDLDZCQUE2QjtDQUM5QjtDQUNBO0VBQ0MsNEJBQTRCO0NBQzdCO0FBQ0RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiKiB7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5odG1sLCBib2R5IHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcXG59XFxuYm9keSB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4uY3hfd2ViZ2wge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7IC8qIEZvciB6LWluZGV4ICovXFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgLyogTWF4IHZhbHVlIHRvIGJlIHN1cGVyIHN1cmUgdGhhdCBpdCByZWFsbHkgaXMgb24gdG9wIG9mIGV2ZXJ5dGhpbmcsIGluIGNhc2UgSlMgY3JlYXRlcyBlbGVtZW50cyBvdXRzaWRlIG9mICNqcy1yb290ICovXFxuICAgIHotaW5kZXg6IDIxNDc0ODM2NDc7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgdG91Y2gtYWN0aW9uOiBwYW4teCBwYW4teTsgLyogTW9iaWxlIFNhZmFyaSBkb2Vzbid0IHN1cHBvcnQgXFxcIm5vbmVcXFwiICovXFxufVxcbi5jeF93ZWJnbF9sb2FkZXIge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogNTAlO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICBjb2xvcjogIzY2NjtcXG4gICAgZm9udC1zaXplOiA0MHB4O1xcbn1cXG4janNfcm9vdCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsgLyogRm9yIHotaW5kZXggKi9cXG4gICAgei1pbmRleDogMDsgLyogTmV3IHN0YWNraW5nIGNvbnRleHQgKi9cXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHRvcDogMDtcXG4gICAgYm90dG9tOiAwO1xcbn1cXG5cXG4uY3hfd2ViZ2xfbG9hZGVyID4gc3BhbiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgYW5pbWF0aW9uLW5hbWU6IHdpZ2dsZTtcXG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAxMDAwbXM7XFxuICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXG59XFxuQGtleWZyYW1lcyB3aWdnbGUge1xcbiAgMCUge3RyYW5zZm9ybTogcm90YXRlKDBkZWcpO31cXG4gIDEwJSB7dHJhbnNmb3JtOiByb3RhdGUoMTBkZWcpO31cXG4gIDMwJSB7dHJhbnNmb3JtOiByb3RhdGUoLTEwZGVnKTt9XFxuICA1MCUge3RyYW5zZm9ybTogcm90YXRlKDIwZGVnKTt9XFxuICA3MCUge3RyYW5zZm9ybTogcm90YXRlKC01ZGVnKTt9XFxuICA5MCUge3RyYW5zZm9ybTogcm90YXRlKDJkZWcpO31cXG4gIDk1JSB7dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7fVxcbn1cXG5cXG4uY3hfd2ViZ2xfbG9hZGVyID4gZGl2IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogbWF4LWNvbnRlbnQ7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIDQwcHgpO1xcbiAgICBmb250LWZhbWlseTogVmVyZGFuYSwgQXJpYWwgQmxhY2s7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBmb250LXNpemU6IDI4cHg7XFxuXFxuXFx0YmFja2dyb3VuZDogIzIyMiAtd2Via2l0LWdyYWRpZW50KGxpbmVhciwgbGVmdCB0b3AsIHJpZ2h0IHRvcCwgZnJvbSgjMjIyKSwgdG8oIzIyMiksIGNvbG9yLXN0b3AoMC41LCAjZmZmKSkgMCAwIG5vLXJlcGVhdDtcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCgtNDBkZWcsIHRyYW5zcGFyZW50IDAlLCB0cmFuc3BhcmVudCA0MCUsICNmZmYgNTAlLCB0cmFuc3BhcmVudCA2MCUsIHRyYW5zcGFyZW50IDEwMCUpO1xcblxcdGJhY2tncm91bmQtc2l6ZTogMjAwcHg7XFxuXFx0LXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XFxuXFx0YmFja2dyb3VuZC1jbGlwOiB0ZXh0O1xcblxcdGFuaW1hdGlvbi1uYW1lOiBzaGluZTtcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDFzO1xcblxcdGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcblxcdHRleHQtc2hhZG93OiAwIDBweCAwcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcbn1cXG5Aa2V5ZnJhbWVzIHNoaW5lIHtcXG5cXHQwJSB7XFxuXFx0XFx0YmFja2dyb3VuZC1wb3NpdGlvbjogLTIwMHB4IDA7XFxuXFx0fVxcblxcdDEwMCUge1xcblxcdFxcdGJhY2tncm91bmQtcG9zaXRpb246IDI1MHB4IDA7XFxuXFx0fVxcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./wrf.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzP2FmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/sourceMaps.js\n");

/***/ }),

/***/ "./wrf.css":
/*!*****************!*\
  !*** ./wrf.css ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_wrf_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!./node_modules/css-loader/dist/cjs.js!./wrf.css */ \"./node_modules/css-loader/dist/cjs.js!./wrf.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_wrf_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_wrf_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_wrf_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_wrf_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmYuY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vd3JmLmNzcz9iNmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3dyZi5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vd3JmLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./wrf.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuXG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanM/YjIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcz9kZTZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzP2RkY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzP2U0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cblxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG5cbiAgY3NzICs9IG9iai5jc3M7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzPzFkZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ }),

/***/ "./common.ts":
/*!*******************!*\
  !*** ./common.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rpc\": () => (/* binding */ Rpc),\n/* harmony export */   \"mutexLock\": () => (/* binding */ mutexLock),\n/* harmony export */   \"mutexUnlock\": () => (/* binding */ mutexUnlock),\n/* harmony export */   \"TW_SAB_MUTEX_PTR\": () => (/* binding */ TW_SAB_MUTEX_PTR),\n/* harmony export */   \"TW_SAB_MESSAGE_COUNT_PTR\": () => (/* binding */ TW_SAB_MESSAGE_COUNT_PTR),\n/* harmony export */   \"initTaskWorkerSab\": () => (/* binding */ initTaskWorkerSab),\n/* harmony export */   \"initThreadLocalStorageMainWorker\": () => (/* binding */ initThreadLocalStorageMainWorker),\n/* harmony export */   \"makeThreadLocalStorageAndStackDataOnExistingThread\": () => (/* binding */ makeThreadLocalStorageAndStackDataOnExistingThread),\n/* harmony export */   \"initThreadLocalStorageAndStackOtherWorkers\": () => (/* binding */ initThreadLocalStorageAndStackOtherWorkers),\n/* harmony export */   \"copyArrayToRustBuffer\": () => (/* binding */ copyArrayToRustBuffer),\n/* harmony export */   \"getWrfParamType\": () => (/* binding */ getWrfParamType),\n/* harmony export */   \"createWasmBuffer\": () => (/* binding */ createWasmBuffer),\n/* harmony export */   \"makeZerdeBuilder\": () => (/* binding */ makeZerdeBuilder),\n/* harmony export */   \"getWasmEnv\": () => (/* binding */ getWasmEnv),\n/* harmony export */   \"transformParamsFromRustImpl\": () => (/* binding */ transformParamsFromRustImpl),\n/* harmony export */   \"assertNotNull\": () => (/* binding */ assertNotNull)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n/* harmony import */ var _zerde__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zerde */ \"./zerde.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n\n\n\nconst RESPONSE = \"$$RESPONSE\";\nconst ERROR = \"$$ERROR\";\n// helper function to create linked channels for testing\nfunction _createLinkedChannels() {\n    const local = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (remote.onmessage) {\n                remote.onmessage(ev);\n            }\n        },\n    };\n    const remote = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (local.onmessage) {\n                local.onmessage(ev);\n            }\n        },\n    };\n    return { local, remote };\n}\n// This class allows you to hook up bi-directional async calls across web-worker\n// boundaries where a single call to or from a worker can 'wait' on the response.\n// Errors in receivers are propigated back to the caller as a rejection.\n// It also supports returning transferrables over the web-worker postMessage api,\n// which was the main shortcomming with the worker-rpc npm module.\n// To attach rpc to an instance of a worker in the main thread:\n//   const rpc = new Rpc(workerInstace);\n// To attach rpc within an a web worker:\n//   const rpc = new Rpc(global);\n// Check out the tests for more examples.\n// See `rpc_types.ts` for descriptions of how to set up typed interactions.\nclass Rpc {\n    constructor(channel) {\n        this._messageId = 0;\n        this._pendingCallbacks = {};\n        this._receivers = new Map();\n        this._onChannelMessage = (ev) => {\n            const { id, topic, data } = ev.data;\n            if (topic === RESPONSE) {\n                this._pendingCallbacks[id](ev.data);\n                delete this._pendingCallbacks[id];\n                return;\n            }\n            // invoke the receive handler in a promise so if it throws synchronously we can reject\n            new Promise((resolve) => {\n                const handler = this._receivers.get(topic);\n                if (!handler) {\n                    throw new Error(`no receiver registered for ${topic}`);\n                }\n                // This works both when `handler` returns a value or a Promise.\n                resolve(handler(data));\n            })\n                .then((result) => {\n                if (!result) {\n                    this.postMessage({ topic: RESPONSE, id }, []);\n                    return;\n                }\n                const transferrables = result[Rpc.transferrables];\n                delete result[Rpc.transferrables];\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: result,\n                };\n                this.postMessage(message, transferrables);\n            })\n                .catch((err) => {\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: {\n                        [ERROR]: true,\n                        name: err.name,\n                        message: err.message,\n                        stack: err.stack,\n                    },\n                };\n                this.postMessage(message, []);\n            });\n        };\n        this._channel = channel;\n        if (this._channel.onmessage) {\n            throw new Error(\"channel.onmessage is already set. Can only use one Rpc instance per channel.\");\n        }\n        this._channel.onmessage = this._onChannelMessage;\n    }\n    // send a message across the rpc boundary to a receiver on the other side\n    // this returns a promise for the receiver's response.  If there is no registered\n    // receiver for the given topic, this method throws\n    send(topic, data, transfer) {\n        const id = this._messageId++;\n        const message = { topic, id, data };\n        const result = new Promise((resolve, reject) => {\n            this._pendingCallbacks[id] = (info) => {\n                if (info.data && info.data[ERROR]) {\n                    const error = new Error(info.data.message);\n                    error.name = info.data.name;\n                    error.stack = info.data.stack;\n                    reject(error);\n                }\n                else {\n                    resolve(info.data);\n                }\n            };\n        });\n        this.postMessage(message, transfer);\n        return result;\n    }\n    // register a receiver for a given message on a topic\n    // only one receiver can be registered per topic and currently\n    // 'deregistering' a receiver is not supported since this is not common\n    receive(topic, handler) {\n        if (this._receivers.has(topic)) {\n            throw new Error(`Receiver already registered for topic: ${topic}`);\n        }\n        this._receivers.set(topic, handler);\n    }\n    postMessage(message, transfer) {\n        try {\n            this._channel.postMessage(message, transfer);\n        }\n        catch (e) {\n            console.error(\"Rpc postMessage call itself failed: \", e);\n        }\n    }\n}\nRpc.transferrables = \"$$TRANSFERRABLES\";\n////////////////////////////////////////////////////////////////\n// Mutex\n////////////////////////////////////////////////////////////////\nconst MUTEX_UNLOCKED = 0;\nconst MUTEX_LOCKED = 1;\nconst mutexLock = (sabi32, offset) => {\n    // This needs to be in a loop, because between the `wait` and `compareExchange` another thread might\n    // take the Mutex.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (Atomics.compareExchange(sabi32, offset, MUTEX_UNLOCKED, MUTEX_LOCKED) ==\n            MUTEX_UNLOCKED) {\n            return;\n        }\n        Atomics.wait(sabi32, offset, MUTEX_LOCKED);\n    }\n};\nconst mutexUnlock = (sabi32, offset) => {\n    if (Atomics.compareExchange(sabi32, offset, MUTEX_LOCKED, MUTEX_UNLOCKED) !=\n        MUTEX_LOCKED) {\n        throw new Error(\"Called mutex_unlock on an already unlocked mutex\");\n    }\n    Atomics.notify(sabi32, offset, 1);\n};\n////////////////////////////////////////////////////////////////\n// Task worker\n////////////////////////////////////////////////////////////////\nconst TW_SAB_MUTEX_PTR = 0;\nconst TW_SAB_MESSAGE_COUNT_PTR = 1;\n// Initialize a SharedArrayBuffer used to communicate with task_worker.ts. This\n// is a one-way communication channel; use pointers into `memory` for communicating\n// information back.\n//\n// We use this because we typically can't use `postMessage`; see task_worker.ts\n// for more details.\n//\n// Format:\n// * i32 (4 bytes)         - read/write mutex\n// * i32 (4 bytes)         - number of messages in queue (notify on this to wake up the task worker - it will\n//                           read this before taking a mutex, but then reread it after taking the mutex)\n// * n * u32 (n * 4 bytes) - pointers to messages serialized with `ZerdeBuilder`\nconst initTaskWorkerSab = () => {\n    const bufferSizeBytes = 10000;\n    const taskWorkerSab = new SharedArrayBuffer(bufferSizeBytes);\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    taskWorkerSabi32[TW_SAB_MUTEX_PTR] = MUTEX_UNLOCKED;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = 0;\n    return taskWorkerSab;\n};\n// Append a new message pointer to the SharedArrayBuffer used by task_worker.ts,\n// and wake it up so it can process this new message (unless it's currently in polling\n// mode, in that case the `Atomics.notify` will just not do anything).\nconst sendTaskWorkerMessage = (taskWorkerSab, twMessagePtr) => {\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    mutexLock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    const currentNumberOfMessages = taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR];\n    // Use unsigned numbers for the actual pointer, since they can be >2GB.\n    new Uint32Array(taskWorkerSab)[currentNumberOfMessages + 2] = twMessagePtr;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = currentNumberOfMessages + 1;\n    mutexUnlock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    Atomics.notify(taskWorkerSabi32, 1);\n};\n////////////////////////////////////////////////////////////////\n// Wasm Thread initialization\n////////////////////////////////////////////////////////////////\n// Threads in WebAssembly! They are.. fun! Here's what happens.\n//\n// The first Wasm instance we start is in the main worker. It does the following:\n// - It initializes static memory using `__wasm_init_memory`, which is automatically set\n//   by LLVM as the special \"start\" function.\n// - It already has memory allocated for the \"shadow stack\". This is like any stack in a\n//   native program, but in WebAssembly it's called the \"shadow stack\" because WebAssembly\n//   itself also has a notion of a stack built-in. It is however not suitable for all\n//   kinds of data, which is why we need another separate stack.\n// - We allocate Thread Local Storage (TLS) by allocating some memory on the heap (an\n//   operation which by itself should not require TLS; otherwise we'd have a Catch-22\n//   situation..), and calling `initThreadLocalStorageMainWorker` with it.\n//\n// Then, when we make any other WebAssembly threads (e.g. in our own WebWorkers, or in\n// the WebWorkers of users), we do the following:\n// - `__wasm_init_memory` is again called automatically, but will be skipped, since an\n//   (atomic) flag has been set not to initialize static memory again.\n// - We need to initialize memory for both the shadow stack and the Thread Local\n//   Storage (TLS), using `makeThreadLocalStorageAndStackDataOnExistingThread`. We do this\n//   by allocating memory on the heap on an already initialized thread, since allocating memory DOES\n//   require the shadow stack to be initialized.\n// - We then use this memory for both the TLS (on the lower side) and the shadow stack\n//   (on the upper side, since it moves downward), using `initThreadLocalStorageAndStackOtherWorkers`.\n//\n// TODO(JP): This currently leaks memory since we never deallocate the TLS/shadow stack!\n//\n// TODO(JP): Even if we do deallocate the memory, there is currently no way to call TLS\n// destructors; so we'd still leak memory. See https://github.com/rust-lang/rust/issues/77839\n// The \"shadow stack\" size for new threads. Note that the main thread will\n// keep using its own shadow stack size.\nconst WASM_STACK_SIZE_BYTES = 2 * 1024 * 1024; // 2 MB\n// For the main worker, we only need to initialize Thread Local Storage (TLS).\nconst initThreadLocalStorageMainWorker = (wasmExports) => {\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(wasmExports.__tls_size.value));\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    wasmExports.__wasm_init_tls(Number(ptr));\n};\n// For non-main workers, we need to allocate enough data for Thread Local Storage (TLS)\n// and the \"shadow stack\". We allocate this data in the main worker, and then send the\n// pointer + size to other workers.\n//\n// This is easier than trying to allocate the appropriate amount of data in the other\n// itself, which is possible (e.g. using memory.grow) but kind of cumbersome.\nconst makeThreadLocalStorageAndStackDataOnExistingThread = (wasmExports) => {\n    // Align size to 64 bits / 8 bytes.\n    const size = Math.ceil((wasmExports.__tls_size.value + WASM_STACK_SIZE_BYTES) / 8) * 8;\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(size));\n    return { ptr, size };\n};\n// Set the shadow stack pointer and initialize thet Thread Local Storage (TLS).\n//\n// Note that the TLS sits on the lower side of the memory, wheras the shadow stack\n// starts on the upper side of the memory and grows downwards.\n//\n// TODO(JP): __wasm_init_tls takes a Number, which might not work when it is >2GB.\nconst initThreadLocalStorageAndStackOtherWorkers = (wasmExports, tlsAndStackData) => {\n    // Start the shadow stack pointer on the upper side of the memory, though subtract\n    // 8 so we don't overwrite the byte right after the memory, while still keeping it\n    // 64-bit aligned. TODO(JP): Is the 64-bit alignment necessary for the shadow stack?\n    wasmExports.__stack_pointer.value =\n        Number(tlsAndStackData.ptr) + tlsAndStackData.size - 8;\n    wasmExports.__wasm_init_tls(\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    Number(tlsAndStackData.ptr));\n};\n////////////////////////////////////////////////////////////////\n// Common wasm functions\n////////////////////////////////////////////////////////////////\nconst copyArrayToRustBuffer = (inputBuffer, outputBuffer, outputPtr) => {\n    // should be the same type as inputBuffer\n    // @ts-ignore: constructor is getting typed as Function instead of a constructor\n    new inputBuffer.constructor(outputBuffer, outputPtr, inputBuffer.length).set(inputBuffer);\n};\nconst getWrfParamType = (array, readonly) => {\n    if (array instanceof Uint8Array) {\n        return readonly ? _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyU8Buffer : _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.U8Buffer;\n    }\n    else if (array instanceof Float32Array) {\n        return readonly ? _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyF32Buffer : _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.F32Buffer;\n    }\n    else {\n        throw new Error(\"Invalid array type\");\n    }\n};\nconst createWasmBuffer = (memory, exports, data) => {\n    const vecPtr = Number(exports.allocWasmVec(BigInt(data.byteLength)));\n    copyArrayToRustBuffer(data, memory.buffer, vecPtr);\n    return vecPtr;\n};\nconst makeZerdeBuilder = (memory, wasmExports) => {\n    const slots = 1024;\n    // We have get memory.buffer *after* calling `allocWasmMessage`, because\n    // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n    const byteOffset = Number(wasmExports.allocWasmMessage(BigInt(slots * 4)));\n    return new _zerde__WEBPACK_IMPORTED_MODULE_2__.ZerdeBuilder({\n        buffer: memory.buffer,\n        byteOffset: byteOffset,\n        slots,\n        growCallback: (_buffer, oldByteOffset, newBytes) => {\n            const newByteOffset = Number(wasmExports.reallocWasmMessage(BigInt(oldByteOffset), BigInt(newBytes)));\n            // We have get memory.buffer *after* calling `reallocWasmMessage`, because\n            // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n            return { buffer: memory.buffer, byteOffset: newByteOffset };\n        },\n    });\n};\nconst getWasmEnv = ({ getExports, memory, taskWorkerSab, fileHandles, sendEventFromAnyThread, threadSpawn, baseUri, }) => {\n    const fileReaderSync = new FileReaderSync();\n    const parseString = (ptr, len) => {\n        let out = \"\";\n        // Can't use TextDecoder here since it doesn't work with SharedArrayBuffer.\n        // TODO(JP): If it becomes important enough, we can see if making a copy to a regular\n        // ArrayBuffer and then using TextDecoder is faster than what we do here.\n        const array = new Uint32Array(memory.buffer, ptr, len);\n        for (let i = 0; i < len; i++) {\n            out += String.fromCharCode(array[i]);\n        }\n        return out;\n    };\n    return {\n        memory,\n        _consoleLog: (charsPtr, len, error) => {\n            const out = parseString(parseInt(charsPtr), parseInt(len));\n            if (error) {\n                console.error(out);\n            }\n            else {\n                console.log(out);\n            }\n        },\n        readUserFileRange: (userFileId, bufPtr, bufLen, fileOffset) => {\n            const file = fileHandles[userFileId];\n            const start = Number(fileOffset);\n            const end = start + Number(bufLen);\n            if (file.lastReadStart <= start && start < file.lastReadEnd) {\n                console.warn(`Read start (${start}) fell in the range of the last read (${file.lastReadStart}-${file.lastReadEnd}); ` +\n                    \"this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.\");\n            }\n            file.lastReadStart = start;\n            file.lastReadEnd = end;\n            // TODO(JP): This creates a new buffer instead of reading directly into the wasm memory.\n            // Maybe we can avoid this by using a stream with a ReadableStreamBYOBReader, but that is\n            // asynchronous, so we'd have to do a dance with another thread and atomics and all that,\n            // and I don't know if that overhead would be worth it..\n            const buffer = fileReaderSync.readAsArrayBuffer(file.file.slice(start, end));\n            copyArrayToRustBuffer(new Uint8Array(buffer), memory.buffer, Number(bufPtr));\n            return BigInt(buffer.byteLength);\n        },\n        performanceNow: () => {\n            return performance.now();\n        },\n        threadSpawn: (ctxPtr) => {\n            threadSpawn(ctxPtr);\n        },\n        _sendEventFromAnyThread: (eventPtr) => {\n            sendEventFromAnyThread(eventPtr);\n        },\n        readUrlSync: (urlPtr, urlLen, bufPtrOut, bufLenOut) => {\n            const url = parseString(urlPtr, urlLen);\n            const request = new XMLHttpRequest();\n            request.responseType = \"arraybuffer\";\n            request.open(\"GET\", new URL(url, baseUri).href, false /* synchronous */);\n            request.send(null);\n            if (request.status === 200) {\n                const exports = getExports();\n                const outputBufPtr = createWasmBuffer(memory, exports, new Uint8Array(request.response));\n                new Uint32Array(memory.buffer, bufPtrOut, 1)[0] = outputBufPtr;\n                new Uint32Array(memory.buffer, bufLenOut, 1)[0] =\n                    request.response.byteLength;\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        },\n        randomU64: () => new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],\n        sendTaskWorkerMessage: (twMessagePtr) => {\n            sendTaskWorkerMessage(taskWorkerSab, parseInt(twMessagePtr));\n        },\n    };\n};\nfunction transformParamsFromRustImpl(memory, destructor, mutableDestructor, params) {\n    return params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else {\n            const wrfBuffer = (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.getWrfBufferWasm)(memory, param, destructor, mutableDestructor);\n            if (param.paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.String) {\n                throw new Error(\"WrfParam buffer type called with string paramType\");\n            }\n            // These are actually WrfArray types, since we overwrite TypedArrays in overwriteTypedArraysWithWrfArrays()\n            const ArrayConstructor = {\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.U8Buffer]: Uint8Array,\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyU8Buffer]: Uint8Array,\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.F32Buffer]: Float32Array,\n                [_types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyF32Buffer]: Float32Array,\n            }[param.paramType];\n            return (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.getCachedWrfBuffer)(wrfBuffer, new ArrayConstructor(wrfBuffer, param.bufferPtr, param.bufferLen / ArrayConstructor.BYTES_PER_ELEMENT));\n        }\n    });\n}\nfunction assertNotNull(value, objectName = \"Value\") {\n    if (value === null || value === undefined) {\n        throw new Error(`Assertion failed: ${objectName} is null`);\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21tb24udHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL2NvbW1vbi50cz8yMGIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMS1wcmVzZW50LCBDcnVpc2UgTExDXG4vL1xuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UtQVBBQ0hFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBXcmZQYXJhbVR5cGUsIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGdldENhY2hlZFdyZkJ1ZmZlciwgZ2V0V3JmQnVmZmVyV2FzbSB9IGZyb20gXCIuL3dyZl9idWZmZXJcIjtcbmltcG9ydCB7IFplcmRlQnVpbGRlciB9IGZyb20gXCIuL3plcmRlXCI7XG5jb25zdCBSRVNQT05TRSA9IFwiJCRSRVNQT05TRVwiO1xuY29uc3QgRVJST1IgPSBcIiQkRVJST1JcIjtcbi8vIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbGlua2VkIGNoYW5uZWxzIGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBfY3JlYXRlTGlua2VkQ2hhbm5lbHMoKSB7XG4gICAgY29uc3QgbG9jYWwgPSB7XG4gICAgICAgIG9ubWVzc2FnZSxcbiAgICAgICAgcG9zdE1lc3NhZ2UoZGF0YSwgX3RyYW5zZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBldiA9IG5ldyBNZXNzYWdlRXZlbnQoXCJtZXNzYWdlXCIsIHsgZGF0YSB9KTtcbiAgICAgICAgICAgIGlmIChyZW1vdGUub25tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlLm9ubWVzc2FnZShldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCByZW1vdGUgPSB7XG4gICAgICAgIG9ubWVzc2FnZSxcbiAgICAgICAgcG9zdE1lc3NhZ2UoZGF0YSwgX3RyYW5zZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBldiA9IG5ldyBNZXNzYWdlRXZlbnQoXCJtZXNzYWdlXCIsIHsgZGF0YSB9KTtcbiAgICAgICAgICAgIGlmIChsb2NhbC5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBsb2NhbC5vbm1lc3NhZ2UoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHsgbG9jYWwsIHJlbW90ZSB9O1xufVxuLy8gVGhpcyBjbGFzcyBhbGxvd3MgeW91IHRvIGhvb2sgdXAgYmktZGlyZWN0aW9uYWwgYXN5bmMgY2FsbHMgYWNyb3NzIHdlYi13b3JrZXJcbi8vIGJvdW5kYXJpZXMgd2hlcmUgYSBzaW5nbGUgY2FsbCB0byBvciBmcm9tIGEgd29ya2VyIGNhbiAnd2FpdCcgb24gdGhlIHJlc3BvbnNlLlxuLy8gRXJyb3JzIGluIHJlY2VpdmVycyBhcmUgcHJvcGlnYXRlZCBiYWNrIHRvIHRoZSBjYWxsZXIgYXMgYSByZWplY3Rpb24uXG4vLyBJdCBhbHNvIHN1cHBvcnRzIHJldHVybmluZyB0cmFuc2ZlcnJhYmxlcyBvdmVyIHRoZSB3ZWItd29ya2VyIHBvc3RNZXNzYWdlIGFwaSxcbi8vIHdoaWNoIHdhcyB0aGUgbWFpbiBzaG9ydGNvbW1pbmcgd2l0aCB0aGUgd29ya2VyLXJwYyBucG0gbW9kdWxlLlxuLy8gVG8gYXR0YWNoIHJwYyB0byBhbiBpbnN0YW5jZSBvZiBhIHdvcmtlciBpbiB0aGUgbWFpbiB0aHJlYWQ6XG4vLyAgIGNvbnN0IHJwYyA9IG5ldyBScGMod29ya2VySW5zdGFjZSk7XG4vLyBUbyBhdHRhY2ggcnBjIHdpdGhpbiBhbiBhIHdlYiB3b3JrZXI6XG4vLyAgIGNvbnN0IHJwYyA9IG5ldyBScGMoZ2xvYmFsKTtcbi8vIENoZWNrIG91dCB0aGUgdGVzdHMgZm9yIG1vcmUgZXhhbXBsZXMuXG4vLyBTZWUgYHJwY190eXBlcy50c2AgZm9yIGRlc2NyaXB0aW9ucyBvZiBob3cgdG8gc2V0IHVwIHR5cGVkIGludGVyYWN0aW9ucy5cbmV4cG9ydCBjbGFzcyBScGMge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUlkID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl9yZWNlaXZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX29uQ2hhbm5lbE1lc3NhZ2UgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHRvcGljLCBkYXRhIH0gPSBldi5kYXRhO1xuICAgICAgICAgICAgaWYgKHRvcGljID09PSBSRVNQT05TRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3NbaWRdKGV2LmRhdGEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzW2lkXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbnZva2UgdGhlIHJlY2VpdmUgaGFuZGxlciBpbiBhIHByb21pc2Ugc28gaWYgaXQgdGhyb3dzIHN5bmNocm9ub3VzbHkgd2UgY2FuIHJlamVjdFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcmVjZWl2ZXJzLmdldCh0b3BpYyk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gcmVjZWl2ZXIgcmVnaXN0ZXJlZCBmb3IgJHt0b3BpY31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3b3JrcyBib3RoIHdoZW4gYGhhbmRsZXJgIHJldHVybnMgYSB2YWx1ZSBvciBhIFByb21pc2UuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShoYW5kbGVyKGRhdGEpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2UoeyB0b3BpYzogUkVTUE9OU0UsIGlkIH0sIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlcnJhYmxlcyA9IHJlc3VsdFtScGMudHJhbnNmZXJyYWJsZXNdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbUnBjLnRyYW5zZmVycmFibGVzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3BpYzogUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycmFibGVzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3BpYzogUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbRVJST1JdOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXJyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiBlcnIuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFtdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5uZWwub25tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFubmVsLm9ubWVzc2FnZSBpcyBhbHJlYWR5IHNldC4gQ2FuIG9ubHkgdXNlIG9uZSBScGMgaW5zdGFuY2UgcGVyIGNoYW5uZWwuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5uZWwub25tZXNzYWdlID0gdGhpcy5fb25DaGFubmVsTWVzc2FnZTtcbiAgICB9XG4gICAgLy8gc2VuZCBhIG1lc3NhZ2UgYWNyb3NzIHRoZSBycGMgYm91bmRhcnkgdG8gYSByZWNlaXZlciBvbiB0aGUgb3RoZXIgc2lkZVxuICAgIC8vIHRoaXMgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZWNlaXZlcidzIHJlc3BvbnNlLiAgSWYgdGhlcmUgaXMgbm8gcmVnaXN0ZXJlZFxuICAgIC8vIHJlY2VpdmVyIGZvciB0aGUgZ2l2ZW4gdG9waWMsIHRoaXMgbWV0aG9kIHRocm93c1xuICAgIHNlbmQodG9waWMsIGRhdGEsIHRyYW5zZmVyKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fbWVzc2FnZUlkKys7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7IHRvcGljLCBpZCwgZGF0YSB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzW2lkXSA9IChpbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uZGF0YSAmJiBpbmZvLmRhdGFbRVJST1JdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGluZm8uZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IGluZm8uZGF0YS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IGluZm8uZGF0YS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW5mby5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIHJlZ2lzdGVyIGEgcmVjZWl2ZXIgZm9yIGEgZ2l2ZW4gbWVzc2FnZSBvbiBhIHRvcGljXG4gICAgLy8gb25seSBvbmUgcmVjZWl2ZXIgY2FuIGJlIHJlZ2lzdGVyZWQgcGVyIHRvcGljIGFuZCBjdXJyZW50bHlcbiAgICAvLyAnZGVyZWdpc3RlcmluZycgYSByZWNlaXZlciBpcyBub3Qgc3VwcG9ydGVkIHNpbmNlIHRoaXMgaXMgbm90IGNvbW1vblxuICAgIHJlY2VpdmUodG9waWMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlY2VpdmVycy5oYXModG9waWMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVyIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgdG9waWM6ICR7dG9waWN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjZWl2ZXJzLnNldCh0b3BpYywgaGFuZGxlcik7XG4gICAgfVxuICAgIHBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFubmVsLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlJwYyBwb3N0TWVzc2FnZSBjYWxsIGl0c2VsZiBmYWlsZWQ6IFwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblJwYy50cmFuc2ZlcnJhYmxlcyA9IFwiJCRUUkFOU0ZFUlJBQkxFU1wiO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTXV0ZXhcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IE1VVEVYX1VOTE9DS0VEID0gMDtcbmNvbnN0IE1VVEVYX0xPQ0tFRCA9IDE7XG5leHBvcnQgY29uc3QgbXV0ZXhMb2NrID0gKHNhYmkzMiwgb2Zmc2V0KSA9PiB7XG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBpbiBhIGxvb3AsIGJlY2F1c2UgYmV0d2VlbiB0aGUgYHdhaXRgIGFuZCBgY29tcGFyZUV4Y2hhbmdlYCBhbm90aGVyIHRocmVhZCBtaWdodFxuICAgIC8vIHRha2UgdGhlIE11dGV4LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoQXRvbWljcy5jb21wYXJlRXhjaGFuZ2Uoc2FiaTMyLCBvZmZzZXQsIE1VVEVYX1VOTE9DS0VELCBNVVRFWF9MT0NLRUQpID09XG4gICAgICAgICAgICBNVVRFWF9VTkxPQ0tFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEF0b21pY3Mud2FpdChzYWJpMzIsIG9mZnNldCwgTVVURVhfTE9DS0VEKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG11dGV4VW5sb2NrID0gKHNhYmkzMiwgb2Zmc2V0KSA9PiB7XG4gICAgaWYgKEF0b21pY3MuY29tcGFyZUV4Y2hhbmdlKHNhYmkzMiwgb2Zmc2V0LCBNVVRFWF9MT0NLRUQsIE1VVEVYX1VOTE9DS0VEKSAhPVxuICAgICAgICBNVVRFWF9MT0NLRUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIG11dGV4X3VubG9jayBvbiBhbiBhbHJlYWR5IHVubG9ja2VkIG11dGV4XCIpO1xuICAgIH1cbiAgICBBdG9taWNzLm5vdGlmeShzYWJpMzIsIG9mZnNldCwgMSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVGFzayB3b3JrZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjb25zdCBUV19TQUJfTVVURVhfUFRSID0gMDtcbmV4cG9ydCBjb25zdCBUV19TQUJfTUVTU0FHRV9DT1VOVF9QVFIgPSAxO1xuLy8gSW5pdGlhbGl6ZSBhIFNoYXJlZEFycmF5QnVmZmVyIHVzZWQgdG8gY29tbXVuaWNhdGUgd2l0aCB0YXNrX3dvcmtlci50cy4gVGhpc1xuLy8gaXMgYSBvbmUtd2F5IGNvbW11bmljYXRpb24gY2hhbm5lbDsgdXNlIHBvaW50ZXJzIGludG8gYG1lbW9yeWAgZm9yIGNvbW11bmljYXRpbmdcbi8vIGluZm9ybWF0aW9uIGJhY2suXG4vL1xuLy8gV2UgdXNlIHRoaXMgYmVjYXVzZSB3ZSB0eXBpY2FsbHkgY2FuJ3QgdXNlIGBwb3N0TWVzc2FnZWA7IHNlZSB0YXNrX3dvcmtlci50c1xuLy8gZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBGb3JtYXQ6XG4vLyAqIGkzMiAoNCBieXRlcykgICAgICAgICAtIHJlYWQvd3JpdGUgbXV0ZXhcbi8vICogaTMyICg0IGJ5dGVzKSAgICAgICAgIC0gbnVtYmVyIG9mIG1lc3NhZ2VzIGluIHF1ZXVlIChub3RpZnkgb24gdGhpcyB0byB3YWtlIHVwIHRoZSB0YXNrIHdvcmtlciAtIGl0IHdpbGxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZCB0aGlzIGJlZm9yZSB0YWtpbmcgYSBtdXRleCwgYnV0IHRoZW4gcmVyZWFkIGl0IGFmdGVyIHRha2luZyB0aGUgbXV0ZXgpXG4vLyAqIG4gKiB1MzIgKG4gKiA0IGJ5dGVzKSAtIHBvaW50ZXJzIHRvIG1lc3NhZ2VzIHNlcmlhbGl6ZWQgd2l0aCBgWmVyZGVCdWlsZGVyYFxuZXhwb3J0IGNvbnN0IGluaXRUYXNrV29ya2VyU2FiID0gKCkgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlclNpemVCeXRlcyA9IDEwMDAwO1xuICAgIGNvbnN0IHRhc2tXb3JrZXJTYWIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoYnVmZmVyU2l6ZUJ5dGVzKTtcbiAgICBjb25zdCB0YXNrV29ya2VyU2FiaTMyID0gbmV3IEludDMyQXJyYXkodGFza1dvcmtlclNhYik7XG4gICAgdGFza1dvcmtlclNhYmkzMltUV19TQUJfTVVURVhfUFRSXSA9IE1VVEVYX1VOTE9DS0VEO1xuICAgIHRhc2tXb3JrZXJTYWJpMzJbVFdfU0FCX01FU1NBR0VfQ09VTlRfUFRSXSA9IDA7XG4gICAgcmV0dXJuIHRhc2tXb3JrZXJTYWI7XG59O1xuLy8gQXBwZW5kIGEgbmV3IG1lc3NhZ2UgcG9pbnRlciB0byB0aGUgU2hhcmVkQXJyYXlCdWZmZXIgdXNlZCBieSB0YXNrX3dvcmtlci50cyxcbi8vIGFuZCB3YWtlIGl0IHVwIHNvIGl0IGNhbiBwcm9jZXNzIHRoaXMgbmV3IG1lc3NhZ2UgKHVubGVzcyBpdCdzIGN1cnJlbnRseSBpbiBwb2xsaW5nXG4vLyBtb2RlLCBpbiB0aGF0IGNhc2UgdGhlIGBBdG9taWNzLm5vdGlmeWAgd2lsbCBqdXN0IG5vdCBkbyBhbnl0aGluZykuXG5jb25zdCBzZW5kVGFza1dvcmtlck1lc3NhZ2UgPSAodGFza1dvcmtlclNhYiwgdHdNZXNzYWdlUHRyKSA9PiB7XG4gICAgY29uc3QgdGFza1dvcmtlclNhYmkzMiA9IG5ldyBJbnQzMkFycmF5KHRhc2tXb3JrZXJTYWIpO1xuICAgIG11dGV4TG9jayh0YXNrV29ya2VyU2FiaTMyLCBUV19TQUJfTVVURVhfUFRSKTtcbiAgICBjb25zdCBjdXJyZW50TnVtYmVyT2ZNZXNzYWdlcyA9IHRhc2tXb3JrZXJTYWJpMzJbVFdfU0FCX01FU1NBR0VfQ09VTlRfUFRSXTtcbiAgICAvLyBVc2UgdW5zaWduZWQgbnVtYmVycyBmb3IgdGhlIGFjdHVhbCBwb2ludGVyLCBzaW5jZSB0aGV5IGNhbiBiZSA+MkdCLlxuICAgIG5ldyBVaW50MzJBcnJheSh0YXNrV29ya2VyU2FiKVtjdXJyZW50TnVtYmVyT2ZNZXNzYWdlcyArIDJdID0gdHdNZXNzYWdlUHRyO1xuICAgIHRhc2tXb3JrZXJTYWJpMzJbVFdfU0FCX01FU1NBR0VfQ09VTlRfUFRSXSA9IGN1cnJlbnROdW1iZXJPZk1lc3NhZ2VzICsgMTtcbiAgICBtdXRleFVubG9jayh0YXNrV29ya2VyU2FiaTMyLCBUV19TQUJfTVVURVhfUFRSKTtcbiAgICBBdG9taWNzLm5vdGlmeSh0YXNrV29ya2VyU2FiaTMyLCAxKTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXYXNtIFRocmVhZCBpbml0aWFsaXphdGlvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVGhyZWFkcyBpbiBXZWJBc3NlbWJseSEgVGhleSBhcmUuLiBmdW4hIEhlcmUncyB3aGF0IGhhcHBlbnMuXG4vL1xuLy8gVGhlIGZpcnN0IFdhc20gaW5zdGFuY2Ugd2Ugc3RhcnQgaXMgaW4gdGhlIG1haW4gd29ya2VyLiBJdCBkb2VzIHRoZSBmb2xsb3dpbmc6XG4vLyAtIEl0IGluaXRpYWxpemVzIHN0YXRpYyBtZW1vcnkgdXNpbmcgYF9fd2FzbV9pbml0X21lbW9yeWAsIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgc2V0XG4vLyAgIGJ5IExMVk0gYXMgdGhlIHNwZWNpYWwgXCJzdGFydFwiIGZ1bmN0aW9uLlxuLy8gLSBJdCBhbHJlYWR5IGhhcyBtZW1vcnkgYWxsb2NhdGVkIGZvciB0aGUgXCJzaGFkb3cgc3RhY2tcIi4gVGhpcyBpcyBsaWtlIGFueSBzdGFjayBpbiBhXG4vLyAgIG5hdGl2ZSBwcm9ncmFtLCBidXQgaW4gV2ViQXNzZW1ibHkgaXQncyBjYWxsZWQgdGhlIFwic2hhZG93IHN0YWNrXCIgYmVjYXVzZSBXZWJBc3NlbWJseVxuLy8gICBpdHNlbGYgYWxzbyBoYXMgYSBub3Rpb24gb2YgYSBzdGFjayBidWlsdC1pbi4gSXQgaXMgaG93ZXZlciBub3Qgc3VpdGFibGUgZm9yIGFsbFxuLy8gICBraW5kcyBvZiBkYXRhLCB3aGljaCBpcyB3aHkgd2UgbmVlZCBhbm90aGVyIHNlcGFyYXRlIHN0YWNrLlxuLy8gLSBXZSBhbGxvY2F0ZSBUaHJlYWQgTG9jYWwgU3RvcmFnZSAoVExTKSBieSBhbGxvY2F0aW5nIHNvbWUgbWVtb3J5IG9uIHRoZSBoZWFwIChhblxuLy8gICBvcGVyYXRpb24gd2hpY2ggYnkgaXRzZWxmIHNob3VsZCBub3QgcmVxdWlyZSBUTFM7IG90aGVyd2lzZSB3ZSdkIGhhdmUgYSBDYXRjaC0yMlxuLy8gICBzaXR1YXRpb24uLiksIGFuZCBjYWxsaW5nIGBpbml0VGhyZWFkTG9jYWxTdG9yYWdlTWFpbldvcmtlcmAgd2l0aCBpdC5cbi8vXG4vLyBUaGVuLCB3aGVuIHdlIG1ha2UgYW55IG90aGVyIFdlYkFzc2VtYmx5IHRocmVhZHMgKGUuZy4gaW4gb3VyIG93biBXZWJXb3JrZXJzLCBvciBpblxuLy8gdGhlIFdlYldvcmtlcnMgb2YgdXNlcnMpLCB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gLSBgX193YXNtX2luaXRfbWVtb3J5YCBpcyBhZ2FpbiBjYWxsZWQgYXV0b21hdGljYWxseSwgYnV0IHdpbGwgYmUgc2tpcHBlZCwgc2luY2UgYW5cbi8vICAgKGF0b21pYykgZmxhZyBoYXMgYmVlbiBzZXQgbm90IHRvIGluaXRpYWxpemUgc3RhdGljIG1lbW9yeSBhZ2Fpbi5cbi8vIC0gV2UgbmVlZCB0byBpbml0aWFsaXplIG1lbW9yeSBmb3IgYm90aCB0aGUgc2hhZG93IHN0YWNrIGFuZCB0aGUgVGhyZWFkIExvY2FsXG4vLyAgIFN0b3JhZ2UgKFRMUyksIHVzaW5nIGBtYWtlVGhyZWFkTG9jYWxTdG9yYWdlQW5kU3RhY2tEYXRhT25FeGlzdGluZ1RocmVhZGAuIFdlIGRvIHRoaXNcbi8vICAgYnkgYWxsb2NhdGluZyBtZW1vcnkgb24gdGhlIGhlYXAgb24gYW4gYWxyZWFkeSBpbml0aWFsaXplZCB0aHJlYWQsIHNpbmNlIGFsbG9jYXRpbmcgbWVtb3J5IERPRVNcbi8vICAgcmVxdWlyZSB0aGUgc2hhZG93IHN0YWNrIHRvIGJlIGluaXRpYWxpemVkLlxuLy8gLSBXZSB0aGVuIHVzZSB0aGlzIG1lbW9yeSBmb3IgYm90aCB0aGUgVExTIChvbiB0aGUgbG93ZXIgc2lkZSkgYW5kIHRoZSBzaGFkb3cgc3RhY2tcbi8vICAgKG9uIHRoZSB1cHBlciBzaWRlLCBzaW5jZSBpdCBtb3ZlcyBkb3dud2FyZCksIHVzaW5nIGBpbml0VGhyZWFkTG9jYWxTdG9yYWdlQW5kU3RhY2tPdGhlcldvcmtlcnNgLlxuLy9cbi8vIFRPRE8oSlApOiBUaGlzIGN1cnJlbnRseSBsZWFrcyBtZW1vcnkgc2luY2Ugd2UgbmV2ZXIgZGVhbGxvY2F0ZSB0aGUgVExTL3NoYWRvdyBzdGFjayFcbi8vXG4vLyBUT0RPKEpQKTogRXZlbiBpZiB3ZSBkbyBkZWFsbG9jYXRlIHRoZSBtZW1vcnksIHRoZXJlIGlzIGN1cnJlbnRseSBubyB3YXkgdG8gY2FsbCBUTFNcbi8vIGRlc3RydWN0b3JzOyBzbyB3ZSdkIHN0aWxsIGxlYWsgbWVtb3J5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9ydXN0L2lzc3Vlcy83NzgzOVxuLy8gVGhlIFwic2hhZG93IHN0YWNrXCIgc2l6ZSBmb3IgbmV3IHRocmVhZHMuIE5vdGUgdGhhdCB0aGUgbWFpbiB0aHJlYWQgd2lsbFxuLy8ga2VlcCB1c2luZyBpdHMgb3duIHNoYWRvdyBzdGFjayBzaXplLlxuY29uc3QgV0FTTV9TVEFDS19TSVpFX0JZVEVTID0gMiAqIDEwMjQgKiAxMDI0OyAvLyAyIE1CXG4vLyBGb3IgdGhlIG1haW4gd29ya2VyLCB3ZSBvbmx5IG5lZWQgdG8gaW5pdGlhbGl6ZSBUaHJlYWQgTG9jYWwgU3RvcmFnZSAoVExTKS5cbmV4cG9ydCBjb25zdCBpbml0VGhyZWFkTG9jYWxTdG9yYWdlTWFpbldvcmtlciA9ICh3YXNtRXhwb3J0cykgPT4ge1xuICAgIC8vIE5vdGUgdGhhdCBhbGxvY1dhc21NZXNzYWdlIGFsd2F5cyBhbGlnbnMgdG8gNjQgYml0cyAvIDggYnl0ZXMuXG4gICAgY29uc3QgcHRyID0gd2FzbUV4cG9ydHMuYWxsb2NXYXNtTWVzc2FnZShCaWdJbnQod2FzbUV4cG9ydHMuX190bHNfc2l6ZS52YWx1ZSkpO1xuICAgIC8vIFRPRE8oSlApOiBDYXN0IHRvIE51bWJlciBjYW4gY2F1c2UgdHJvdWJsZSA+MkdCLlxuICAgIHdhc21FeHBvcnRzLl9fd2FzbV9pbml0X3RscyhOdW1iZXIocHRyKSk7XG59O1xuLy8gRm9yIG5vbi1tYWluIHdvcmtlcnMsIHdlIG5lZWQgdG8gYWxsb2NhdGUgZW5vdWdoIGRhdGEgZm9yIFRocmVhZCBMb2NhbCBTdG9yYWdlIChUTFMpXG4vLyBhbmQgdGhlIFwic2hhZG93IHN0YWNrXCIuIFdlIGFsbG9jYXRlIHRoaXMgZGF0YSBpbiB0aGUgbWFpbiB3b3JrZXIsIGFuZCB0aGVuIHNlbmQgdGhlXG4vLyBwb2ludGVyICsgc2l6ZSB0byBvdGhlciB3b3JrZXJzLlxuLy9cbi8vIFRoaXMgaXMgZWFzaWVyIHRoYW4gdHJ5aW5nIHRvIGFsbG9jYXRlIHRoZSBhcHByb3ByaWF0ZSBhbW91bnQgb2YgZGF0YSBpbiB0aGUgb3RoZXJcbi8vIGl0c2VsZiwgd2hpY2ggaXMgcG9zc2libGUgKGUuZy4gdXNpbmcgbWVtb3J5Lmdyb3cpIGJ1dCBraW5kIG9mIGN1bWJlcnNvbWUuXG5leHBvcnQgY29uc3QgbWFrZVRocmVhZExvY2FsU3RvcmFnZUFuZFN0YWNrRGF0YU9uRXhpc3RpbmdUaHJlYWQgPSAod2FzbUV4cG9ydHMpID0+IHtcbiAgICAvLyBBbGlnbiBzaXplIHRvIDY0IGJpdHMgLyA4IGJ5dGVzLlxuICAgIGNvbnN0IHNpemUgPSBNYXRoLmNlaWwoKHdhc21FeHBvcnRzLl9fdGxzX3NpemUudmFsdWUgKyBXQVNNX1NUQUNLX1NJWkVfQllURVMpIC8gOCkgKiA4O1xuICAgIC8vIE5vdGUgdGhhdCBhbGxvY1dhc21NZXNzYWdlIGFsd2F5cyBhbGlnbnMgdG8gNjQgYml0cyAvIDggYnl0ZXMuXG4gICAgY29uc3QgcHRyID0gd2FzbUV4cG9ydHMuYWxsb2NXYXNtTWVzc2FnZShCaWdJbnQoc2l6ZSkpO1xuICAgIHJldHVybiB7IHB0ciwgc2l6ZSB9O1xufTtcbi8vIFNldCB0aGUgc2hhZG93IHN0YWNrIHBvaW50ZXIgYW5kIGluaXRpYWxpemUgdGhldCBUaHJlYWQgTG9jYWwgU3RvcmFnZSAoVExTKS5cbi8vXG4vLyBOb3RlIHRoYXQgdGhlIFRMUyBzaXRzIG9uIHRoZSBsb3dlciBzaWRlIG9mIHRoZSBtZW1vcnksIHdoZXJhcyB0aGUgc2hhZG93IHN0YWNrXG4vLyBzdGFydHMgb24gdGhlIHVwcGVyIHNpZGUgb2YgdGhlIG1lbW9yeSBhbmQgZ3Jvd3MgZG93bndhcmRzLlxuLy9cbi8vIFRPRE8oSlApOiBfX3dhc21faW5pdF90bHMgdGFrZXMgYSBOdW1iZXIsIHdoaWNoIG1pZ2h0IG5vdCB3b3JrIHdoZW4gaXQgaXMgPjJHQi5cbmV4cG9ydCBjb25zdCBpbml0VGhyZWFkTG9jYWxTdG9yYWdlQW5kU3RhY2tPdGhlcldvcmtlcnMgPSAod2FzbUV4cG9ydHMsIHRsc0FuZFN0YWNrRGF0YSkgPT4ge1xuICAgIC8vIFN0YXJ0IHRoZSBzaGFkb3cgc3RhY2sgcG9pbnRlciBvbiB0aGUgdXBwZXIgc2lkZSBvZiB0aGUgbWVtb3J5LCB0aG91Z2ggc3VidHJhY3RcbiAgICAvLyA4IHNvIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgYnl0ZSByaWdodCBhZnRlciB0aGUgbWVtb3J5LCB3aGlsZSBzdGlsbCBrZWVwaW5nIGl0XG4gICAgLy8gNjQtYml0IGFsaWduZWQuIFRPRE8oSlApOiBJcyB0aGUgNjQtYml0IGFsaWdubWVudCBuZWNlc3NhcnkgZm9yIHRoZSBzaGFkb3cgc3RhY2s/XG4gICAgd2FzbUV4cG9ydHMuX19zdGFja19wb2ludGVyLnZhbHVlID1cbiAgICAgICAgTnVtYmVyKHRsc0FuZFN0YWNrRGF0YS5wdHIpICsgdGxzQW5kU3RhY2tEYXRhLnNpemUgLSA4O1xuICAgIHdhc21FeHBvcnRzLl9fd2FzbV9pbml0X3RscyhcbiAgICAvLyBUT0RPKEpQKTogQ2FzdCB0byBOdW1iZXIgY2FuIGNhdXNlIHRyb3VibGUgPjJHQi5cbiAgICBOdW1iZXIodGxzQW5kU3RhY2tEYXRhLnB0cikpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENvbW1vbiB3YXNtIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGNvcHlBcnJheVRvUnVzdEJ1ZmZlciA9IChpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBvdXRwdXRQdHIpID0+IHtcbiAgICAvLyBzaG91bGQgYmUgdGhlIHNhbWUgdHlwZSBhcyBpbnB1dEJ1ZmZlclxuICAgIC8vIEB0cy1pZ25vcmU6IGNvbnN0cnVjdG9yIGlzIGdldHRpbmcgdHlwZWQgYXMgRnVuY3Rpb24gaW5zdGVhZCBvZiBhIGNvbnN0cnVjdG9yXG4gICAgbmV3IGlucHV0QnVmZmVyLmNvbnN0cnVjdG9yKG91dHB1dEJ1ZmZlciwgb3V0cHV0UHRyLCBpbnB1dEJ1ZmZlci5sZW5ndGgpLnNldChpbnB1dEJ1ZmZlcik7XG59O1xuZXhwb3J0IGNvbnN0IGdldFdyZlBhcmFtVHlwZSA9IChhcnJheSwgcmVhZG9ubHkpID0+IHtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiByZWFkb25seSA/IFdyZlBhcmFtVHlwZS5SZWFkT25seVU4QnVmZmVyIDogV3JmUGFyYW1UeXBlLlU4QnVmZmVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgICByZXR1cm4gcmVhZG9ubHkgPyBXcmZQYXJhbVR5cGUuUmVhZE9ubHlGMzJCdWZmZXIgOiBXcmZQYXJhbVR5cGUuRjMyQnVmZmVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcnJheSB0eXBlXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgY3JlYXRlV2FzbUJ1ZmZlciA9IChtZW1vcnksIGV4cG9ydHMsIGRhdGEpID0+IHtcbiAgICBjb25zdCB2ZWNQdHIgPSBOdW1iZXIoZXhwb3J0cy5hbGxvY1dhc21WZWMoQmlnSW50KGRhdGEuYnl0ZUxlbmd0aCkpKTtcbiAgICBjb3B5QXJyYXlUb1J1c3RCdWZmZXIoZGF0YSwgbWVtb3J5LmJ1ZmZlciwgdmVjUHRyKTtcbiAgICByZXR1cm4gdmVjUHRyO1xufTtcbmV4cG9ydCBjb25zdCBtYWtlWmVyZGVCdWlsZGVyID0gKG1lbW9yeSwgd2FzbUV4cG9ydHMpID0+IHtcbiAgICBjb25zdCBzbG90cyA9IDEwMjQ7XG4gICAgLy8gV2UgaGF2ZSBnZXQgbWVtb3J5LmJ1ZmZlciAqYWZ0ZXIqIGNhbGxpbmcgYGFsbG9jV2FzbU1lc3NhZ2VgLCBiZWNhdXNlXG4gICAgLy8gdGhlcmUncyBhIGdvb2QgY2hhbmNlIGl0J2xsIGdldCBzd2FwcGVkIG91dCAoaWYgaXQgbmVlZGVkIHRvIGdyb3cgdGhlIGJ1ZmZlcikuXG4gICAgY29uc3QgYnl0ZU9mZnNldCA9IE51bWJlcih3YXNtRXhwb3J0cy5hbGxvY1dhc21NZXNzYWdlKEJpZ0ludChzbG90cyAqIDQpKSk7XG4gICAgcmV0dXJuIG5ldyBaZXJkZUJ1aWxkZXIoe1xuICAgICAgICBidWZmZXI6IG1lbW9yeS5idWZmZXIsXG4gICAgICAgIGJ5dGVPZmZzZXQ6IGJ5dGVPZmZzZXQsXG4gICAgICAgIHNsb3RzLFxuICAgICAgICBncm93Q2FsbGJhY2s6IChfYnVmZmVyLCBvbGRCeXRlT2Zmc2V0LCBuZXdCeXRlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Qnl0ZU9mZnNldCA9IE51bWJlcih3YXNtRXhwb3J0cy5yZWFsbG9jV2FzbU1lc3NhZ2UoQmlnSW50KG9sZEJ5dGVPZmZzZXQpLCBCaWdJbnQobmV3Qnl0ZXMpKSk7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGdldCBtZW1vcnkuYnVmZmVyICphZnRlciogY2FsbGluZyBgcmVhbGxvY1dhc21NZXNzYWdlYCwgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhlcmUncyBhIGdvb2QgY2hhbmNlIGl0J2xsIGdldCBzd2FwcGVkIG91dCAoaWYgaXQgbmVlZGVkIHRvIGdyb3cgdGhlIGJ1ZmZlcikuXG4gICAgICAgICAgICByZXR1cm4geyBidWZmZXI6IG1lbW9yeS5idWZmZXIsIGJ5dGVPZmZzZXQ6IG5ld0J5dGVPZmZzZXQgfTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgZ2V0V2FzbUVudiA9ICh7IGdldEV4cG9ydHMsIG1lbW9yeSwgdGFza1dvcmtlclNhYiwgZmlsZUhhbmRsZXMsIHNlbmRFdmVudEZyb21BbnlUaHJlYWQsIHRocmVhZFNwYXduLCBiYXNlVXJpLCB9KSA9PiB7XG4gICAgY29uc3QgZmlsZVJlYWRlclN5bmMgPSBuZXcgRmlsZVJlYWRlclN5bmMoKTtcbiAgICBjb25zdCBwYXJzZVN0cmluZyA9IChwdHIsIGxlbikgPT4ge1xuICAgICAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICAgICAgLy8gQ2FuJ3QgdXNlIFRleHREZWNvZGVyIGhlcmUgc2luY2UgaXQgZG9lc24ndCB3b3JrIHdpdGggU2hhcmVkQXJyYXlCdWZmZXIuXG4gICAgICAgIC8vIFRPRE8oSlApOiBJZiBpdCBiZWNvbWVzIGltcG9ydGFudCBlbm91Z2gsIHdlIGNhbiBzZWUgaWYgbWFraW5nIGEgY29weSB0byBhIHJlZ3VsYXJcbiAgICAgICAgLy8gQXJyYXlCdWZmZXIgYW5kIHRoZW4gdXNpbmcgVGV4dERlY29kZXIgaXMgZmFzdGVyIHRoYW4gd2hhdCB3ZSBkbyBoZXJlLlxuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCBwdHIsIGxlbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVtb3J5LFxuICAgICAgICBfY29uc29sZUxvZzogKGNoYXJzUHRyLCBsZW4sIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdXQgPSBwYXJzZVN0cmluZyhwYXJzZUludChjaGFyc1B0ciksIHBhcnNlSW50KGxlbikpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cob3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZFVzZXJGaWxlUmFuZ2U6ICh1c2VyRmlsZUlkLCBidWZQdHIsIGJ1ZkxlbiwgZmlsZU9mZnNldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVIYW5kbGVzW3VzZXJGaWxlSWRdO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBOdW1iZXIoZmlsZU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIE51bWJlcihidWZMZW4pO1xuICAgICAgICAgICAgaWYgKGZpbGUubGFzdFJlYWRTdGFydCA8PSBzdGFydCAmJiBzdGFydCA8IGZpbGUubGFzdFJlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJlYWQgc3RhcnQgKCR7c3RhcnR9KSBmZWxsIGluIHRoZSByYW5nZSBvZiB0aGUgbGFzdCByZWFkICgke2ZpbGUubGFzdFJlYWRTdGFydH0tJHtmaWxlLmxhc3RSZWFkRW5kfSk7IGAgK1xuICAgICAgICAgICAgICAgICAgICBcInRoaXMgdXN1YWxseSBoYXBwZW5zIGlmIHlvdSBkb24ndCB1c2UgQnVmUmVhZGVyIG9yIGlmIHlvdSBkb24ndCB1c2UgQnVmUmVhZGVyLnNlZWtfcmVsYXRpdmUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZS5sYXN0UmVhZFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBmaWxlLmxhc3RSZWFkRW5kID0gZW5kO1xuICAgICAgICAgICAgLy8gVE9ETyhKUCk6IFRoaXMgY3JlYXRlcyBhIG5ldyBidWZmZXIgaW5zdGVhZCBvZiByZWFkaW5nIGRpcmVjdGx5IGludG8gdGhlIHdhc20gbWVtb3J5LlxuICAgICAgICAgICAgLy8gTWF5YmUgd2UgY2FuIGF2b2lkIHRoaXMgYnkgdXNpbmcgYSBzdHJlYW0gd2l0aCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciwgYnV0IHRoYXQgaXNcbiAgICAgICAgICAgIC8vIGFzeW5jaHJvbm91cywgc28gd2UnZCBoYXZlIHRvIGRvIGEgZGFuY2Ugd2l0aCBhbm90aGVyIHRocmVhZCBhbmQgYXRvbWljcyBhbmQgYWxsIHRoYXQsXG4gICAgICAgICAgICAvLyBhbmQgSSBkb24ndCBrbm93IGlmIHRoYXQgb3ZlcmhlYWQgd291bGQgYmUgd29ydGggaXQuLlxuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZmlsZVJlYWRlclN5bmMucmVhZEFzQXJyYXlCdWZmZXIoZmlsZS5maWxlLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGNvcHlBcnJheVRvUnVzdEJ1ZmZlcihuZXcgVWludDhBcnJheShidWZmZXIpLCBtZW1vcnkuYnVmZmVyLCBOdW1iZXIoYnVmUHRyKSk7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVyZm9ybWFuY2VOb3c6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhyZWFkU3Bhd246IChjdHhQdHIpID0+IHtcbiAgICAgICAgICAgIHRocmVhZFNwYXduKGN0eFB0cik7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZW5kRXZlbnRGcm9tQW55VGhyZWFkOiAoZXZlbnRQdHIpID0+IHtcbiAgICAgICAgICAgIHNlbmRFdmVudEZyb21BbnlUaHJlYWQoZXZlbnRQdHIpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkVXJsU3luYzogKHVybFB0ciwgdXJsTGVuLCBidWZQdHJPdXQsIGJ1Zkxlbk91dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gcGFyc2VTdHJpbmcodXJsUHRyLCB1cmxMZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgbmV3IFVSTCh1cmwsIGJhc2VVcmkpLmhyZWYsIGZhbHNlIC8qIHN5bmNocm9ub3VzICovKTtcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0cyA9IGdldEV4cG9ydHMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRCdWZQdHIgPSBjcmVhdGVXYXNtQnVmZmVyKG1lbW9yeSwgZXhwb3J0cywgbmV3IFVpbnQ4QXJyYXkocmVxdWVzdC5yZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCBidWZQdHJPdXQsIDEpWzBdID0gb3V0cHV0QnVmUHRyO1xuICAgICAgICAgICAgICAgIG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCBidWZMZW5PdXQsIDEpWzBdID1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJhbmRvbVU2NDogKCkgPT4gbmV3IEJpZ1VpbnQ2NEFycmF5KHNlbGYuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpLmJ1ZmZlcilbMF0sXG4gICAgICAgIHNlbmRUYXNrV29ya2VyTWVzc2FnZTogKHR3TWVzc2FnZVB0cikgPT4ge1xuICAgICAgICAgICAgc2VuZFRhc2tXb3JrZXJNZXNzYWdlKHRhc2tXb3JrZXJTYWIsIHBhcnNlSW50KHR3TWVzc2FnZVB0cikpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0SW1wbChtZW1vcnksIGRlc3RydWN0b3IsIG11dGFibGVEZXN0cnVjdG9yLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gZ2V0V3JmQnVmZmVyV2FzbShtZW1vcnksIHBhcmFtLCBkZXN0cnVjdG9yLCBtdXRhYmxlRGVzdHJ1Y3Rvcik7XG4gICAgICAgICAgICBpZiAocGFyYW0ucGFyYW1UeXBlID09PSBXcmZQYXJhbVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JmUGFyYW0gYnVmZmVyIHR5cGUgY2FsbGVkIHdpdGggc3RyaW5nIHBhcmFtVHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBhY3R1YWxseSBXcmZBcnJheSB0eXBlcywgc2luY2Ugd2Ugb3ZlcndyaXRlIFR5cGVkQXJyYXlzIGluIG92ZXJ3cml0ZVR5cGVkQXJyYXlzV2l0aFdyZkFycmF5cygpXG4gICAgICAgICAgICBjb25zdCBBcnJheUNvbnN0cnVjdG9yID0ge1xuICAgICAgICAgICAgICAgIFtXcmZQYXJhbVR5cGUuVThCdWZmZXJdOiBVaW50OEFycmF5LFxuICAgICAgICAgICAgICAgIFtXcmZQYXJhbVR5cGUuUmVhZE9ubHlVOEJ1ZmZlcl06IFVpbnQ4QXJyYXksXG4gICAgICAgICAgICAgICAgW1dyZlBhcmFtVHlwZS5GMzJCdWZmZXJdOiBGbG9hdDMyQXJyYXksXG4gICAgICAgICAgICAgICAgW1dyZlBhcmFtVHlwZS5SZWFkT25seUYzMkJ1ZmZlcl06IEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAgIH1bcGFyYW0ucGFyYW1UeXBlXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDYWNoZWRXcmZCdWZmZXIod3JmQnVmZmVyLCBuZXcgQXJyYXlDb25zdHJ1Y3Rvcih3cmZCdWZmZXIsIHBhcmFtLmJ1ZmZlclB0ciwgcGFyYW0uYnVmZmVyTGVuIC8gQXJyYXlDb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVCkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm90TnVsbCh2YWx1ZSwgb2JqZWN0TmFtZSA9IFwiVmFsdWVcIikge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXJ0aW9uIGZhaWxlZDogJHtvYmplY3ROYW1lfSBpcyBudWxsYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./common.ts\n");

/***/ }),

/***/ "./cursor_map.ts":
/*!***********************!*\
  !*** ./cursor_map.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cursorMap\": () => (/* binding */ cursorMap)\n/* harmony export */ });\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Be sure to keep this in sync with cursor.rs!\nconst cursorMap = [\n    \"none\",\n    \"default\",\n    \"crosshair\",\n    \"pointer\",\n    \"default\",\n    \"move\",\n    \"text\",\n    \"wait\",\n    \"help\",\n    \"not-allowed\",\n    \"n-resize\",\n    \"ne-resize\",\n    \"e-resize\",\n    \"se-resize\",\n    \"s-resize\",\n    \"sw-resize\",\n    \"w-resize\",\n    \"nw-resize\",\n    \"ns-resize\",\n    \"nesw-resize\",\n    \"ew-resize\",\n    \"nwse-resize\",\n    \"col-resize\",\n    \"row-resize\", // RowResize=>23,\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jdXJzb3JfbWFwLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vY3Vyc29yX21hcC50cz85YjhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMS1wcmVzZW50LCBDcnVpc2UgTExDXG4vL1xuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UtQVBBQ0hFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBCZSBzdXJlIHRvIGtlZXAgdGhpcyBpbiBzeW5jIHdpdGggY3Vyc29yLnJzIVxuZXhwb3J0IGNvbnN0IGN1cnNvck1hcCA9IFtcbiAgICBcIm5vbmVcIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImNyb3NzaGFpclwiLFxuICAgIFwicG9pbnRlclwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwibW92ZVwiLFxuICAgIFwidGV4dFwiLFxuICAgIFwid2FpdFwiLFxuICAgIFwiaGVscFwiLFxuICAgIFwibm90LWFsbG93ZWRcIixcbiAgICBcIm4tcmVzaXplXCIsXG4gICAgXCJuZS1yZXNpemVcIixcbiAgICBcImUtcmVzaXplXCIsXG4gICAgXCJzZS1yZXNpemVcIixcbiAgICBcInMtcmVzaXplXCIsXG4gICAgXCJzdy1yZXNpemVcIixcbiAgICBcInctcmVzaXplXCIsXG4gICAgXCJudy1yZXNpemVcIixcbiAgICBcIm5zLXJlc2l6ZVwiLFxuICAgIFwibmVzdy1yZXNpemVcIixcbiAgICBcImV3LXJlc2l6ZVwiLFxuICAgIFwibndzZS1yZXNpemVcIixcbiAgICBcImNvbC1yZXNpemVcIixcbiAgICBcInJvdy1yZXNpemVcIiwgLy8gUm93UmVzaXplPT4yMyxcbl07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./cursor_map.ts\n");

/***/ }),

/***/ "./make_rpc_event.ts":
/*!***************************!*\
  !*** ./make_rpc_event.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeRpcMouseEvent\": () => (/* binding */ makeRpcMouseEvent),\n/* harmony export */   \"makeRpcTouchEvent\": () => (/* binding */ makeRpcTouchEvent),\n/* harmony export */   \"makeRpcWheelEvent\": () => (/* binding */ makeRpcWheelEvent),\n/* harmony export */   \"makeRpcKeyboardEvent\": () => (/* binding */ makeRpcKeyboardEvent)\n/* harmony export */ });\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\nconst makeRpcMouseEvent = (event) => {\n    return {\n        pageX: event.pageX,\n        pageY: event.pageY,\n        button: event.button,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\nconst makeRpcTouchEvent = (event) => {\n    return {\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n        changedTouches: Array.from(event.changedTouches).map((touch) => ({\n            pageX: touch.pageX,\n            pageY: touch.pageY,\n            identifier: touch.identifier,\n        })),\n    };\n};\nconst makeRpcWheelEvent = (event) => {\n    return {\n        pageX: event.pageX,\n        pageY: event.pageY,\n        button: event.button,\n        timeStamp: event.timeStamp,\n        deltaMode: event.deltaMode,\n        deltaX: event.deltaX,\n        deltaY: event.deltaY,\n        // @ts-ignore - the wheelDeltaY API is non-standard\n        wheelDeltaY: event.wheelDeltaY,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\nconst makeRpcKeyboardEvent = (event) => {\n    return {\n        keyCode: event.keyCode,\n        repeat: event.repeat,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWtlX3JwY19ldmVudC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL21ha2VfcnBjX2V2ZW50LnRzP2FmMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbmV4cG9ydCBjb25zdCBtYWtlUnBjTW91c2VFdmVudCA9IChldmVudCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VYOiBldmVudC5wYWdlWCxcbiAgICAgICAgcGFnZVk6IGV2ZW50LnBhZ2VZLFxuICAgICAgICBidXR0b246IGV2ZW50LmJ1dHRvbixcbiAgICAgICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICBjdHJsS2V5OiBldmVudC5jdHJsS2V5LFxuICAgICAgICBtZXRhS2V5OiBldmVudC5tZXRhS2V5LFxuICAgICAgICBhbHRLZXk6IGV2ZW50LmFsdEtleSxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBtYWtlUnBjVG91Y2hFdmVudCA9IChldmVudCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNoaWZ0S2V5OiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogZXZlbnQuY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogZXZlbnQubWV0YUtleSxcbiAgICAgICAgYWx0S2V5OiBldmVudC5hbHRLZXksXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOiBBcnJheS5mcm9tKGV2ZW50LmNoYW5nZWRUb3VjaGVzKS5tYXAoKHRvdWNoKSA9PiAoe1xuICAgICAgICAgICAgcGFnZVg6IHRvdWNoLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IHRvdWNoLnBhZ2VZLFxuICAgICAgICAgICAgaWRlbnRpZmllcjogdG91Y2guaWRlbnRpZmllcixcbiAgICAgICAgfSkpLFxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IG1ha2VScGNXaGVlbEV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICBwYWdlWTogZXZlbnQucGFnZVksXG4gICAgICAgIGJ1dHRvbjogZXZlbnQuYnV0dG9uLFxuICAgICAgICB0aW1lU3RhbXA6IGV2ZW50LnRpbWVTdGFtcCxcbiAgICAgICAgZGVsdGFNb2RlOiBldmVudC5kZWx0YU1vZGUsXG4gICAgICAgIGRlbHRhWDogZXZlbnQuZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGV2ZW50LmRlbHRhWSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHRoZSB3aGVlbERlbHRhWSBBUEkgaXMgbm9uLXN0YW5kYXJkXG4gICAgICAgIHdoZWVsRGVsdGFZOiBldmVudC53aGVlbERlbHRhWSxcbiAgICAgICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICBjdHJsS2V5OiBldmVudC5jdHJsS2V5LFxuICAgICAgICBtZXRhS2V5OiBldmVudC5tZXRhS2V5LFxuICAgICAgICBhbHRLZXk6IGV2ZW50LmFsdEtleSxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBtYWtlUnBjS2V5Ym9hcmRFdmVudCA9IChldmVudCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleUNvZGU6IGV2ZW50LmtleUNvZGUsXG4gICAgICAgIHJlcGVhdDogZXZlbnQucmVwZWF0LFxuICAgICAgICBzaGlmdEtleTogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXk6IGV2ZW50LmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXk6IGV2ZW50Lm1ldGFLZXksXG4gICAgICAgIGFsdEtleTogZXZlbnQuYWx0S2V5LFxuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./make_rpc_event.ts\n");

/***/ }),

/***/ "./make_textarea.ts":
/*!**************************!*\
  !*** ./make_textarea.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeTextarea\": () => (/* binding */ makeTextarea)\n/* harmony export */ });\n/* harmony import */ var _make_rpc_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./make_rpc_event */ \"./make_rpc_event.ts\");\n/* harmony import */ var _rpc_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc_types */ \"./rpc_types.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n\n\n// Create a hidden textarea which is purely used for text input into Rust.\nfunction makeTextarea(callback) {\n    let ta;\n    // NOTE(JP): This looks a bit convoluted, but it's the most reliable method I could find to return the focus to the textarea!\n    function fixFocus() {\n        setTimeout(() => {\n            var _a;\n            if (ta &&\n                document.activeElement !== ta &&\n                !((_a = document.getElementById(\"js_root\")) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement))) {\n                ta.focus();\n            }\n        });\n    }\n    document.addEventListener(\"mousedown\", fixFocus, true);\n    document.addEventListener(\"mouseup\", fixFocus, true);\n    document.addEventListener(\"focus\", fixFocus, true);\n    document.addEventListener(\"blur\", fixFocus, true);\n    let textAreaPos;\n    const updateTextAreaPos = () => {\n        if (!textAreaPos) {\n            ta.style.left = -100 + \"px\";\n            ta.style.top = -100 + \"px\";\n        }\n        else {\n            ta.style.left = Math.round(textAreaPos.x) - 4 + \"px\";\n            ta.style.top = Math.round(textAreaPos.y) + \"px\";\n        }\n    };\n    function showTextIME({ x, y }) {\n        textAreaPos = { x, y };\n        updateTextAreaPos();\n    }\n    let wasPaste = false;\n    let lastLen = 0;\n    let uglyIMEHack = false;\n    const recreateTextarea = function () {\n        if (ta)\n            document.body.removeChild(ta);\n        ta = document.createElement(\"textarea\");\n        ta.className = \"cx_webgl_textinput\";\n        ta.setAttribute(\"autocomplete\", \"off\");\n        ta.setAttribute(\"autocorrect\", \"off\");\n        ta.setAttribute(\"autocapitalize\", \"off\");\n        ta.setAttribute(\"spellcheck\", \"false\");\n        const style = document.createElement(\"style\");\n        style.innerHTML = `\n      textarea.cx_webgl_textinput {\n        z-index: 1000;\n        position: absolute;\n        opacity: 0;\n        border-radius: 4px;\n        color:white;\n        font-size: 6;\n        background: gray;\n        -moz-appearance: none;\n        appearance:none;\n        border:none;\n        resize: none;\n        outline: none;\n        overflow: hidden;\n        text-indent: 0px;\n        padding: 0 0px;\n        margin: 0 -1px;\n        text-indent: 0px;\n        -ms-user-select: text;\n        -moz-user-select: text;\n        -webkit-user-select: text;\n        user-select: text;\n        white-space: pre!important;\n      }\n      textarea:focus.cx_webgl_textinput {\n        outline: 0px !important;\n        -webkit-appearance: none;\n      }\n    `;\n        document.body.appendChild(style);\n        ta.style.left = -100 + \"px\";\n        ta.style.top = -100 + \"px\";\n        ta.style.height = 1 + \"px\";\n        ta.style.width = 1 + \"px\";\n        ta.addEventListener(\"contextmenu\", (event) => {\n            event.preventDefault();\n            return false;\n        });\n        document.body.appendChild(ta);\n        ta.focus();\n        updateTextAreaPos();\n        ta.addEventListener(\"cut\", () => {\n            setTimeout(() => {\n                ta.value = \"\";\n                lastLen = 0;\n            });\n        });\n        ta.addEventListener(\"copy\", () => {\n            setTimeout(() => {\n                ta.value = \"\";\n                lastLen = 0;\n            });\n        });\n        ta.addEventListener(\"paste\", () => {\n            wasPaste = true;\n        });\n        ta.addEventListener(\"input\", () => {\n            if (ta.value.length > 0) {\n                if (wasPaste) {\n                    wasPaste = false;\n                    const input = ta.value.substring(lastLen);\n                    ta.value = \"\";\n                    callback({\n                        type: _rpc_types__WEBPACK_IMPORTED_MODULE_1__.WorkerEvent.TextInput,\n                        wasPaste: true,\n                        input,\n                        replaceLast: false,\n                    });\n                }\n                else {\n                    let replaceLast = false;\n                    let textValue = ta.value;\n                    if (ta.value.length >= 2) {\n                        // we want the second char\n                        textValue = ta.value.substring(1, 2);\n                        ta.value = textValue;\n                    }\n                    else if (ta.value.length == 1 && lastLen == ta.value.length) {\n                        // its an IME replace\n                        replaceLast = true;\n                    }\n                    // we should send a replace last\n                    if (replaceLast || textValue != \"\\n\") {\n                        callback({\n                            type: _rpc_types__WEBPACK_IMPORTED_MODULE_1__.WorkerEvent.TextInput,\n                            wasPaste: false,\n                            input: textValue,\n                            replaceLast: replaceLast,\n                        });\n                    }\n                }\n            }\n            lastLen = ta.value.length;\n        });\n        ta.addEventListener(\"keydown\", (event) => {\n            const code = event.keyCode;\n            if (code == 18 || code == 17 || code == 16)\n                event.preventDefault(); // alt\n            if (code === 8 || code === 9)\n                event.preventDefault(); // backspace/tab\n            if (code === 89 && (event.metaKey || event.ctrlKey))\n                event.preventDefault(); // all (select all)\n            if (code === 83 && (event.metaKey || event.ctrlKey))\n                event.preventDefault(); // ctrl s\n            if (code >= 33 && code <= 40) {\n                // if we are using arrow keys, home or end\n                ta.value = \"\";\n                lastLen = ta.value.length;\n            }\n            if ((code === 88 || code == 67) && (event.metaKey || event.ctrlKey)) {\n                // copy or cut\n                // we need to request the clipboard\n                callback({ type: _rpc_types__WEBPACK_IMPORTED_MODULE_1__.WorkerEvent.TextCopy });\n                event.preventDefault();\n            }\n            if (code === 90 && (event.metaKey || event.ctrlKey)) {\n                // ctrl/cmd + z\n                updateTextAreaPos();\n                ta.value = \"\";\n                uglyIMEHack = true;\n                ta.readOnly = true;\n                event.preventDefault();\n            }\n            callback({\n                type: _rpc_types__WEBPACK_IMPORTED_MODULE_1__.WorkerEvent.KeyDown,\n                event: (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_0__.makeRpcKeyboardEvent)(event),\n            });\n        });\n        ta.addEventListener(\"keyup\", (event) => {\n            const code = event.keyCode;\n            if (code == 18 || code == 17 || code == 16)\n                event.preventDefault(); // alt\n            if (code == 91)\n                event.preventDefault(); // left window key\n            if (uglyIMEHack) {\n                uglyIMEHack = false;\n                recreateTextarea();\n            }\n            callback({\n                type: _rpc_types__WEBPACK_IMPORTED_MODULE_1__.WorkerEvent.KeyUp,\n                event: (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_0__.makeRpcKeyboardEvent)(event),\n            });\n        });\n    };\n    recreateTextarea();\n    function textareaHasFocus() {\n        return document.activeElement == ta;\n    }\n    return { showTextIME, textareaHasFocus };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWtlX3RleHRhcmVhLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL21ha2VfdGV4dGFyZWEudHM/MDc3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjEtcHJlc2VudCwgQ3J1aXNlIExMQ1xuLy9cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCxcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFLUFQQUNIRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgbWFrZVJwY0tleWJvYXJkRXZlbnQgfSBmcm9tIFwiLi9tYWtlX3JwY19ldmVudFwiO1xuaW1wb3J0IHsgV29ya2VyRXZlbnQgfSBmcm9tIFwiLi9ycGNfdHlwZXNcIjtcbi8vIENyZWF0ZSBhIGhpZGRlbiB0ZXh0YXJlYSB3aGljaCBpcyBwdXJlbHkgdXNlZCBmb3IgdGV4dCBpbnB1dCBpbnRvIFJ1c3QuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVRleHRhcmVhKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRhO1xuICAgIC8vIE5PVEUoSlApOiBUaGlzIGxvb2tzIGEgYml0IGNvbnZvbHV0ZWQsIGJ1dCBpdCdzIHRoZSBtb3N0IHJlbGlhYmxlIG1ldGhvZCBJIGNvdWxkIGZpbmQgdG8gcmV0dXJuIHRoZSBmb2N1cyB0byB0aGUgdGV4dGFyZWEhXG4gICAgZnVuY3Rpb24gZml4Rm9jdXMoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRhICYmXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGEgJiZcbiAgICAgICAgICAgICAgICAhKChfYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwianNfcm9vdFwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgIHRhLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZpeEZvY3VzLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmaXhGb2N1cywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZpeEZvY3VzLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmaXhGb2N1cywgdHJ1ZSk7XG4gICAgbGV0IHRleHRBcmVhUG9zO1xuICAgIGNvbnN0IHVwZGF0ZVRleHRBcmVhUG9zID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRleHRBcmVhUG9zKSB7XG4gICAgICAgICAgICB0YS5zdHlsZS5sZWZ0ID0gLTEwMCArIFwicHhcIjtcbiAgICAgICAgICAgIHRhLnN0eWxlLnRvcCA9IC0xMDAgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YS5zdHlsZS5sZWZ0ID0gTWF0aC5yb3VuZCh0ZXh0QXJlYVBvcy54KSAtIDQgKyBcInB4XCI7XG4gICAgICAgICAgICB0YS5zdHlsZS50b3AgPSBNYXRoLnJvdW5kKHRleHRBcmVhUG9zLnkpICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzaG93VGV4dElNRSh7IHgsIHkgfSkge1xuICAgICAgICB0ZXh0QXJlYVBvcyA9IHsgeCwgeSB9O1xuICAgICAgICB1cGRhdGVUZXh0QXJlYVBvcygpO1xuICAgIH1cbiAgICBsZXQgd2FzUGFzdGUgPSBmYWxzZTtcbiAgICBsZXQgbGFzdExlbiA9IDA7XG4gICAgbGV0IHVnbHlJTUVIYWNrID0gZmFsc2U7XG4gICAgY29uc3QgcmVjcmVhdGVUZXh0YXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRhKVxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0YSk7XG4gICAgICAgIHRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICB0YS5jbGFzc05hbWUgPSBcImN4X3dlYmdsX3RleHRpbnB1dFwiO1xuICAgICAgICB0YS5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIik7XG4gICAgICAgIHRhLnNldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIsIFwib2ZmXCIpO1xuICAgICAgICB0YS5zZXRBdHRyaWJ1dGUoXCJhdXRvY2FwaXRhbGl6ZVwiLCBcIm9mZlwiKTtcbiAgICAgICAgdGEuc2V0QXR0cmlidXRlKFwic3BlbGxjaGVja1wiLCBcImZhbHNlXCIpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gYFxuICAgICAgdGV4dGFyZWEuY3hfd2ViZ2xfdGV4dGlucHV0IHtcbiAgICAgICAgei1pbmRleDogMTAwMDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgIGNvbG9yOndoaXRlO1xuICAgICAgICBmb250LXNpemU6IDY7XG4gICAgICAgIGJhY2tncm91bmQ6IGdyYXk7XG4gICAgICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcbiAgICAgICAgYXBwZWFyYW5jZTpub25lO1xuICAgICAgICBib3JkZXI6bm9uZTtcbiAgICAgICAgcmVzaXplOiBub25lO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0ZXh0LWluZGVudDogMHB4O1xuICAgICAgICBwYWRkaW5nOiAwIDBweDtcbiAgICAgICAgbWFyZ2luOiAwIC0xcHg7XG4gICAgICAgIHRleHQtaW5kZW50OiAwcHg7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogdGV4dDtcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogdGV4dDtcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogdGV4dDtcbiAgICAgICAgdXNlci1zZWxlY3Q6IHRleHQ7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBwcmUhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgdGV4dGFyZWE6Zm9jdXMuY3hfd2ViZ2xfdGV4dGlucHV0IHtcbiAgICAgICAgb3V0bGluZTogMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgICAgIH1cbiAgICBgO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgdGEuc3R5bGUubGVmdCA9IC0xMDAgKyBcInB4XCI7XG4gICAgICAgIHRhLnN0eWxlLnRvcCA9IC0xMDAgKyBcInB4XCI7XG4gICAgICAgIHRhLnN0eWxlLmhlaWdodCA9IDEgKyBcInB4XCI7XG4gICAgICAgIHRhLnN0eWxlLndpZHRoID0gMSArIFwicHhcIjtcbiAgICAgICAgdGEuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGEpO1xuICAgICAgICB0YS5mb2N1cygpO1xuICAgICAgICB1cGRhdGVUZXh0QXJlYVBvcygpO1xuICAgICAgICB0YS5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsICgpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRhLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsYXN0TGVuID0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGEuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgKCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGEudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxhc3RMZW4gPSAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0YS5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgd2FzUGFzdGUgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGEuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0YS52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhc1Bhc3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc1Bhc3RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGEudmFsdWUuc3Vic3RyaW5nKGxhc3RMZW4pO1xuICAgICAgICAgICAgICAgICAgICB0YS52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFdvcmtlckV2ZW50LlRleHRJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc1Bhc3RlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlTGFzdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcGxhY2VMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0VmFsdWUgPSB0YS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhLnZhbHVlLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRoZSBzZWNvbmQgY2hhclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFZhbHVlID0gdGEudmFsdWUuc3Vic3RyaW5nKDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGEudmFsdWUgPSB0ZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGEudmFsdWUubGVuZ3RoID09IDEgJiYgbGFzdExlbiA9PSB0YS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0cyBhbiBJTUUgcmVwbGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUxhc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBzZW5kIGEgcmVwbGFjZSBsYXN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlTGFzdCB8fCB0ZXh0VmFsdWUgIT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFdvcmtlckV2ZW50LlRleHRJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNQYXN0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRleHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlTGFzdDogcmVwbGFjZUxhc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RMZW4gPSB0YS52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICB0YS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT0gMTggfHwgY29kZSA9PSAxNyB8fCBjb2RlID09IDE2KVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIGFsdFxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDggfHwgY29kZSA9PT0gOSlcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBiYWNrc3BhY2UvdGFiXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gODkgJiYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkpXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gYWxsIChzZWxlY3QgYWxsKVxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDgzICYmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpKVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIGN0cmwgc1xuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMzMgJiYgY29kZSA8PSA0MCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSB1c2luZyBhcnJvdyBrZXlzLCBob21lIG9yIGVuZFxuICAgICAgICAgICAgICAgIHRhLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsYXN0TGVuID0gdGEudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChjb2RlID09PSA4OCB8fCBjb2RlID09IDY3KSAmJiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3IgY3V0XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXF1ZXN0IHRoZSBjbGlwYm9hcmRcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh7IHR5cGU6IFdvcmtlckV2ZW50LlRleHRDb3B5IH0pO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gOTAgJiYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjdHJsL2NtZCArIHpcbiAgICAgICAgICAgICAgICB1cGRhdGVUZXh0QXJlYVBvcygpO1xuICAgICAgICAgICAgICAgIHRhLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICB1Z2x5SU1FSGFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGEucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgdHlwZTogV29ya2VyRXZlbnQuS2V5RG93bixcbiAgICAgICAgICAgICAgICBldmVudDogbWFrZVJwY0tleWJvYXJkRXZlbnQoZXZlbnQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0YS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICAgIGlmIChjb2RlID09IDE4IHx8IGNvZGUgPT0gMTcgfHwgY29kZSA9PSAxNilcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBhbHRcbiAgICAgICAgICAgIGlmIChjb2RlID09IDkxKVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIGxlZnQgd2luZG93IGtleVxuICAgICAgICAgICAgaWYgKHVnbHlJTUVIYWNrKSB7XG4gICAgICAgICAgICAgICAgdWdseUlNRUhhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZWNyZWF0ZVRleHRhcmVhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgdHlwZTogV29ya2VyRXZlbnQuS2V5VXAsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IG1ha2VScGNLZXlib2FyZEV2ZW50KGV2ZW50KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJlY3JlYXRlVGV4dGFyZWEoKTtcbiAgICBmdW5jdGlvbiB0ZXh0YXJlYUhhc0ZvY3VzKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSB0YTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2hvd1RleHRJTUUsIHRleHRhcmVhSGFzRm9jdXMgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./make_textarea.ts\n");

/***/ }),

/***/ "./rpc_types.ts":
/*!**********************!*\
  !*** ./rpc_types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WorkerEvent\": () => (/* binding */ WorkerEvent),\n/* harmony export */   \"TaskWorkerEvent\": () => (/* binding */ TaskWorkerEvent),\n/* harmony export */   \"AsyncWorkerEvent\": () => (/* binding */ AsyncWorkerEvent),\n/* harmony export */   \"MainWorkerChannelEvent\": () => (/* binding */ MainWorkerChannelEvent)\n/* harmony export */ });\nvar WorkerEvent;\n(function (WorkerEvent) {\n    WorkerEvent[\"CallRust\"] = \"WorkerEvent.CallRust\";\n    WorkerEvent[\"CreateBuffer\"] = \"WorkerEvent.CreateBuffer\";\n    WorkerEvent[\"CreateReadOnlyBuffer\"] = \"WorkerEvent.CreateReadOnlyBuffer\";\n    WorkerEvent[\"BindMainWorkerPort\"] = \"WorkerEvent.BindMainWorkerPort\";\n    WorkerEvent[\"DecrementArc\"] = \"WorkerEvent.DecrementArc\";\n    WorkerEvent[\"DeallocVec\"] = \"WorkerEvent.DeallocVec\";\n    WorkerEvent[\"IncrementArc\"] = \"WorkerEvent.IncrementArc\";\n    WorkerEvent[\"DragEnter\"] = \"WorkerEvent.DragEnter\";\n    WorkerEvent[\"DragOver\"] = \"WorkerEvent.DragOver\";\n    WorkerEvent[\"DragLeave\"] = \"WorkerEvent.DragLeave\";\n    WorkerEvent[\"Drop\"] = \"WorkerEvent.Drop\";\n    WorkerEvent[\"WindowMouseUp\"] = \"WorkerEvent.WindowMouseUp\";\n    WorkerEvent[\"CanvasMouseDown\"] = \"WorkerEvent.CanvasMouseDown\";\n    WorkerEvent[\"WindowMouseMove\"] = \"WorkerEvent.WindowMouseMove\";\n    WorkerEvent[\"WindowMouseOut\"] = \"WorkerEvent.WindowMouseOut\";\n    WorkerEvent[\"WindowFocus\"] = \"WorkerEvent.WindowFocus\";\n    WorkerEvent[\"WindowBlur\"] = \"WorkerEvent.WindowBlur\";\n    WorkerEvent[\"ScreenResize\"] = \"WorkerEvent.ScreenResize\";\n    WorkerEvent[\"CanvasWheel\"] = \"WorkerEvent.CanvasWheel\";\n    WorkerEvent[\"ShowIncompatibleBrowserNotification\"] = \"WorkerEvent.ShowIncompatibleBrowserNotification\";\n    WorkerEvent[\"RemoveLoadingIndicators\"] = \"WorkerEvent.RemoveLoadingIndicators\";\n    WorkerEvent[\"SetDocumentTitle\"] = \"WorkerEvent.SetDocumentTitle\";\n    WorkerEvent[\"SetMouseCursor\"] = \"WorkerEvent.SetMouseCursor\";\n    WorkerEvent[\"Fullscreen\"] = \"WorkerEvent.Fullscreen\";\n    WorkerEvent[\"Normalscreen\"] = \"WorkerEvent.Normalscreen\";\n    WorkerEvent[\"TextCopyResponse\"] = \"WorkerEvent.TextCopyResponse\";\n    WorkerEvent[\"EnableGlobalFileDropTarget\"] = \"WorkerEvent.EnableGlobalFileDropTarget\";\n    WorkerEvent[\"CallJs\"] = \"WorkerEvent.CallJs\";\n    WorkerEvent[\"ShowTextIME\"] = \"WorkerEvent.ShowTextIME\";\n    WorkerEvent[\"TextInput\"] = \"WorkerEvent.TextInput\";\n    WorkerEvent[\"TextCopy\"] = \"WorkerEvent.TextCopy\";\n    WorkerEvent[\"KeyDown\"] = \"WorkerEvent.KeyDown\";\n    WorkerEvent[\"KeyUp\"] = \"WorkerEvent.KeyUp\";\n    WorkerEvent[\"Init\"] = \"WorkerEvent.Init\";\n    WorkerEvent[\"RunWebGL\"] = \"WorkerEvent.RunWebGL\";\n    WorkerEvent[\"ThreadSpawn\"] = \"WorkerEvent.ThreadSpawn\";\n    WorkerEvent[\"WindowTouchStart\"] = \"WorkerEvent.WindowTouchStart\";\n    WorkerEvent[\"WindowTouchMove\"] = \"WorkerEvent.WindowTouchMove\";\n    WorkerEvent[\"WindowTouchEndCancelLeave\"] = \"WorkerEvent.WindowTouchEndCancelLeave\";\n})(WorkerEvent || (WorkerEvent = {}));\nvar TaskWorkerEvent;\n(function (TaskWorkerEvent) {\n    TaskWorkerEvent[\"Init\"] = \"TaskWorkerEvent.Init\";\n})(TaskWorkerEvent || (TaskWorkerEvent = {}));\nvar AsyncWorkerEvent;\n(function (AsyncWorkerEvent) {\n    AsyncWorkerEvent[\"Run\"] = \"AsyncWorkerEvent.Run\";\n    AsyncWorkerEvent[\"ThreadSpawn\"] = \"AsyncWorkerEvent.ThreadSpawn\";\n})(AsyncWorkerEvent || (AsyncWorkerEvent = {}));\nvar MainWorkerChannelEvent;\n(function (MainWorkerChannelEvent) {\n    MainWorkerChannelEvent[\"Init\"] = \"MainWorkerChannelEvent.Init\";\n    MainWorkerChannelEvent[\"BindMainWorkerPort\"] = \"MainWorkerChannelEvent.BindMainWorkerPort\";\n    MainWorkerChannelEvent[\"CallRust\"] = \"MainWorkerChannelEvent.CallRust\";\n    MainWorkerChannelEvent[\"SendEventFromAnyThread\"] = \"MainWorkerChannelEvent.SendEventFromAnyThread\";\n})(MainWorkerChannelEvent || (MainWorkerChannelEvent = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ycGNfdHlwZXMudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vcnBjX3R5cGVzLnRzPzg4M2IiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBXb3JrZXJFdmVudDtcbihmdW5jdGlvbiAoV29ya2VyRXZlbnQpIHtcbiAgICBXb3JrZXJFdmVudFtcIkNhbGxSdXN0XCJdID0gXCJXb3JrZXJFdmVudC5DYWxsUnVzdFwiO1xuICAgIFdvcmtlckV2ZW50W1wiQ3JlYXRlQnVmZmVyXCJdID0gXCJXb3JrZXJFdmVudC5DcmVhdGVCdWZmZXJcIjtcbiAgICBXb3JrZXJFdmVudFtcIkNyZWF0ZVJlYWRPbmx5QnVmZmVyXCJdID0gXCJXb3JrZXJFdmVudC5DcmVhdGVSZWFkT25seUJ1ZmZlclwiO1xuICAgIFdvcmtlckV2ZW50W1wiQmluZE1haW5Xb3JrZXJQb3J0XCJdID0gXCJXb3JrZXJFdmVudC5CaW5kTWFpbldvcmtlclBvcnRcIjtcbiAgICBXb3JrZXJFdmVudFtcIkRlY3JlbWVudEFyY1wiXSA9IFwiV29ya2VyRXZlbnQuRGVjcmVtZW50QXJjXCI7XG4gICAgV29ya2VyRXZlbnRbXCJEZWFsbG9jVmVjXCJdID0gXCJXb3JrZXJFdmVudC5EZWFsbG9jVmVjXCI7XG4gICAgV29ya2VyRXZlbnRbXCJJbmNyZW1lbnRBcmNcIl0gPSBcIldvcmtlckV2ZW50LkluY3JlbWVudEFyY1wiO1xuICAgIFdvcmtlckV2ZW50W1wiRHJhZ0VudGVyXCJdID0gXCJXb3JrZXJFdmVudC5EcmFnRW50ZXJcIjtcbiAgICBXb3JrZXJFdmVudFtcIkRyYWdPdmVyXCJdID0gXCJXb3JrZXJFdmVudC5EcmFnT3ZlclwiO1xuICAgIFdvcmtlckV2ZW50W1wiRHJhZ0xlYXZlXCJdID0gXCJXb3JrZXJFdmVudC5EcmFnTGVhdmVcIjtcbiAgICBXb3JrZXJFdmVudFtcIkRyb3BcIl0gPSBcIldvcmtlckV2ZW50LkRyb3BcIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd01vdXNlVXBcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd01vdXNlVXBcIjtcbiAgICBXb3JrZXJFdmVudFtcIkNhbnZhc01vdXNlRG93blwiXSA9IFwiV29ya2VyRXZlbnQuQ2FudmFzTW91c2VEb3duXCI7XG4gICAgV29ya2VyRXZlbnRbXCJXaW5kb3dNb3VzZU1vdmVcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd01vdXNlTW92ZVwiO1xuICAgIFdvcmtlckV2ZW50W1wiV2luZG93TW91c2VPdXRcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd01vdXNlT3V0XCI7XG4gICAgV29ya2VyRXZlbnRbXCJXaW5kb3dGb2N1c1wiXSA9IFwiV29ya2VyRXZlbnQuV2luZG93Rm9jdXNcIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd0JsdXJcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd0JsdXJcIjtcbiAgICBXb3JrZXJFdmVudFtcIlNjcmVlblJlc2l6ZVwiXSA9IFwiV29ya2VyRXZlbnQuU2NyZWVuUmVzaXplXCI7XG4gICAgV29ya2VyRXZlbnRbXCJDYW52YXNXaGVlbFwiXSA9IFwiV29ya2VyRXZlbnQuQ2FudmFzV2hlZWxcIjtcbiAgICBXb3JrZXJFdmVudFtcIlNob3dJbmNvbXBhdGlibGVCcm93c2VyTm90aWZpY2F0aW9uXCJdID0gXCJXb3JrZXJFdmVudC5TaG93SW5jb21wYXRpYmxlQnJvd3Nlck5vdGlmaWNhdGlvblwiO1xuICAgIFdvcmtlckV2ZW50W1wiUmVtb3ZlTG9hZGluZ0luZGljYXRvcnNcIl0gPSBcIldvcmtlckV2ZW50LlJlbW92ZUxvYWRpbmdJbmRpY2F0b3JzXCI7XG4gICAgV29ya2VyRXZlbnRbXCJTZXREb2N1bWVudFRpdGxlXCJdID0gXCJXb3JrZXJFdmVudC5TZXREb2N1bWVudFRpdGxlXCI7XG4gICAgV29ya2VyRXZlbnRbXCJTZXRNb3VzZUN1cnNvclwiXSA9IFwiV29ya2VyRXZlbnQuU2V0TW91c2VDdXJzb3JcIjtcbiAgICBXb3JrZXJFdmVudFtcIkZ1bGxzY3JlZW5cIl0gPSBcIldvcmtlckV2ZW50LkZ1bGxzY3JlZW5cIjtcbiAgICBXb3JrZXJFdmVudFtcIk5vcm1hbHNjcmVlblwiXSA9IFwiV29ya2VyRXZlbnQuTm9ybWFsc2NyZWVuXCI7XG4gICAgV29ya2VyRXZlbnRbXCJUZXh0Q29weVJlc3BvbnNlXCJdID0gXCJXb3JrZXJFdmVudC5UZXh0Q29weVJlc3BvbnNlXCI7XG4gICAgV29ya2VyRXZlbnRbXCJFbmFibGVHbG9iYWxGaWxlRHJvcFRhcmdldFwiXSA9IFwiV29ya2VyRXZlbnQuRW5hYmxlR2xvYmFsRmlsZURyb3BUYXJnZXRcIjtcbiAgICBXb3JrZXJFdmVudFtcIkNhbGxKc1wiXSA9IFwiV29ya2VyRXZlbnQuQ2FsbEpzXCI7XG4gICAgV29ya2VyRXZlbnRbXCJTaG93VGV4dElNRVwiXSA9IFwiV29ya2VyRXZlbnQuU2hvd1RleHRJTUVcIjtcbiAgICBXb3JrZXJFdmVudFtcIlRleHRJbnB1dFwiXSA9IFwiV29ya2VyRXZlbnQuVGV4dElucHV0XCI7XG4gICAgV29ya2VyRXZlbnRbXCJUZXh0Q29weVwiXSA9IFwiV29ya2VyRXZlbnQuVGV4dENvcHlcIjtcbiAgICBXb3JrZXJFdmVudFtcIktleURvd25cIl0gPSBcIldvcmtlckV2ZW50LktleURvd25cIjtcbiAgICBXb3JrZXJFdmVudFtcIktleVVwXCJdID0gXCJXb3JrZXJFdmVudC5LZXlVcFwiO1xuICAgIFdvcmtlckV2ZW50W1wiSW5pdFwiXSA9IFwiV29ya2VyRXZlbnQuSW5pdFwiO1xuICAgIFdvcmtlckV2ZW50W1wiUnVuV2ViR0xcIl0gPSBcIldvcmtlckV2ZW50LlJ1bldlYkdMXCI7XG4gICAgV29ya2VyRXZlbnRbXCJUaHJlYWRTcGF3blwiXSA9IFwiV29ya2VyRXZlbnQuVGhyZWFkU3Bhd25cIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd1RvdWNoU3RhcnRcIl0gPSBcIldvcmtlckV2ZW50LldpbmRvd1RvdWNoU3RhcnRcIjtcbiAgICBXb3JrZXJFdmVudFtcIldpbmRvd1RvdWNoTW92ZVwiXSA9IFwiV29ya2VyRXZlbnQuV2luZG93VG91Y2hNb3ZlXCI7XG4gICAgV29ya2VyRXZlbnRbXCJXaW5kb3dUb3VjaEVuZENhbmNlbExlYXZlXCJdID0gXCJXb3JrZXJFdmVudC5XaW5kb3dUb3VjaEVuZENhbmNlbExlYXZlXCI7XG59KShXb3JrZXJFdmVudCB8fCAoV29ya2VyRXZlbnQgPSB7fSkpO1xuZXhwb3J0IHZhciBUYXNrV29ya2VyRXZlbnQ7XG4oZnVuY3Rpb24gKFRhc2tXb3JrZXJFdmVudCkge1xuICAgIFRhc2tXb3JrZXJFdmVudFtcIkluaXRcIl0gPSBcIlRhc2tXb3JrZXJFdmVudC5Jbml0XCI7XG59KShUYXNrV29ya2VyRXZlbnQgfHwgKFRhc2tXb3JrZXJFdmVudCA9IHt9KSk7XG5leHBvcnQgdmFyIEFzeW5jV29ya2VyRXZlbnQ7XG4oZnVuY3Rpb24gKEFzeW5jV29ya2VyRXZlbnQpIHtcbiAgICBBc3luY1dvcmtlckV2ZW50W1wiUnVuXCJdID0gXCJBc3luY1dvcmtlckV2ZW50LlJ1blwiO1xuICAgIEFzeW5jV29ya2VyRXZlbnRbXCJUaHJlYWRTcGF3blwiXSA9IFwiQXN5bmNXb3JrZXJFdmVudC5UaHJlYWRTcGF3blwiO1xufSkoQXN5bmNXb3JrZXJFdmVudCB8fCAoQXN5bmNXb3JrZXJFdmVudCA9IHt9KSk7XG5leHBvcnQgdmFyIE1haW5Xb3JrZXJDaGFubmVsRXZlbnQ7XG4oZnVuY3Rpb24gKE1haW5Xb3JrZXJDaGFubmVsRXZlbnQpIHtcbiAgICBNYWluV29ya2VyQ2hhbm5lbEV2ZW50W1wiSW5pdFwiXSA9IFwiTWFpbldvcmtlckNoYW5uZWxFdmVudC5Jbml0XCI7XG4gICAgTWFpbldvcmtlckNoYW5uZWxFdmVudFtcIkJpbmRNYWluV29ya2VyUG9ydFwiXSA9IFwiTWFpbldvcmtlckNoYW5uZWxFdmVudC5CaW5kTWFpbldvcmtlclBvcnRcIjtcbiAgICBNYWluV29ya2VyQ2hhbm5lbEV2ZW50W1wiQ2FsbFJ1c3RcIl0gPSBcIk1haW5Xb3JrZXJDaGFubmVsRXZlbnQuQ2FsbFJ1c3RcIjtcbiAgICBNYWluV29ya2VyQ2hhbm5lbEV2ZW50W1wiU2VuZEV2ZW50RnJvbUFueVRocmVhZFwiXSA9IFwiTWFpbldvcmtlckNoYW5uZWxFdmVudC5TZW5kRXZlbnRGcm9tQW55VGhyZWFkXCI7XG59KShNYWluV29ya2VyQ2hhbm5lbEV2ZW50IHx8IChNYWluV29ya2VyQ2hhbm5lbEV2ZW50ID0ge30pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./rpc_types.ts\n");

/***/ }),

/***/ "./type_of_runtime.ts":
/*!****************************!*\
  !*** ./type_of_runtime.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jsRuntime\": () => (/* binding */ jsRuntime)\n/* harmony export */ });\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// We only define `cefCallRust` if in CEF, so we can use this for environment detection.\n// This should only be used at the top level `wrf_runtime` file or in test, since we want to keep\n// CEF and WASM code separate for bundle size.\nconst jsRuntime = \"cefCallRust\" in self ? \"cef\" : \"wasm\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90eXBlX29mX3J1bnRpbWUudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3R5cGVfb2ZfcnVudGltZS50cz9kNzJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMS1wcmVzZW50LCBDcnVpc2UgTExDXG4vL1xuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UtQVBBQ0hFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBXZSBvbmx5IGRlZmluZSBgY2VmQ2FsbFJ1c3RgIGlmIGluIENFRiwgc28gd2UgY2FuIHVzZSB0aGlzIGZvciBlbnZpcm9ubWVudCBkZXRlY3Rpb24uXG4vLyBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgYXQgdGhlIHRvcCBsZXZlbCBgd3JmX3J1bnRpbWVgIGZpbGUgb3IgaW4gdGVzdCwgc2luY2Ugd2Ugd2FudCB0byBrZWVwXG4vLyBDRUYgYW5kIFdBU00gY29kZSBzZXBhcmF0ZSBmb3IgYnVuZGxlIHNpemUuXG5leHBvcnQgY29uc3QganNSdW50aW1lID0gXCJjZWZDYWxsUnVzdFwiIGluIHNlbGYgPyBcImNlZlwiIDogXCJ3YXNtXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./type_of_runtime.ts\n");

/***/ }),

/***/ "./types.ts":
/*!******************!*\
  !*** ./types.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WrfParamType\": () => (/* binding */ WrfParamType)\n/* harmony export */ });\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Keep in sync with `param.rs`\nvar WrfParamType;\n(function (WrfParamType) {\n    WrfParamType[WrfParamType[\"String\"] = 0] = \"String\";\n    WrfParamType[WrfParamType[\"ReadOnlyU8Buffer\"] = 1] = \"ReadOnlyU8Buffer\";\n    WrfParamType[WrfParamType[\"U8Buffer\"] = 2] = \"U8Buffer\";\n    WrfParamType[WrfParamType[\"F32Buffer\"] = 3] = \"F32Buffer\";\n    WrfParamType[WrfParamType[\"ReadOnlyF32Buffer\"] = 4] = \"ReadOnlyF32Buffer\";\n})(WrfParamType || (WrfParamType = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90eXBlcy50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3R5cGVzLnRzPzVmNTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIEtlZXAgaW4gc3luYyB3aXRoIGBwYXJhbS5yc2BcbmV4cG9ydCB2YXIgV3JmUGFyYW1UeXBlO1xuKGZ1bmN0aW9uIChXcmZQYXJhbVR5cGUpIHtcbiAgICBXcmZQYXJhbVR5cGVbV3JmUGFyYW1UeXBlW1wiU3RyaW5nXCJdID0gMF0gPSBcIlN0cmluZ1wiO1xuICAgIFdyZlBhcmFtVHlwZVtXcmZQYXJhbVR5cGVbXCJSZWFkT25seVU4QnVmZmVyXCJdID0gMV0gPSBcIlJlYWRPbmx5VThCdWZmZXJcIjtcbiAgICBXcmZQYXJhbVR5cGVbV3JmUGFyYW1UeXBlW1wiVThCdWZmZXJcIl0gPSAyXSA9IFwiVThCdWZmZXJcIjtcbiAgICBXcmZQYXJhbVR5cGVbV3JmUGFyYW1UeXBlW1wiRjMyQnVmZmVyXCJdID0gM10gPSBcIkYzMkJ1ZmZlclwiO1xuICAgIFdyZlBhcmFtVHlwZVtXcmZQYXJhbVR5cGVbXCJSZWFkT25seUYzMkJ1ZmZlclwiXSA9IDRdID0gXCJSZWFkT25seUYzMkJ1ZmZlclwiO1xufSkoV3JmUGFyYW1UeXBlIHx8IChXcmZQYXJhbVR5cGUgPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./types.ts\n");

/***/ }),

/***/ "./webgl_renderer.ts":
/*!***************************!*\
  !*** ./webgl_renderer.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebGLRenderer\": () => (/* binding */ WebGLRenderer)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n/* harmony import */ var _zerde__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zerde */ \"./zerde.ts\");\n\n\nclass WebGLRenderer {\n    constructor(canvas, memory, sizingData, incompatibleBrowserCallback) {\n        this.uniformFnTable = {\n            float: function setFloat(self, loc, off) {\n                const slot = off >> 2;\n                self.gl.uniform1f(loc, self.basef32[slot]);\n            },\n            vec2: function setVec2(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform2f(loc, basef32[slot], basef32[slot + 1]);\n            },\n            vec3: function setVec3(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform3f(loc, basef32[slot], basef32[slot + 1], basef32[slot + 2]);\n            },\n            vec4: function setVec4(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform4f(loc, basef32[slot], basef32[slot + 1], basef32[slot + 2], basef32[slot + 3]);\n            },\n            mat2: function setMat2(self, loc, off) {\n                self.gl.uniformMatrix2fv(loc, false, new Float32Array(self.memory.buffer, off, 4));\n            },\n            mat3: function setMat3(self, loc, off) {\n                self.gl.uniformMatrix3fv(loc, false, new Float32Array(self.memory.buffer, off, 9));\n            },\n            mat4: function setMat4(self, loc, off) {\n                const mat4 = new Float32Array(self.memory.buffer, off, 16);\n                self.gl.uniformMatrix4fv(loc, false, mat4);\n            },\n        };\n        // Array of function id's wasm can call on us; `self` is pointer to WebGLRenderer.\n        // Function names are suffixed with the index in the array, and annotated with\n        // their name in cx_webgl.rs, for easier matching.\n        this.sendFnTable = [\n            // end\n            function end0(_self) {\n                return true;\n            },\n            // compile_webgl_shader\n            function compileWebGLShader1(self) {\n                function parseShvarvec() {\n                    const len = self.zerdeParser.parseU32();\n                    const vars = [];\n                    for (let i = 0; i < len; i++) {\n                        vars.push({\n                            ty: self.zerdeParser.parseString(),\n                            name: self.zerdeParser.parseString(),\n                        });\n                    }\n                    return vars;\n                }\n                const ash = {\n                    shaderId: self.zerdeParser.parseU32(),\n                    fragment: self.zerdeParser.parseString(),\n                    vertex: self.zerdeParser.parseString(),\n                    geometrySlots: self.zerdeParser.parseU32(),\n                    instanceSlots: self.zerdeParser.parseU32(),\n                    passUniforms: parseShvarvec(),\n                    viewUniforms: parseShvarvec(),\n                    drawUniforms: parseShvarvec(),\n                    userUniforms: parseShvarvec(),\n                    textureSlots: parseShvarvec(),\n                };\n                self.compileWebGLShader(ash);\n            },\n            // alloc_array_buffer\n            function allocArrayBuffer2(self) {\n                const arrayBufferId = self.zerdeParser.parseU32();\n                const len = self.zerdeParser.parseU32();\n                const pointer = self.zerdeParser.parseU32();\n                const array = new Float32Array(self.memory.buffer, pointer, len);\n                self.allocArrayBuffer(arrayBufferId, array);\n            },\n            // alloc_index_buffer\n            function allocIndexBuffer3(self) {\n                const indexBufferId = self.zerdeParser.parseU32();\n                const len = self.zerdeParser.parseU32();\n                const pointer = self.zerdeParser.parseU32();\n                const array = new Uint32Array(self.memory.buffer, pointer, len);\n                self.allocIndexBuffer(indexBufferId, array);\n            },\n            // alloc_vao\n            function allocVao4(self) {\n                const vaoId = self.zerdeParser.parseU32();\n                const shaderId = self.zerdeParser.parseU32();\n                const geomIbId = self.zerdeParser.parseU32();\n                const geomVbId = self.zerdeParser.parseU32();\n                const instVbId = self.zerdeParser.parseU32();\n                self.allocVao(vaoId, shaderId, geomIbId, geomVbId, instVbId);\n            },\n            // draw_call\n            function drawCall5(self) {\n                const shaderId = self.zerdeParser.parseU32();\n                const vaoId = self.zerdeParser.parseU32();\n                const uniformsPassPtr = self.zerdeParser.parseU32();\n                const uniformsViewPtr = self.zerdeParser.parseU32();\n                const uniformsDrawPtr = self.zerdeParser.parseU32();\n                const uniformsUserPtr = self.zerdeParser.parseU32();\n                const textures = self.zerdeParser.parseU32();\n                self.drawCall(shaderId, vaoId, uniformsPassPtr, uniformsViewPtr, uniformsDrawPtr, uniformsUserPtr, textures);\n            },\n            // update_texture_image2d\n            function allocTexture6(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const width = self.zerdeParser.parseU32();\n                const height = self.zerdeParser.parseU32();\n                const dataPtr = self.zerdeParser.parseU32();\n                self.allocTexture(textureId, width, height, dataPtr);\n            },\n            // begin_render_targets\n            function beginRenderTargets7(self) {\n                const passId = self.zerdeParser.parseU32();\n                const width = self.zerdeParser.parseU32();\n                const height = self.zerdeParser.parseU32();\n                self.beginRenderTargets(passId, width, height);\n            },\n            // add_color_target\n            function addColorTarget8(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const initOnly = self.zerdeParser.parseU32();\n                const r = self.zerdeParser.parseF32();\n                const g = self.zerdeParser.parseF32();\n                const b = self.zerdeParser.parseF32();\n                const a = self.zerdeParser.parseF32();\n                self.addColorTarget(textureId, initOnly, r, g, b, a);\n            },\n            // set_depth_target\n            function setDepthTarget9(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const initOnly = self.zerdeParser.parseU32();\n                const depth = self.zerdeParser.parseF32();\n                self.setDepthTarget(textureId, initOnly, depth);\n            },\n            // end_render_targets\n            function endRenderTargets10(self) {\n                self.endRenderTargets();\n            },\n            // set_default_depth_and_blend_mode\n            function setDefaultDepthAndBlendMode11(self) {\n                self.setDefaultDepthAndBlendMode();\n            },\n            // begin_main_canvas\n            function beginMainCanvas12(self) {\n                const r = self.zerdeParser.parseF32();\n                const g = self.zerdeParser.parseF32();\n                const b = self.zerdeParser.parseF32();\n                const a = self.zerdeParser.parseF32();\n                const depth = self.zerdeParser.parseF32();\n                self.beginMainCanvas(r, g, b, a, depth);\n            },\n        ];\n        this.canvas = canvas;\n        this.memory = memory;\n        this.sizingData = sizingData;\n        this.shaders = [];\n        this.indexBuffers = [];\n        this.arrayBuffers = [];\n        this.vaos = [];\n        this.textures = [];\n        this.framebuffers = [];\n        this.targetWidth = 0;\n        this.targetHeight = 0;\n        this.clearFlags = 0;\n        this.clearR = 0;\n        this.clearG = 0;\n        this.clearB = 0;\n        this.clearA = 0;\n        this.clearDepth = 0;\n        // this.isMainCanvas = false;\n        const options = {\n            preferLowPowerToHighPerformance: true,\n            // xrCompatible: true // TODO(JP): Bring back some day?\n        };\n        // @ts-ignore - TODO(Paras): Get proper support for OffscreenCanvas\n        this.gl =\n            // @ts-ignore\n            canvas.getContext(\"webgl\", options) ||\n                // @ts-ignore\n                canvas.getContext(\"webgl-experimental\", options) ||\n                // @ts-ignore\n                canvas.getContext(\"experimental-webgl\", options);\n        if (!this.gl) {\n            incompatibleBrowserCallback();\n            return;\n        }\n        this.OESVertexArrayObject = (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertNotNull)(this.gl.getExtension(\"OES_vertex_array_object\"));\n        this.ANGLEInstancedArrays = (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertNotNull)(this.gl.getExtension(\"ANGLE_instanced_arrays\"));\n        this.gl.getExtension(\"OES_standard_derivatives\");\n        this.gl.getExtension(\"OES_element_index_uint\");\n        this.resize(sizingData);\n    }\n    processMessages(zerdeParserPtr) {\n        this.zerdeParser = new _zerde__WEBPACK_IMPORTED_MODULE_1__.ZerdeParser(this.memory, zerdeParserPtr);\n        this.basef32 = new Float32Array(this.memory.buffer);\n        this.baseu32 = new Uint32Array(this.memory.buffer);\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const msgType = this.zerdeParser.parseU32();\n            if (this.sendFnTable[msgType](this)) {\n                break;\n            }\n        }\n    }\n    resize(sizingData) {\n        this.sizingData = sizingData;\n        this.canvas.width = sizingData.width * sizingData.dpiFactor;\n        this.canvas.height = sizingData.height * sizingData.dpiFactor;\n    }\n    getAttribLocations(program, base, slots) {\n        const gl = this.gl;\n        const attribLocs = [];\n        let attribs = slots >> 2;\n        if ((slots & 3) != 0)\n            attribs++;\n        for (let i = 0; i < attribs; i++) {\n            let size = slots - i * 4;\n            if (size > 4)\n                size = 4;\n            attribLocs.push({\n                loc: gl.getAttribLocation(program, base + i),\n                offset: i * 16,\n                size: size,\n                stride: slots * 4,\n            });\n        }\n        return attribLocs;\n    }\n    getUniformLocations(program, uniforms) {\n        const gl = this.gl;\n        const uniformLocs = [];\n        let offset = 0;\n        for (let i = 0; i < uniforms.length; i++) {\n            const uniform = uniforms[i];\n            // lets align the uniform\n            const slots = uniformSizeTable[uniform.ty];\n            if ((offset & 3) != 0 && (offset & 3) + slots > 4) {\n                // goes over the boundary\n                offset += 4 - (offset & 3); // make jump to new slot\n            }\n            uniformLocs.push({\n                name: uniform.name,\n                offset: offset << 2,\n                ty: uniform.ty,\n                loc: gl.getUniformLocation(program, uniform.name),\n                fn: this.uniformFnTable[uniform.ty],\n            });\n            offset += slots;\n        }\n        return uniformLocs;\n    }\n    compileWebGLShader(ash) {\n        const gl = this.gl;\n        const vsh = (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertNotNull)(gl.createShader(gl.VERTEX_SHADER));\n        gl.shaderSource(vsh, ash.vertex);\n        gl.compileShader(vsh);\n        if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {\n            console.log(gl.getShaderInfoLog(vsh), addLineNumbersToString(ash.vertex));\n        }\n        // compile pixelshader\n        const fsh = (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertNotNull)(gl.createShader(gl.FRAGMENT_SHADER));\n        gl.shaderSource(fsh, ash.fragment);\n        gl.compileShader(fsh);\n        if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {\n            console.log(gl.getShaderInfoLog(fsh), addLineNumbersToString(ash.fragment));\n        }\n        const program = (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertNotNull)(gl.createProgram());\n        gl.attachShader(program, vsh);\n        gl.attachShader(program, fsh);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            console.log(gl.getProgramInfoLog(program), addLineNumbersToString(ash.vertex), addLineNumbersToString(ash.fragment));\n        }\n        // fetch all attribs and uniforms\n        this.shaders[ash.shaderId] = {\n            geomAttribs: this.getAttribLocations(program, \"mpsc_packed_geometry_\", ash.geometrySlots),\n            instAttribs: this.getAttribLocations(program, \"mpsc_packed_instance_\", ash.instanceSlots),\n            passUniforms: this.getUniformLocations(program, ash.passUniforms),\n            viewUniforms: this.getUniformLocations(program, ash.viewUniforms),\n            drawUniforms: this.getUniformLocations(program, ash.drawUniforms),\n            userUniforms: this.getUniformLocations(program, ash.userUniforms),\n            textureSlots: this.getUniformLocations(program, ash.textureSlots),\n            instanceSlots: ash.instanceSlots,\n            program: program,\n            ash: ash,\n        };\n    }\n    allocArrayBuffer(arrayBufferId, array) {\n        const gl = this.gl;\n        let buf = this.arrayBuffers[arrayBufferId];\n        if (buf === undefined) {\n            buf = this.arrayBuffers[arrayBufferId] = {\n                glBuf: (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertNotNull)(gl.createBuffer()),\n                length: array.length,\n            };\n        }\n        else {\n            buf.length = array.length;\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, buf.glBuf);\n        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n    allocIndexBuffer(indexBufferId, array) {\n        const gl = this.gl;\n        let buf = this.indexBuffers[indexBufferId];\n        if (buf === undefined) {\n            buf = this.indexBuffers[indexBufferId] = {\n                glBuf: (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertNotNull)(gl.createBuffer()),\n                length: array.length,\n            };\n        }\n        else {\n            buf.length = array.length;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.glBuf);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    allocVao(vaoId, shaderId, geomIbId, geomVbId, instVbId) {\n        const gl = this.gl;\n        const oldVao = this.vaos[vaoId];\n        if (oldVao) {\n            this.OESVertexArrayObject.deleteVertexArrayOES(oldVao.glVao);\n        }\n        const glVao = (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertNotNull)(this.OESVertexArrayObject.createVertexArrayOES());\n        const vao = (this.vaos[vaoId] = { glVao, geomIbId, geomVbId, instVbId });\n        this.OESVertexArrayObject.bindVertexArrayOES(vao.glVao);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffers[geomVbId].glBuf);\n        const shader = this.shaders[shaderId];\n        for (let i = 0; i < shader.geomAttribs.length; i++) {\n            const attr = shader.geomAttribs[i];\n            if (attr.loc < 0) {\n                continue;\n            }\n            gl.vertexAttribPointer(attr.loc, attr.size, gl.FLOAT, false, attr.stride, attr.offset);\n            gl.enableVertexAttribArray(attr.loc);\n            this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(attr.loc, 0);\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffers[instVbId].glBuf);\n        for (let i = 0; i < shader.instAttribs.length; i++) {\n            const attr = shader.instAttribs[i];\n            if (attr.loc < 0) {\n                continue;\n            }\n            gl.vertexAttribPointer(attr.loc, attr.size, gl.FLOAT, false, attr.stride, attr.offset);\n            gl.enableVertexAttribArray(attr.loc);\n            this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(attr.loc, 1);\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffers[geomIbId].glBuf);\n        this.OESVertexArrayObject.bindVertexArrayOES(null);\n    }\n    drawCall(shaderId, vaoId, passUniformsPtr, viewUniformsPtr, drawUniformsPtr, userUniformsPtr, texturesPtr) {\n        const gl = this.gl;\n        const shader = this.shaders[shaderId];\n        gl.useProgram(shader.program);\n        const vao = this.vaos[vaoId];\n        this.OESVertexArrayObject.bindVertexArrayOES(vao.glVao);\n        const indexBuffer = this.indexBuffers[vao.geomIbId];\n        const instanceBuffer = this.arrayBuffers[vao.instVbId];\n        // set up uniforms TODO do this a bit more incremental based on uniform layer\n        // also possibly use webGL2 uniform buffers. For now this will suffice for webGL 1 compat\n        const passUniforms = shader.passUniforms;\n        // if vr_presenting\n        const viewUniforms = shader.viewUniforms;\n        for (let i = 0; i < viewUniforms.length; i++) {\n            const uni = viewUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + viewUniformsPtr);\n        }\n        const drawUniforms = shader.drawUniforms;\n        for (let i = 0; i < drawUniforms.length; i++) {\n            const uni = drawUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + drawUniformsPtr);\n        }\n        const userUniforms = shader.userUniforms;\n        for (let i = 0; i < userUniforms.length; i++) {\n            const uni = userUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + userUniformsPtr);\n        }\n        const textureSlots = shader.textureSlots;\n        for (let i = 0; i < textureSlots.length; i++) {\n            const texSlot = textureSlots[i];\n            const texId = this.baseu32[(texturesPtr >> 2) + i];\n            const texObj = this.textures[texId];\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, texObj);\n            gl.uniform1i(texSlot.loc, i);\n        }\n        const indices = indexBuffer.length;\n        const instances = instanceBuffer.length / shader.instanceSlots;\n        // if (this.isMainCanvas && xrIsPresenting) {\n        // for (let i = 3; i < pass_uniforms.length; i ++) {\n        //     let uni = pass_uniforms[i];\n        //     uni.fn(this, uni.loc, uni.offset + pass_uniforms_ptr);\n        // }\n        // // the first 2 matrices are project and view\n        // let left_viewport = this.xr_left_viewport;\n        // gl.viewport(left_viewport.x, left_viewport.y, left_viewport.width, left_viewport.height);\n        // gl.uniformMatrix4fv(pass_uniforms[0].loc, false, this.xr_left_projection_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[1].loc, false, this.xr_left_transform_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[2].loc, false, this.xr_left_invtransform_matrix);\n        // this.ANGLE_instanced_arrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // let right_viewport = this.xr_right_viewport;\n        // gl.viewport(right_viewport.x, right_viewport.y, right_viewport.width, right_viewport.height);\n        // gl.uniformMatrix4fv(pass_uniforms[0].loc, false, this.xr_right_projection_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[1].loc, false, this.xr_right_transform_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[2].loc, false, this.xr_right_invtransform_matrix);\n        // this.ANGLE_instanced_arrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // } else {\n        for (let i = 0; i < passUniforms.length; i++) {\n            const uni = passUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + passUniformsPtr);\n        }\n        this.ANGLEInstancedArrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // }\n        this.OESVertexArrayObject.bindVertexArrayOES(null);\n    }\n    allocTexture(textureId, width, height, dataPtr) {\n        const gl = this.gl;\n        const glTex = this.textures[textureId] || gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, glTex);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        const data = new Uint8Array(this.memory.buffer, dataPtr, width * height * 4);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        this.textures[textureId] = glTex;\n    }\n    beginRenderTargets(passId, width, height) {\n        const gl = this.gl;\n        this.targetWidth = width;\n        this.targetHeight = height;\n        this.clearFlags = 0;\n        // this.isMainCanvas = false;\n        const glFramebuffer = this.framebuffers[passId] ||\n            (this.framebuffers[passId] = (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertNotNull)(gl.createFramebuffer()));\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glFramebuffer);\n    }\n    addColorTarget(textureId, initOnly, r, g, b, a) {\n        // if use_default\n        this.clearR = r;\n        this.clearG = g;\n        this.clearB = b;\n        this.clearA = a;\n        const gl = this.gl;\n        const glTex = this.textures[textureId] ||\n            (this.textures[textureId] = gl.createTexture());\n        // resize or create texture\n        if (glTex.mpWidth != this.targetWidth ||\n            glTex.mpHeight != this.targetHeight) {\n            gl.bindTexture(gl.TEXTURE_2D, glTex);\n            this.clearFlags |= gl.COLOR_BUFFER_BIT;\n            glTex.mpWidth = this.targetWidth;\n            glTex.mpHeight = this.targetHeight;\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, glTex.mpWidth, glTex.mpHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n        else if (!initOnly) {\n            this.clearFlags |= gl.COLOR_BUFFER_BIT;\n        }\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTex, 0);\n    }\n    setDepthTarget(textureId, initOnly, depth) {\n        const gl = this.gl;\n        this.clearDepth = depth;\n        const glRenderBuffer = this.textures[textureId] ||\n            (this.textures[textureId] = gl.createRenderbuffer());\n        if (glRenderBuffer.mpWidth != this.targetWidth ||\n            glRenderBuffer.mpHeight != this.targetHeight) {\n            // Borrowed concept from https://webglfundamentals.org/webgl/lessons/webgl-render-to-texture.html\n            gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderBuffer);\n            this.clearFlags |= gl.DEPTH_BUFFER_BIT;\n            glRenderBuffer.mpWidth = this.targetWidth;\n            glRenderBuffer.mpHeight = this.targetHeight;\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.targetWidth, this.targetHeight);\n        }\n        else if (!initOnly) {\n            this.clearFlags |= gl.DEPTH_BUFFER_BIT;\n        }\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, glRenderBuffer);\n    }\n    endRenderTargets() {\n        const gl = this.gl;\n        // process the actual 'clear'\n        gl.viewport(0, 0, this.targetWidth, this.targetHeight);\n        // check if we need to clear color, and depth\n        // clear it\n        if (this.clearFlags) {\n            gl.clearColor(this.clearR, this.clearG, this.clearB, this.clearA);\n            gl.clearDepth(this.clearDepth);\n            gl.clear(this.clearFlags);\n        }\n    }\n    setDefaultDepthAndBlendMode() {\n        const gl = this.gl;\n        gl.enable(gl.DEPTH_TEST);\n        gl.depthFunc(gl.LEQUAL);\n        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n    }\n    beginMainCanvas(r, g, b, a, depth) {\n        const gl = this.gl;\n        // this.isMainCanvas = true;\n        // if (this.xrIsPresenting) {\n        // let xr_webgllayer = this.xr_session.renderState.baseLayer;\n        // this.gl.bindFramebuffer(gl.FRAMEBUFFER, xr_webgllayer.framebuffer);\n        // gl.viewport(0, 0, xr_webgllayer.framebufferWidth, xr_webgllayer.framebufferHeight);\n        // // quest 1 is 3648\n        // // quest 2 is 4096\n        // let left_view = this.xr_pose.views[0];\n        // let right_view = this.xr_pose.views[1];\n        // this.xr_left_viewport = xr_webgllayer.getViewport(left_view);\n        // this.xr_right_viewport = xr_webgllayer.getViewport(right_view);\n        // this.xr_left_projection_matrix = left_view.projectionMatrix;\n        // this.xr_left_transform_matrix = left_view.transform.inverse.matrix;\n        // this.xr_left_invtransform_matrix = left_view.transform.matrix;\n        // this.xr_right_projection_matrix = right_view.projectionMatrix;\n        // this.xr_right_transform_matrix = right_view.transform.inverse.matrix;\n        // this.xr_right_camera_pos = right_view.transform.inverse.position;\n        // this.xr_right_invtransform_matrix = right_view.transform.matrix;\n        // } else {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, this.sizingData.width * this.sizingData.dpiFactor, this.sizingData.height * this.sizingData.dpiFactor);\n        // }\n        gl.clearColor(r, g, b, a);\n        gl.clearDepth(depth);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    }\n}\nconst uniformSizeTable = {\n    float: 1,\n    vec2: 2,\n    vec3: 3,\n    vec4: 4,\n    mat2: 4,\n    mat3: 9,\n    mat4: 16,\n};\nfunction addLineNumbersToString(code) {\n    const lines = code.split(\"\\n\");\n    let out = \"\";\n    for (let i = 0; i < lines.length; i++) {\n        out += i + 1 + \": \" + lines[i] + \"\\n\";\n    }\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93ZWJnbF9yZW5kZXJlci50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cmYvLi93ZWJnbF9yZW5kZXJlci50cz83MzY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydE5vdE51bGwgfSBmcm9tIFwiLi9jb21tb25cIjtcbmltcG9ydCB7IFplcmRlUGFyc2VyIH0gZnJvbSBcIi4vemVyZGVcIjtcbmV4cG9ydCBjbGFzcyBXZWJHTFJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMsIG1lbW9yeSwgc2l6aW5nRGF0YSwgaW5jb21wYXRpYmxlQnJvd3NlckNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybUZuVGFibGUgPSB7XG4gICAgICAgICAgICBmbG9hdDogZnVuY3Rpb24gc2V0RmxvYXQoc2VsZiwgbG9jLCBvZmYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90ID0gb2ZmID4+IDI7XG4gICAgICAgICAgICAgICAgc2VsZi5nbC51bmlmb3JtMWYobG9jLCBzZWxmLmJhc2VmMzJbc2xvdF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlYzI6IGZ1bmN0aW9uIHNldFZlYzIoc2VsZiwgbG9jLCBvZmYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90ID0gb2ZmID4+IDI7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZWYzMiA9IHNlbGYuYmFzZWYzMjtcbiAgICAgICAgICAgICAgICBzZWxmLmdsLnVuaWZvcm0yZihsb2MsIGJhc2VmMzJbc2xvdF0sIGJhc2VmMzJbc2xvdCArIDFdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2ZWMzOiBmdW5jdGlvbiBzZXRWZWMzKHNlbGYsIGxvYywgb2ZmKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdCA9IG9mZiA+PiAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VmMzIgPSBzZWxmLmJhc2VmMzI7XG4gICAgICAgICAgICAgICAgc2VsZi5nbC51bmlmb3JtM2YobG9jLCBiYXNlZjMyW3Nsb3RdLCBiYXNlZjMyW3Nsb3QgKyAxXSwgYmFzZWYzMltzbG90ICsgMl0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlYzQ6IGZ1bmN0aW9uIHNldFZlYzQoc2VsZiwgbG9jLCBvZmYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90ID0gb2ZmID4+IDI7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZWYzMiA9IHNlbGYuYmFzZWYzMjtcbiAgICAgICAgICAgICAgICBzZWxmLmdsLnVuaWZvcm00Zihsb2MsIGJhc2VmMzJbc2xvdF0sIGJhc2VmMzJbc2xvdCArIDFdLCBiYXNlZjMyW3Nsb3QgKyAyXSwgYmFzZWYzMltzbG90ICsgM10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hdDI6IGZ1bmN0aW9uIHNldE1hdDIoc2VsZiwgbG9jLCBvZmYpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdsLnVuaWZvcm1NYXRyaXgyZnYobG9jLCBmYWxzZSwgbmV3IEZsb2F0MzJBcnJheShzZWxmLm1lbW9yeS5idWZmZXIsIG9mZiwgNCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hdDM6IGZ1bmN0aW9uIHNldE1hdDMoc2VsZiwgbG9jLCBvZmYpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdsLnVuaWZvcm1NYXRyaXgzZnYobG9jLCBmYWxzZSwgbmV3IEZsb2F0MzJBcnJheShzZWxmLm1lbW9yeS5idWZmZXIsIG9mZiwgOSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hdDQ6IGZ1bmN0aW9uIHNldE1hdDQoc2VsZiwgbG9jLCBvZmYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXQ0ID0gbmV3IEZsb2F0MzJBcnJheShzZWxmLm1lbW9yeS5idWZmZXIsIG9mZiwgMTYpO1xuICAgICAgICAgICAgICAgIHNlbGYuZ2wudW5pZm9ybU1hdHJpeDRmdihsb2MsIGZhbHNlLCBtYXQ0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFycmF5IG9mIGZ1bmN0aW9uIGlkJ3Mgd2FzbSBjYW4gY2FsbCBvbiB1czsgYHNlbGZgIGlzIHBvaW50ZXIgdG8gV2ViR0xSZW5kZXJlci5cbiAgICAgICAgLy8gRnVuY3Rpb24gbmFtZXMgYXJlIHN1ZmZpeGVkIHdpdGggdGhlIGluZGV4IGluIHRoZSBhcnJheSwgYW5kIGFubm90YXRlZCB3aXRoXG4gICAgICAgIC8vIHRoZWlyIG5hbWUgaW4gY3hfd2ViZ2wucnMsIGZvciBlYXNpZXIgbWF0Y2hpbmcuXG4gICAgICAgIHRoaXMuc2VuZEZuVGFibGUgPSBbXG4gICAgICAgICAgICAvLyBlbmRcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVuZDAoX3NlbGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBjb21waWxlX3dlYmdsX3NoYWRlclxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGlsZVdlYkdMU2hhZGVyMShzZWxmKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VTaHZhcnZlYygpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHk6IHNlbGYuemVyZGVQYXJzZXIucGFyc2VTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZWxmLnplcmRlUGFyc2VyLnBhcnNlU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXNoID0ge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXJJZDogc2VsZi56ZXJkZVBhcnNlci5wYXJzZVUzMigpLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogc2VsZi56ZXJkZVBhcnNlci5wYXJzZVN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXg6IHNlbGYuemVyZGVQYXJzZXIucGFyc2VTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlTbG90czogc2VsZi56ZXJkZVBhcnNlci5wYXJzZVUzMigpLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVNsb3RzOiBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCksXG4gICAgICAgICAgICAgICAgICAgIHBhc3NVbmlmb3JtczogcGFyc2VTaHZhcnZlYygpLFxuICAgICAgICAgICAgICAgICAgICB2aWV3VW5pZm9ybXM6IHBhcnNlU2h2YXJ2ZWMoKSxcbiAgICAgICAgICAgICAgICAgICAgZHJhd1VuaWZvcm1zOiBwYXJzZVNodmFydmVjKCksXG4gICAgICAgICAgICAgICAgICAgIHVzZXJVbmlmb3JtczogcGFyc2VTaHZhcnZlYygpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlU2xvdHM6IHBhcnNlU2h2YXJ2ZWMoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlbGYuY29tcGlsZVdlYkdMU2hhZGVyKGFzaCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYWxsb2NfYXJyYXlfYnVmZmVyXG4gICAgICAgICAgICBmdW5jdGlvbiBhbGxvY0FycmF5QnVmZmVyMihzZWxmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXJJZCA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoc2VsZi5tZW1vcnkuYnVmZmVyLCBwb2ludGVyLCBsZW4pO1xuICAgICAgICAgICAgICAgIHNlbGYuYWxsb2NBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcklkLCBhcnJheSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYWxsb2NfaW5kZXhfYnVmZmVyXG4gICAgICAgICAgICBmdW5jdGlvbiBhbGxvY0luZGV4QnVmZmVyMyhzZWxmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhCdWZmZXJJZCA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheShzZWxmLm1lbW9yeS5idWZmZXIsIHBvaW50ZXIsIGxlbik7XG4gICAgICAgICAgICAgICAgc2VsZi5hbGxvY0luZGV4QnVmZmVyKGluZGV4QnVmZmVySWQsIGFycmF5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhbGxvY192YW9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFsbG9jVmFvNChzZWxmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFvSWQgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhZGVySWQgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbUliSWQgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbVZiSWQgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdFZiSWQgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5hbGxvY1Zhbyh2YW9JZCwgc2hhZGVySWQsIGdlb21JYklkLCBnZW9tVmJJZCwgaW5zdFZiSWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGRyYXdfY2FsbFxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd0NhbGw1KHNlbGYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFkZXJJZCA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YW9JZCA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlmb3Jtc1Bhc3NQdHIgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5pZm9ybXNWaWV3UHRyID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuaWZvcm1zRHJhd1B0ciA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlmb3Jtc1VzZXJQdHIgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZXMgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5kcmF3Q2FsbChzaGFkZXJJZCwgdmFvSWQsIHVuaWZvcm1zUGFzc1B0ciwgdW5pZm9ybXNWaWV3UHRyLCB1bmlmb3Jtc0RyYXdQdHIsIHVuaWZvcm1zVXNlclB0ciwgdGV4dHVyZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHVwZGF0ZV90ZXh0dXJlX2ltYWdlMmRcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFsbG9jVGV4dHVyZTYoc2VsZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVJZCA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVB0ciA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFsbG9jVGV4dHVyZSh0ZXh0dXJlSWQsIHdpZHRoLCBoZWlnaHQsIGRhdGFQdHIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGJlZ2luX3JlbmRlcl90YXJnZXRzXG4gICAgICAgICAgICBmdW5jdGlvbiBiZWdpblJlbmRlclRhcmdldHM3KHNlbGYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXNzSWQgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIHNlbGYuYmVnaW5SZW5kZXJUYXJnZXRzKHBhc3NJZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYWRkX2NvbG9yX3RhcmdldFxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkQ29sb3JUYXJnZXQ4KHNlbGYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlSWQgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdE9ubHkgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VGMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZUYzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlRjMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VGMzIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZENvbG9yVGFyZ2V0KHRleHR1cmVJZCwgaW5pdE9ubHksIHIsIGcsIGIsIGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHNldF9kZXB0aF90YXJnZXRcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldERlcHRoVGFyZ2V0OShzZWxmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZUlkID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRPbmx5ID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZUYzMigpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RGVwdGhUYXJnZXQodGV4dHVyZUlkLCBpbml0T25seSwgZGVwdGgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVuZF9yZW5kZXJfdGFyZ2V0c1xuICAgICAgICAgICAgZnVuY3Rpb24gZW5kUmVuZGVyVGFyZ2V0czEwKHNlbGYpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZFJlbmRlclRhcmdldHMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBzZXRfZGVmYXVsdF9kZXB0aF9hbmRfYmxlbmRfbW9kZVxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0RGVmYXVsdERlcHRoQW5kQmxlbmRNb2RlMTEoc2VsZikge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RGVmYXVsdERlcHRoQW5kQmxlbmRNb2RlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYmVnaW5fbWFpbl9jYW52YXNcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJlZ2luTWFpbkNhbnZhczEyKHNlbGYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZUYzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBzZWxmLnplcmRlUGFyc2VyLnBhcnNlRjMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IHNlbGYuemVyZGVQYXJzZXIucGFyc2VGMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZUYzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gc2VsZi56ZXJkZVBhcnNlci5wYXJzZUYzMigpO1xuICAgICAgICAgICAgICAgIHNlbGYuYmVnaW5NYWluQ2FudmFzKHIsIGcsIGIsIGEsIGRlcHRoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLm1lbW9yeSA9IG1lbW9yeTtcbiAgICAgICAgdGhpcy5zaXppbmdEYXRhID0gc2l6aW5nRGF0YTtcbiAgICAgICAgdGhpcy5zaGFkZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXJzID0gW107XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXJzID0gW107XG4gICAgICAgIHRoaXMudmFvcyA9IFtdO1xuICAgICAgICB0aGlzLnRleHR1cmVzID0gW107XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXJzID0gW107XG4gICAgICAgIHRoaXMudGFyZ2V0V2lkdGggPSAwO1xuICAgICAgICB0aGlzLnRhcmdldEhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuY2xlYXJGbGFncyA9IDA7XG4gICAgICAgIHRoaXMuY2xlYXJSID0gMDtcbiAgICAgICAgdGhpcy5jbGVhckcgPSAwO1xuICAgICAgICB0aGlzLmNsZWFyQiA9IDA7XG4gICAgICAgIHRoaXMuY2xlYXJBID0gMDtcbiAgICAgICAgdGhpcy5jbGVhckRlcHRoID0gMDtcbiAgICAgICAgLy8gdGhpcy5pc01haW5DYW52YXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByZWZlckxvd1Bvd2VyVG9IaWdoUGVyZm9ybWFuY2U6IHRydWUsXG4gICAgICAgICAgICAvLyB4ckNvbXBhdGlibGU6IHRydWUgLy8gVE9ETyhKUCk6IEJyaW5nIGJhY2sgc29tZSBkYXk/XG4gICAgICAgIH07XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUT0RPKFBhcmFzKTogR2V0IHByb3BlciBzdXBwb3J0IGZvciBPZmZzY3JlZW5DYW52YXNcbiAgICAgICAgdGhpcy5nbCA9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIG9wdGlvbnMpIHx8XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wtZXhwZXJpbWVudGFsXCIsIG9wdGlvbnMpIHx8XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMuZ2wpIHtcbiAgICAgICAgICAgIGluY29tcGF0aWJsZUJyb3dzZXJDYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuT0VTVmVydGV4QXJyYXlPYmplY3QgPSBhc3NlcnROb3ROdWxsKHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIikpO1xuICAgICAgICB0aGlzLkFOR0xFSW5zdGFuY2VkQXJyYXlzID0gYXNzZXJ0Tm90TnVsbCh0aGlzLmdsLmdldEV4dGVuc2lvbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIikpO1xuICAgICAgICB0aGlzLmdsLmdldEV4dGVuc2lvbihcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKTtcbiAgICAgICAgdGhpcy5nbC5nZXRFeHRlbnNpb24oXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCIpO1xuICAgICAgICB0aGlzLnJlc2l6ZShzaXppbmdEYXRhKTtcbiAgICB9XG4gICAgcHJvY2Vzc01lc3NhZ2VzKHplcmRlUGFyc2VyUHRyKSB7XG4gICAgICAgIHRoaXMuemVyZGVQYXJzZXIgPSBuZXcgWmVyZGVQYXJzZXIodGhpcy5tZW1vcnksIHplcmRlUGFyc2VyUHRyKTtcbiAgICAgICAgdGhpcy5iYXNlZjMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICB0aGlzLmJhc2V1MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5tZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnVHlwZSA9IHRoaXMuemVyZGVQYXJzZXIucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbmRGblRhYmxlW21zZ1R5cGVdKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplKHNpemluZ0RhdGEpIHtcbiAgICAgICAgdGhpcy5zaXppbmdEYXRhID0gc2l6aW5nRGF0YTtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBzaXppbmdEYXRhLndpZHRoICogc2l6aW5nRGF0YS5kcGlGYWN0b3I7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHNpemluZ0RhdGEuaGVpZ2h0ICogc2l6aW5nRGF0YS5kcGlGYWN0b3I7XG4gICAgfVxuICAgIGdldEF0dHJpYkxvY2F0aW9ucyhwcm9ncmFtLCBiYXNlLCBzbG90cykge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGNvbnN0IGF0dHJpYkxvY3MgPSBbXTtcbiAgICAgICAgbGV0IGF0dHJpYnMgPSBzbG90cyA+PiAyO1xuICAgICAgICBpZiAoKHNsb3RzICYgMykgIT0gMClcbiAgICAgICAgICAgIGF0dHJpYnMrKztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gc2xvdHMgLSBpICogNDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNClcbiAgICAgICAgICAgICAgICBzaXplID0gNDtcbiAgICAgICAgICAgIGF0dHJpYkxvY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBiYXNlICsgaSksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBpICogMTYsXG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICBzdHJpZGU6IHNsb3RzICogNCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyaWJMb2NzO1xuICAgIH1cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zKHByb2dyYW0sIHVuaWZvcm1zKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgY29uc3QgdW5pZm9ybUxvY3MgPSBbXTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5pZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaWZvcm0gPSB1bmlmb3Jtc1tpXTtcbiAgICAgICAgICAgIC8vIGxldHMgYWxpZ24gdGhlIHVuaWZvcm1cbiAgICAgICAgICAgIGNvbnN0IHNsb3RzID0gdW5pZm9ybVNpemVUYWJsZVt1bmlmb3JtLnR5XTtcbiAgICAgICAgICAgIGlmICgob2Zmc2V0ICYgMykgIT0gMCAmJiAob2Zmc2V0ICYgMykgKyBzbG90cyA+IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBnb2VzIG92ZXIgdGhlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICYgMyk7IC8vIG1ha2UganVtcCB0byBuZXcgc2xvdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5pZm9ybUxvY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogdW5pZm9ybS5uYW1lLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0IDw8IDIsXG4gICAgICAgICAgICAgICAgdHk6IHVuaWZvcm0udHksXG4gICAgICAgICAgICAgICAgbG9jOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybS5uYW1lKSxcbiAgICAgICAgICAgICAgICBmbjogdGhpcy51bmlmb3JtRm5UYWJsZVt1bmlmb3JtLnR5XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHNsb3RzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlmb3JtTG9jcztcbiAgICB9XG4gICAgY29tcGlsZVdlYkdMU2hhZGVyKGFzaCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGNvbnN0IHZzaCA9IGFzc2VydE5vdE51bGwoZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpKTtcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHZzaCwgYXNoLnZlcnRleCk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIodnNoKTtcbiAgICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodnNoLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2codnNoKSwgYWRkTGluZU51bWJlcnNUb1N0cmluZyhhc2gudmVydGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcGlsZSBwaXhlbHNoYWRlclxuICAgICAgICBjb25zdCBmc2ggPSBhc3NlcnROb3ROdWxsKGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpKTtcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKGZzaCwgYXNoLmZyYWdtZW50KTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihmc2gpO1xuICAgICAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmc2gsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyhmc2gpLCBhZGRMaW5lTnVtYmVyc1RvU3RyaW5nKGFzaC5mcmFnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBhc3NlcnROb3ROdWxsKGdsLmNyZWF0ZVByb2dyYW0oKSk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2c2gpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnNoKTtcbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pLCBhZGRMaW5lTnVtYmVyc1RvU3RyaW5nKGFzaC52ZXJ0ZXgpLCBhZGRMaW5lTnVtYmVyc1RvU3RyaW5nKGFzaC5mcmFnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZldGNoIGFsbCBhdHRyaWJzIGFuZCB1bmlmb3Jtc1xuICAgICAgICB0aGlzLnNoYWRlcnNbYXNoLnNoYWRlcklkXSA9IHtcbiAgICAgICAgICAgIGdlb21BdHRyaWJzOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhwcm9ncmFtLCBcIm1wc2NfcGFja2VkX2dlb21ldHJ5X1wiLCBhc2guZ2VvbWV0cnlTbG90cyksXG4gICAgICAgICAgICBpbnN0QXR0cmliczogdGhpcy5nZXRBdHRyaWJMb2NhdGlvbnMocHJvZ3JhbSwgXCJtcHNjX3BhY2tlZF9pbnN0YW5jZV9cIiwgYXNoLmluc3RhbmNlU2xvdHMpLFxuICAgICAgICAgICAgcGFzc1VuaWZvcm1zOiB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMocHJvZ3JhbSwgYXNoLnBhc3NVbmlmb3JtcyksXG4gICAgICAgICAgICB2aWV3VW5pZm9ybXM6IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhwcm9ncmFtLCBhc2gudmlld1VuaWZvcm1zKSxcbiAgICAgICAgICAgIGRyYXdVbmlmb3JtczogdGhpcy5nZXRVbmlmb3JtTG9jYXRpb25zKHByb2dyYW0sIGFzaC5kcmF3VW5pZm9ybXMpLFxuICAgICAgICAgICAgdXNlclVuaWZvcm1zOiB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMocHJvZ3JhbSwgYXNoLnVzZXJVbmlmb3JtcyksXG4gICAgICAgICAgICB0ZXh0dXJlU2xvdHM6IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhwcm9ncmFtLCBhc2gudGV4dHVyZVNsb3RzKSxcbiAgICAgICAgICAgIGluc3RhbmNlU2xvdHM6IGFzaC5pbnN0YW5jZVNsb3RzLFxuICAgICAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgICAgIGFzaDogYXNoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhbGxvY0FycmF5QnVmZmVyKGFycmF5QnVmZmVySWQsIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgbGV0IGJ1ZiA9IHRoaXMuYXJyYXlCdWZmZXJzW2FycmF5QnVmZmVySWRdO1xuICAgICAgICBpZiAoYnVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJ1ZiA9IHRoaXMuYXJyYXlCdWZmZXJzW2FycmF5QnVmZmVySWRdID0ge1xuICAgICAgICAgICAgICAgIGdsQnVmOiBhc3NlcnROb3ROdWxsKGdsLmNyZWF0ZUJ1ZmZlcigpKSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWYubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWYuZ2xCdWYpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIH1cbiAgICBhbGxvY0luZGV4QnVmZmVyKGluZGV4QnVmZmVySWQsIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgbGV0IGJ1ZiA9IHRoaXMuaW5kZXhCdWZmZXJzW2luZGV4QnVmZmVySWRdO1xuICAgICAgICBpZiAoYnVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJ1ZiA9IHRoaXMuaW5kZXhCdWZmZXJzW2luZGV4QnVmZmVySWRdID0ge1xuICAgICAgICAgICAgICAgIGdsQnVmOiBhc3NlcnROb3ROdWxsKGdsLmNyZWF0ZUJ1ZmZlcigpKSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWYubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1Zi5nbEJ1Zik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIH1cbiAgICBhbGxvY1Zhbyh2YW9JZCwgc2hhZGVySWQsIGdlb21JYklkLCBnZW9tVmJJZCwgaW5zdFZiSWQpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBjb25zdCBvbGRWYW8gPSB0aGlzLnZhb3NbdmFvSWRdO1xuICAgICAgICBpZiAob2xkVmFvKSB7XG4gICAgICAgICAgICB0aGlzLk9FU1ZlcnRleEFycmF5T2JqZWN0LmRlbGV0ZVZlcnRleEFycmF5T0VTKG9sZFZhby5nbFZhbyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2xWYW8gPSBhc3NlcnROb3ROdWxsKHRoaXMuT0VTVmVydGV4QXJyYXlPYmplY3QuY3JlYXRlVmVydGV4QXJyYXlPRVMoKSk7XG4gICAgICAgIGNvbnN0IHZhbyA9ICh0aGlzLnZhb3NbdmFvSWRdID0geyBnbFZhbywgZ2VvbUliSWQsIGdlb21WYklkLCBpbnN0VmJJZCB9KTtcbiAgICAgICAgdGhpcy5PRVNWZXJ0ZXhBcnJheU9iamVjdC5iaW5kVmVydGV4QXJyYXlPRVModmFvLmdsVmFvKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYXJyYXlCdWZmZXJzW2dlb21WYklkXS5nbEJ1Zik7XG4gICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyc1tzaGFkZXJJZF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhZGVyLmdlb21BdHRyaWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gc2hhZGVyLmdlb21BdHRyaWJzW2ldO1xuICAgICAgICAgICAgaWYgKGF0dHIubG9jIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyLmxvYywgYXR0ci5zaXplLCBnbC5GTE9BVCwgZmFsc2UsIGF0dHIuc3RyaWRlLCBhdHRyLm9mZnNldCk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyLmxvYyk7XG4gICAgICAgICAgICB0aGlzLkFOR0xFSW5zdGFuY2VkQXJyYXlzLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShhdHRyLmxvYywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYXJyYXlCdWZmZXJzW2luc3RWYklkXS5nbEJ1Zik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhZGVyLmluc3RBdHRyaWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gc2hhZGVyLmluc3RBdHRyaWJzW2ldO1xuICAgICAgICAgICAgaWYgKGF0dHIubG9jIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyLmxvYywgYXR0ci5zaXplLCBnbC5GTE9BVCwgZmFsc2UsIGF0dHIuc3RyaWRlLCBhdHRyLm9mZnNldCk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyLmxvYyk7XG4gICAgICAgICAgICB0aGlzLkFOR0xFSW5zdGFuY2VkQXJyYXlzLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShhdHRyLmxvYywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcnNbZ2VvbUliSWRdLmdsQnVmKTtcbiAgICAgICAgdGhpcy5PRVNWZXJ0ZXhBcnJheU9iamVjdC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XG4gICAgfVxuICAgIGRyYXdDYWxsKHNoYWRlcklkLCB2YW9JZCwgcGFzc1VuaWZvcm1zUHRyLCB2aWV3VW5pZm9ybXNQdHIsIGRyYXdVbmlmb3Jtc1B0ciwgdXNlclVuaWZvcm1zUHRyLCB0ZXh0dXJlc1B0cikge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyc1tzaGFkZXJJZF07XG4gICAgICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuICAgICAgICBjb25zdCB2YW8gPSB0aGlzLnZhb3NbdmFvSWRdO1xuICAgICAgICB0aGlzLk9FU1ZlcnRleEFycmF5T2JqZWN0LmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8uZ2xWYW8pO1xuICAgICAgICBjb25zdCBpbmRleEJ1ZmZlciA9IHRoaXMuaW5kZXhCdWZmZXJzW3Zhby5nZW9tSWJJZF07XG4gICAgICAgIGNvbnN0IGluc3RhbmNlQnVmZmVyID0gdGhpcy5hcnJheUJ1ZmZlcnNbdmFvLmluc3RWYklkXTtcbiAgICAgICAgLy8gc2V0IHVwIHVuaWZvcm1zIFRPRE8gZG8gdGhpcyBhIGJpdCBtb3JlIGluY3JlbWVudGFsIGJhc2VkIG9uIHVuaWZvcm0gbGF5ZXJcbiAgICAgICAgLy8gYWxzbyBwb3NzaWJseSB1c2Ugd2ViR0wyIHVuaWZvcm0gYnVmZmVycy4gRm9yIG5vdyB0aGlzIHdpbGwgc3VmZmljZSBmb3Igd2ViR0wgMSBjb21wYXRcbiAgICAgICAgY29uc3QgcGFzc1VuaWZvcm1zID0gc2hhZGVyLnBhc3NVbmlmb3JtcztcbiAgICAgICAgLy8gaWYgdnJfcHJlc2VudGluZ1xuICAgICAgICBjb25zdCB2aWV3VW5pZm9ybXMgPSBzaGFkZXIudmlld1VuaWZvcm1zO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXdVbmlmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdW5pID0gdmlld1VuaWZvcm1zW2ldO1xuICAgICAgICAgICAgdW5pLmZuKHRoaXMsIHVuaS5sb2MsIHVuaS5vZmZzZXQgKyB2aWV3VW5pZm9ybXNQdHIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyYXdVbmlmb3JtcyA9IHNoYWRlci5kcmF3VW5pZm9ybXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJhd1VuaWZvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1bmkgPSBkcmF3VW5pZm9ybXNbaV07XG4gICAgICAgICAgICB1bmkuZm4odGhpcywgdW5pLmxvYywgdW5pLm9mZnNldCArIGRyYXdVbmlmb3Jtc1B0cik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlclVuaWZvcm1zID0gc2hhZGVyLnVzZXJVbmlmb3JtcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1c2VyVW5pZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaSA9IHVzZXJVbmlmb3Jtc1tpXTtcbiAgICAgICAgICAgIHVuaS5mbih0aGlzLCB1bmkubG9jLCB1bmkub2Zmc2V0ICsgdXNlclVuaWZvcm1zUHRyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0dXJlU2xvdHMgPSBzaGFkZXIudGV4dHVyZVNsb3RzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHR1cmVTbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGV4U2xvdCA9IHRleHR1cmVTbG90c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHRleElkID0gdGhpcy5iYXNldTMyWyh0ZXh0dXJlc1B0ciA+PiAyKSArIGldO1xuICAgICAgICAgICAgY29uc3QgdGV4T2JqID0gdGhpcy50ZXh0dXJlc1t0ZXhJZF07XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaSk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXhPYmopO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHRleFNsb3QubG9jLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRpY2VzID0gaW5kZXhCdWZmZXIubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbnN0YW5jZXMgPSBpbnN0YW5jZUJ1ZmZlci5sZW5ndGggLyBzaGFkZXIuaW5zdGFuY2VTbG90cztcbiAgICAgICAgLy8gaWYgKHRoaXMuaXNNYWluQ2FudmFzICYmIHhySXNQcmVzZW50aW5nKSB7XG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAzOyBpIDwgcGFzc191bmlmb3Jtcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgLy8gICAgIGxldCB1bmkgPSBwYXNzX3VuaWZvcm1zW2ldO1xuICAgICAgICAvLyAgICAgdW5pLmZuKHRoaXMsIHVuaS5sb2MsIHVuaS5vZmZzZXQgKyBwYXNzX3VuaWZvcm1zX3B0cik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gLy8gdGhlIGZpcnN0IDIgbWF0cmljZXMgYXJlIHByb2plY3QgYW5kIHZpZXdcbiAgICAgICAgLy8gbGV0IGxlZnRfdmlld3BvcnQgPSB0aGlzLnhyX2xlZnRfdmlld3BvcnQ7XG4gICAgICAgIC8vIGdsLnZpZXdwb3J0KGxlZnRfdmlld3BvcnQueCwgbGVmdF92aWV3cG9ydC55LCBsZWZ0X3ZpZXdwb3J0LndpZHRoLCBsZWZ0X3ZpZXdwb3J0LmhlaWdodCk7XG4gICAgICAgIC8vIGdsLnVuaWZvcm1NYXRyaXg0ZnYocGFzc191bmlmb3Jtc1swXS5sb2MsIGZhbHNlLCB0aGlzLnhyX2xlZnRfcHJvamVjdGlvbl9tYXRyaXgpO1xuICAgICAgICAvLyBnbC51bmlmb3JtTWF0cml4NGZ2KHBhc3NfdW5pZm9ybXNbMV0ubG9jLCBmYWxzZSwgdGhpcy54cl9sZWZ0X3RyYW5zZm9ybV9tYXRyaXgpO1xuICAgICAgICAvLyBnbC51bmlmb3JtTWF0cml4NGZ2KHBhc3NfdW5pZm9ybXNbMl0ubG9jLCBmYWxzZSwgdGhpcy54cl9sZWZ0X2ludnRyYW5zZm9ybV9tYXRyaXgpO1xuICAgICAgICAvLyB0aGlzLkFOR0xFX2luc3RhbmNlZF9hcnJheXMuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoZ2wuVFJJQU5HTEVTLCBpbmRpY2VzLCBnbC5VTlNJR05FRF9JTlQsIDAsIGluc3RhbmNlcyk7XG4gICAgICAgIC8vIGxldCByaWdodF92aWV3cG9ydCA9IHRoaXMueHJfcmlnaHRfdmlld3BvcnQ7XG4gICAgICAgIC8vIGdsLnZpZXdwb3J0KHJpZ2h0X3ZpZXdwb3J0LngsIHJpZ2h0X3ZpZXdwb3J0LnksIHJpZ2h0X3ZpZXdwb3J0LndpZHRoLCByaWdodF92aWV3cG9ydC5oZWlnaHQpO1xuICAgICAgICAvLyBnbC51bmlmb3JtTWF0cml4NGZ2KHBhc3NfdW5pZm9ybXNbMF0ubG9jLCBmYWxzZSwgdGhpcy54cl9yaWdodF9wcm9qZWN0aW9uX21hdHJpeCk7XG4gICAgICAgIC8vIGdsLnVuaWZvcm1NYXRyaXg0ZnYocGFzc191bmlmb3Jtc1sxXS5sb2MsIGZhbHNlLCB0aGlzLnhyX3JpZ2h0X3RyYW5zZm9ybV9tYXRyaXgpO1xuICAgICAgICAvLyBnbC51bmlmb3JtTWF0cml4NGZ2KHBhc3NfdW5pZm9ybXNbMl0ubG9jLCBmYWxzZSwgdGhpcy54cl9yaWdodF9pbnZ0cmFuc2Zvcm1fbWF0cml4KTtcbiAgICAgICAgLy8gdGhpcy5BTkdMRV9pbnN0YW5jZWRfYXJyYXlzLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKGdsLlRSSUFOR0xFUywgaW5kaWNlcywgZ2wuVU5TSUdORURfSU5ULCAwLCBpbnN0YW5jZXMpO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3NVbmlmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdW5pID0gcGFzc1VuaWZvcm1zW2ldO1xuICAgICAgICAgICAgdW5pLmZuKHRoaXMsIHVuaS5sb2MsIHVuaS5vZmZzZXQgKyBwYXNzVW5pZm9ybXNQdHIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuQU5HTEVJbnN0YW5jZWRBcnJheXMuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoZ2wuVFJJQU5HTEVTLCBpbmRpY2VzLCBnbC5VTlNJR05FRF9JTlQsIDAsIGluc3RhbmNlcyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgdGhpcy5PRVNWZXJ0ZXhBcnJheU9iamVjdC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XG4gICAgfVxuICAgIGFsbG9jVGV4dHVyZSh0ZXh0dXJlSWQsIHdpZHRoLCBoZWlnaHQsIGRhdGFQdHIpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBjb25zdCBnbFRleCA9IHRoaXMudGV4dHVyZXNbdGV4dHVyZUlkXSB8fCBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4KTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLm1lbW9yeS5idWZmZXIsIGRhdGFQdHIsIHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSk7XG4gICAgICAgIHRoaXMudGV4dHVyZXNbdGV4dHVyZUlkXSA9IGdsVGV4O1xuICAgIH1cbiAgICBiZWdpblJlbmRlclRhcmdldHMocGFzc0lkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgdGhpcy50YXJnZXRXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnRhcmdldEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jbGVhckZsYWdzID0gMDtcbiAgICAgICAgLy8gdGhpcy5pc01haW5DYW52YXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZ2xGcmFtZWJ1ZmZlciA9IHRoaXMuZnJhbWVidWZmZXJzW3Bhc3NJZF0gfHxcbiAgICAgICAgICAgICh0aGlzLmZyYW1lYnVmZmVyc1twYXNzSWRdID0gYXNzZXJ0Tm90TnVsbChnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpKSk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2xGcmFtZWJ1ZmZlcik7XG4gICAgfVxuICAgIGFkZENvbG9yVGFyZ2V0KHRleHR1cmVJZCwgaW5pdE9ubHksIHIsIGcsIGIsIGEpIHtcbiAgICAgICAgLy8gaWYgdXNlX2RlZmF1bHRcbiAgICAgICAgdGhpcy5jbGVhclIgPSByO1xuICAgICAgICB0aGlzLmNsZWFyRyA9IGc7XG4gICAgICAgIHRoaXMuY2xlYXJCID0gYjtcbiAgICAgICAgdGhpcy5jbGVhckEgPSBhO1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGNvbnN0IGdsVGV4ID0gdGhpcy50ZXh0dXJlc1t0ZXh0dXJlSWRdIHx8XG4gICAgICAgICAgICAodGhpcy50ZXh0dXJlc1t0ZXh0dXJlSWRdID0gZ2wuY3JlYXRlVGV4dHVyZSgpKTtcbiAgICAgICAgLy8gcmVzaXplIG9yIGNyZWF0ZSB0ZXh0dXJlXG4gICAgICAgIGlmIChnbFRleC5tcFdpZHRoICE9IHRoaXMudGFyZ2V0V2lkdGggfHxcbiAgICAgICAgICAgIGdsVGV4Lm1wSGVpZ2h0ICE9IHRoaXMudGFyZ2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRmxhZ3MgfD0gZ2wuQ09MT1JfQlVGRkVSX0JJVDtcbiAgICAgICAgICAgIGdsVGV4Lm1wV2lkdGggPSB0aGlzLnRhcmdldFdpZHRoO1xuICAgICAgICAgICAgZ2xUZXgubXBIZWlnaHQgPSB0aGlzLnRhcmdldEhlaWdodDtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbFRleC5tcFdpZHRoLCBnbFRleC5tcEhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluaXRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRmxhZ3MgfD0gZ2wuQ09MT1JfQlVGRkVSX0JJVDtcbiAgICAgICAgfVxuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGdsVGV4LCAwKTtcbiAgICB9XG4gICAgc2V0RGVwdGhUYXJnZXQodGV4dHVyZUlkLCBpbml0T25seSwgZGVwdGgpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB0aGlzLmNsZWFyRGVwdGggPSBkZXB0aDtcbiAgICAgICAgY29uc3QgZ2xSZW5kZXJCdWZmZXIgPSB0aGlzLnRleHR1cmVzW3RleHR1cmVJZF0gfHxcbiAgICAgICAgICAgICh0aGlzLnRleHR1cmVzW3RleHR1cmVJZF0gPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKSk7XG4gICAgICAgIGlmIChnbFJlbmRlckJ1ZmZlci5tcFdpZHRoICE9IHRoaXMudGFyZ2V0V2lkdGggfHxcbiAgICAgICAgICAgIGdsUmVuZGVyQnVmZmVyLm1wSGVpZ2h0ICE9IHRoaXMudGFyZ2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBCb3Jyb3dlZCBjb25jZXB0IGZyb20gaHR0cHM6Ly93ZWJnbGZ1bmRhbWVudGFscy5vcmcvd2ViZ2wvbGVzc29ucy93ZWJnbC1yZW5kZXItdG8tdGV4dHVyZS5odG1sXG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZ2xSZW5kZXJCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckZsYWdzIHw9IGdsLkRFUFRIX0JVRkZFUl9CSVQ7XG4gICAgICAgICAgICBnbFJlbmRlckJ1ZmZlci5tcFdpZHRoID0gdGhpcy50YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIGdsUmVuZGVyQnVmZmVyLm1wSGVpZ2h0ID0gdGhpcy50YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMudGFyZ2V0V2lkdGgsIHRoaXMudGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5pdE9ubHkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJGbGFncyB8PSBnbC5ERVBUSF9CVUZGRVJfQklUO1xuICAgICAgICB9XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGdsUmVuZGVyQnVmZmVyKTtcbiAgICB9XG4gICAgZW5kUmVuZGVyVGFyZ2V0cygpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAvLyBwcm9jZXNzIHRoZSBhY3R1YWwgJ2NsZWFyJ1xuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLnRhcmdldFdpZHRoLCB0aGlzLnRhcmdldEhlaWdodCk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gY2xlYXIgY29sb3IsIGFuZCBkZXB0aFxuICAgICAgICAvLyBjbGVhciBpdFxuICAgICAgICBpZiAodGhpcy5jbGVhckZsYWdzKSB7XG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKHRoaXMuY2xlYXJSLCB0aGlzLmNsZWFyRywgdGhpcy5jbGVhckIsIHRoaXMuY2xlYXJBKTtcbiAgICAgICAgICAgIGdsLmNsZWFyRGVwdGgodGhpcy5jbGVhckRlcHRoKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKHRoaXMuY2xlYXJGbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGVmYXVsdERlcHRoQW5kQmxlbmRNb2RlKCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgZ2wuZGVwdGhGdW5jKGdsLkxFUVVBTCk7XG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgfVxuICAgIGJlZ2luTWFpbkNhbnZhcyhyLCBnLCBiLCBhLCBkZXB0aCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIC8vIHRoaXMuaXNNYWluQ2FudmFzID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKHRoaXMueHJJc1ByZXNlbnRpbmcpIHtcbiAgICAgICAgLy8gbGV0IHhyX3dlYmdsbGF5ZXIgPSB0aGlzLnhyX3Nlc3Npb24ucmVuZGVyU3RhdGUuYmFzZUxheWVyO1xuICAgICAgICAvLyB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgeHJfd2ViZ2xsYXllci5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIC8vIGdsLnZpZXdwb3J0KDAsIDAsIHhyX3dlYmdsbGF5ZXIuZnJhbWVidWZmZXJXaWR0aCwgeHJfd2ViZ2xsYXllci5mcmFtZWJ1ZmZlckhlaWdodCk7XG4gICAgICAgIC8vIC8vIHF1ZXN0IDEgaXMgMzY0OFxuICAgICAgICAvLyAvLyBxdWVzdCAyIGlzIDQwOTZcbiAgICAgICAgLy8gbGV0IGxlZnRfdmlldyA9IHRoaXMueHJfcG9zZS52aWV3c1swXTtcbiAgICAgICAgLy8gbGV0IHJpZ2h0X3ZpZXcgPSB0aGlzLnhyX3Bvc2Uudmlld3NbMV07XG4gICAgICAgIC8vIHRoaXMueHJfbGVmdF92aWV3cG9ydCA9IHhyX3dlYmdsbGF5ZXIuZ2V0Vmlld3BvcnQobGVmdF92aWV3KTtcbiAgICAgICAgLy8gdGhpcy54cl9yaWdodF92aWV3cG9ydCA9IHhyX3dlYmdsbGF5ZXIuZ2V0Vmlld3BvcnQocmlnaHRfdmlldyk7XG4gICAgICAgIC8vIHRoaXMueHJfbGVmdF9wcm9qZWN0aW9uX21hdHJpeCA9IGxlZnRfdmlldy5wcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAvLyB0aGlzLnhyX2xlZnRfdHJhbnNmb3JtX21hdHJpeCA9IGxlZnRfdmlldy50cmFuc2Zvcm0uaW52ZXJzZS5tYXRyaXg7XG4gICAgICAgIC8vIHRoaXMueHJfbGVmdF9pbnZ0cmFuc2Zvcm1fbWF0cml4ID0gbGVmdF92aWV3LnRyYW5zZm9ybS5tYXRyaXg7XG4gICAgICAgIC8vIHRoaXMueHJfcmlnaHRfcHJvamVjdGlvbl9tYXRyaXggPSByaWdodF92aWV3LnByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgIC8vIHRoaXMueHJfcmlnaHRfdHJhbnNmb3JtX21hdHJpeCA9IHJpZ2h0X3ZpZXcudHJhbnNmb3JtLmludmVyc2UubWF0cml4O1xuICAgICAgICAvLyB0aGlzLnhyX3JpZ2h0X2NhbWVyYV9wb3MgPSByaWdodF92aWV3LnRyYW5zZm9ybS5pbnZlcnNlLnBvc2l0aW9uO1xuICAgICAgICAvLyB0aGlzLnhyX3JpZ2h0X2ludnRyYW5zZm9ybV9tYXRyaXggPSByaWdodF92aWV3LnRyYW5zZm9ybS5tYXRyaXg7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuc2l6aW5nRGF0YS53aWR0aCAqIHRoaXMuc2l6aW5nRGF0YS5kcGlGYWN0b3IsIHRoaXMuc2l6aW5nRGF0YS5oZWlnaHQgKiB0aGlzLnNpemluZ0RhdGEuZHBpRmFjdG9yKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBnbC5jbGVhckNvbG9yKHIsIGcsIGIsIGEpO1xuICAgICAgICBnbC5jbGVhckRlcHRoKGRlcHRoKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIH1cbn1cbmNvbnN0IHVuaWZvcm1TaXplVGFibGUgPSB7XG4gICAgZmxvYXQ6IDEsXG4gICAgdmVjMjogMixcbiAgICB2ZWMzOiAzLFxuICAgIHZlYzQ6IDQsXG4gICAgbWF0MjogNCxcbiAgICBtYXQzOiA5LFxuICAgIG1hdDQ6IDE2LFxufTtcbmZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzVG9TdHJpbmcoY29kZSkge1xuICAgIGNvbnN0IGxpbmVzID0gY29kZS5zcGxpdChcIlxcblwiKTtcbiAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dCArPSBpICsgMSArIFwiOiBcIiArIGxpbmVzW2ldICsgXCJcXG5cIjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./webgl_renderer.ts\n");

/***/ }),

/***/ "./wrf_buffer.ts":
/*!***********************!*\
  !*** ./wrf_buffer.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WrfBuffer\": () => (/* binding */ WrfBuffer),\n/* harmony export */   \"classesToExtend\": () => (/* binding */ classesToExtend),\n/* harmony export */   \"containsWrfBuffer\": () => (/* binding */ containsWrfBuffer),\n/* harmony export */   \"overwriteTypedArraysWithWrfArrays\": () => (/* binding */ overwriteTypedArraysWithWrfArrays),\n/* harmony export */   \"getCachedWrfBuffer\": () => (/* binding */ getCachedWrfBuffer),\n/* harmony export */   \"isWrfBuffer\": () => (/* binding */ isWrfBuffer),\n/* harmony export */   \"checkValidWrfArray\": () => (/* binding */ checkValidWrfArray),\n/* harmony export */   \"allocatedArcs\": () => (/* binding */ allocatedArcs),\n/* harmony export */   \"allocatedVecs\": () => (/* binding */ allocatedVecs),\n/* harmony export */   \"getWrfBufferWasm\": () => (/* binding */ getWrfBufferWasm),\n/* harmony export */   \"unregisterMutableBuffer\": () => (/* binding */ unregisterMutableBuffer),\n/* harmony export */   \"getWrfBufferCef\": () => (/* binding */ getWrfBufferCef)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n/* harmony import */ var _wrf_test__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrf_test */ \"./wrf_test.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Wrapper around SharedArrayBuffer to encapsulate ownership of particular segments of it\n\n\n\n// TODO(Paras) - Make sure we monkeypatch on web workers as well\nclass WrfBuffer extends SharedArrayBuffer {\n    constructor(buffer, bufferData) {\n        super(0);\n        this.__wrflibWasmBuffer = buffer;\n        this.__wrflibBufferData = bufferData;\n    }\n    // TODO(Paras): Actually enforce this flag and prevent mutation of WrfArrays marked as readonly.\n    // Potentially, we can do this by hashing read only buffer data and periodically checking in debug\n    // builds if they have been modified/raising errors.\n    get readonly() {\n        return this.__wrflibBufferData.readonly;\n    }\n    // The only 2 methods on SharedArrayBuffer class to override:\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#instance_properties\n    get byteLength() {\n        return this.__wrflibWasmBuffer.byteLength;\n    }\n    slice(...args) {\n        return this.__wrflibWasmBuffer.slice(...args);\n    }\n}\n// This class is a drop-in replacement for all typed arrays\n// It uses WrfBuffer as a handle for underlying buffer as the object that keeps underlying data around\n// Requirements:\n//  * The underlying typed array behaves like it was created over the original view\n//  * When the new typed array (potentially with different class name) is created from the buffer of the original one,\n//  they share the same handle\n//\n// The Rust side assumes that underlying data buffer is immutable,\n// however it still could be accidentally modified on JS side leading to weird behavior\n// TODO(Dmitry): Throw an error if there is mutation of the data\nfunction wrfBufferExtends(cls) {\n    return class WrfTypedArray extends cls {\n        constructor(...args) {\n            const buffer = args[0];\n            if (typeof buffer === \"object\" && buffer instanceof WrfBuffer) {\n                // Fill in byteOffset if that's omitted.\n                if (args.length < 2) {\n                    args[1] = buffer.__wrflibBufferData.bufferPtr;\n                }\n                // Fill in length (in elements, not in bytes) if that's omitted.\n                if (args.length < 3) {\n                    args[2] = Math.floor((buffer.__wrflibBufferData.bufferPtr +\n                        buffer.__wrflibBufferData.bufferLen -\n                        args[1]) /\n                        cls.BYTES_PER_ELEMENT);\n                }\n                if (args[1] < buffer.__wrflibBufferData.bufferPtr) {\n                    throw new Error(`Byte_offset ${args[1]} is out of bounds`);\n                }\n                if (args[1] + args[2] * cls.BYTES_PER_ELEMENT >\n                    buffer.__wrflibBufferData.bufferPtr +\n                        buffer.__wrflibBufferData.bufferLen) {\n                    throw new Error(`Byte_offset ${args[1]} + length ${args[2]} is out of bounds`);\n                }\n                // Whenever we create WrfUintArray using WrfBuffer as first argument\n                // pass the underlying full wasm_buffer further\n                args[0] = buffer.__wrflibWasmBuffer;\n                super(...args);\n                this.__wrflibBuffer = buffer;\n            }\n            else {\n                super(...args);\n            }\n        }\n        get buffer() {\n            return this.__wrflibBuffer || super.buffer;\n        }\n        subarray(begin = 0, end = this.length) {\n            if (begin < 0) {\n                begin = this.length + begin;\n            }\n            if (end < 0) {\n                end = this.length + end;\n            }\n            if (end < begin) {\n                end = begin;\n            }\n            return new WrfTypedArray(this.buffer, this.byteOffset + begin * this.BYTES_PER_ELEMENT, end - begin);\n        }\n    };\n}\n// Extending all typed arrays\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#indexed_collections\nconst classesToExtend = {\n    Int8Array: \"WrfInt8Array\",\n    Uint8Array: \"WrfUint8Array\",\n    Uint8ClampedArray: \"WrfUint8ClampedArray\",\n    Int16Array: \"WrfInt16Array\",\n    Uint16Array: \"WrfUint16Array\",\n    Uint16ClampedArray: \"WrfUint16ClampedArray\",\n    Int32Array: \"WrfInt32Array\",\n    Uint32Array: \"WrfUint32Array\",\n    Float32Array: \"WrfFloat32Array\",\n    Float64Array: \"WrfFloat64Array\",\n    BigInt64Array: \"WrfBigInt64Array\",\n    BigUint64Array: \"WrfBigUint64Array\",\n    DataView: \"WrfDataView\",\n};\nfor (const [cls, wrfCls] of Object.entries(classesToExtend)) {\n    // Get a new type name by prefixing old one with \"Wrf\".\n    // e.g. Uint8Array is extended by WrfUint8Array, etc\n    if (cls in self) {\n        // @ts-ignore\n        self[wrfCls] = wrfBufferExtends(self[cls]);\n    }\n}\n// Checks if the given object itself or recursively contains WrfBuffers.\n// Exported for tests.\nfunction containsWrfBuffer(object) {\n    if (typeof object != \"object\" || object === null) {\n        return false;\n    }\n    if (Object.prototype.hasOwnProperty.call(object, \"__wrflibBuffer\")) {\n        return true;\n    }\n    // Only supporting nesting for arrays, plain objects, maps and sets similar to StructuredClone algorithm\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types\n    if (Array.isArray(object) || object instanceof Set || object instanceof Map) {\n        for (const entry of object) {\n            if (containsWrfBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    else if (Object.getPrototypeOf(object) === Object.getPrototypeOf({})) {\n        for (const entry of Object.entries(object)) {\n            if (containsWrfBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction patchPostMessage(cls) {\n    const origPostMessage = cls.postMessage;\n    // Explicitly NOT a fat arrow (=>) since we want to keep the original `this`.\n    cls.postMessage = function (...args) {\n        if (containsWrfBuffer(args[0])) {\n            // TODO(Dmitry): add a better error message showing the exact location of typed arrays\n            throw new Error(\"Sending WrfBuffers to/from workers is not supported - \" +\n                \"use .slice() on typed array instead to make an explicit copy\");\n        }\n        origPostMessage.apply(this, args);\n    };\n}\nfunction overwriteTypedArraysWithWrfArrays() {\n    for (const [cls, wrfCls] of Object.entries(classesToExtend)) {\n        if (cls in self) {\n            // @ts-ignore\n            self[cls] = self[wrfCls];\n        }\n    }\n    patchPostMessage(self);\n    patchPostMessage(self.Worker);\n    patchPostMessage(self.MessagePort);\n}\nconst wrfBufferCache = new WeakMap();\nfunction getCachedWrfBuffer(wrfBuffer, fallbackArray) {\n    var _a;\n    if (!(\n    // Overwrite the cached value if we return a pointer to a buffer of a different type\n    // For example, Rust code may cast a float to an u8 and return the same buffer pointer.\n    (((_a = wrfBufferCache.get(wrfBuffer)) === null || _a === void 0 ? void 0 : _a.BYTES_PER_ELEMENT) ===\n        fallbackArray.BYTES_PER_ELEMENT))) {\n        wrfBufferCache.set(wrfBuffer, fallbackArray);\n    }\n    return wrfBufferCache.get(wrfBuffer);\n}\nfunction isWrfBuffer(potentialWrfBuffer) {\n    return (typeof potentialWrfBuffer === \"object\" &&\n        potentialWrfBuffer instanceof WrfBuffer);\n}\nfunction checkValidWrfArray(wrfArray) {\n    if (!isWrfBuffer(wrfArray.buffer)) {\n        throw new Error(\"wrfArray.buffer is not a WrfBuffer in checkValidWrfArray\");\n    }\n    const buffer = wrfArray.buffer;\n    const bufferCoversWrfBuffer = wrfArray.byteOffset === buffer.__wrflibBufferData.bufferPtr &&\n        wrfArray.byteLength === buffer.__wrflibBufferData.bufferLen;\n    if (!bufferCoversWrfBuffer) {\n        throw new Error(\"Called Rust with a buffer that does not span the entire underlying WrfBuffer\");\n    }\n    const paramType = (0,_common__WEBPACK_IMPORTED_MODULE_0__.getWrfParamType)(wrfArray, buffer.readonly);\n    if (paramType !== buffer.__wrflibBufferData.paramType) {\n        throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${_types__WEBPACK_IMPORTED_MODULE_1__.WrfParamType[buffer.__wrflibBufferData.paramType]} but got ${_types__WEBPACK_IMPORTED_MODULE_1__.WrfParamType[paramType]}`);\n    }\n}\n// Cache WrfBuffers so that we have a stable identity for WrfBuffers pointing to the same\n// Arc. This is useful for any downstream caches in user code.\nconst bufferCache = {};\nconst allocatedArcs = {};\nconst allocatedVecs = {};\nconst bufferRegistry = new FinalizationRegistry(({ arcPtr, destructor, }) => {\n    if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n        if (allocatedArcs[arcPtr] === false) {\n            throw new Error(`Deallocating an already deallocated arcPtr ${arcPtr}`);\n        }\n        else if (allocatedArcs[arcPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated arcPtr ${arcPtr}`);\n        }\n        allocatedArcs[arcPtr] = false;\n    }\n    delete bufferCache[arcPtr];\n    if (destructor)\n        destructor(arcPtr);\n});\nconst mutableWrfBufferRegistry = new FinalizationRegistry(({ bufferData, destructor, }) => {\n    if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n        const { bufferPtr } = bufferData;\n        if (allocatedVecs[bufferPtr] === false) {\n            throw new Error(`Deallocating an already deallocated bufferPtr ${bufferPtr}`);\n        }\n        else if (allocatedVecs[bufferPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated bufferPtr ${bufferPtr}`);\n        }\n        allocatedVecs[bufferPtr] = false;\n    }\n    destructor(bufferData);\n});\n// Return a buffer with a stable identity based on arcPtr.\n// Register callbacks so we de-allocate the buffer when it goes out of scope.\nconst getWrfBufferWasm = (wasmMemory, bufferData, destructor, mutableDestructor) => {\n    var _a;\n    if (bufferData.readonly) {\n        if (!((_a = bufferCache[bufferData.arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n                allocatedArcs[bufferData.arcPtr] = true;\n            }\n            const wrfBuffer = new WrfBuffer(wasmMemory.buffer, bufferData);\n            bufferRegistry.register(wrfBuffer, {\n                arcPtr: bufferData.arcPtr,\n                destructor,\n                /* no unregisterToken here since we never need to unregister */\n            });\n            bufferCache[bufferData.arcPtr] = new WeakRef(wrfBuffer);\n        }\n        else {\n            // If we already hold a reference, decrement the Arc we were just given;\n            // otherwise we leak memory.\n            destructor(bufferData.arcPtr);\n        }\n        return bufferCache[bufferData.arcPtr].deref();\n    }\n    else {\n        if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n            allocatedVecs[bufferData.bufferPtr] = true;\n        }\n        const wrfBuffer = new WrfBuffer(wasmMemory.buffer, bufferData);\n        mutableWrfBufferRegistry.register(wrfBuffer, {\n            bufferData,\n            destructor: mutableDestructor,\n        }, wrfBuffer);\n        return wrfBuffer;\n    }\n};\n// Remove mutable WrfBuffers without running destructors. This is useful\n// when transferring ownership of buffers to Rust without deallocating data.\nconst unregisterMutableBuffer = (wrfBuffer) => {\n    if (wrfBuffer.readonly) {\n        throw new Error(\"`unregisterMutableBuffer` should only be called on mutable WrfBuffers\");\n    }\n    mutableWrfBufferRegistry.unregister(wrfBuffer);\n    if (_wrf_test__WEBPACK_IMPORTED_MODULE_2__.inTest) {\n        allocatedVecs[wrfBuffer.__wrflibBufferData.bufferPtr] = false;\n    }\n};\n// Return a buffer with a stable identity based on arcPtr\nconst getWrfBufferCef = (buffer, arcPtr, paramType) => {\n    var _a;\n    if (arcPtr) {\n        if (!((_a = bufferCache[arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            const wrfBuffer = new WrfBuffer(buffer, {\n                bufferPtr: 0,\n                bufferLen: buffer.byteLength,\n                readonly: true,\n                paramType,\n                // TODO(Paras): These fields below do not apply to CEF\n                arcPtr: -1,\n            });\n            bufferRegistry.register(wrfBuffer, { arcPtr });\n            bufferCache[arcPtr] = new WeakRef(wrfBuffer);\n        }\n        return bufferCache[arcPtr].deref();\n    }\n    else {\n        return new WrfBuffer(buffer, {\n            bufferPtr: 0,\n            bufferLen: buffer.byteLength,\n            bufferCap: buffer.byteLength,\n            paramType,\n            readonly: false,\n        });\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfYnVmZmVyLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93cmYvLi93cmZfYnVmZmVyLnRzP2JiMGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFdyYXBwZXIgYXJvdW5kIFNoYXJlZEFycmF5QnVmZmVyIHRvIGVuY2Fwc3VsYXRlIG93bmVyc2hpcCBvZiBwYXJ0aWN1bGFyIHNlZ21lbnRzIG9mIGl0XG5pbXBvcnQgeyBnZXRXcmZQYXJhbVR5cGUgfSBmcm9tIFwiLi9jb21tb25cIjtcbmltcG9ydCB7IFdyZlBhcmFtVHlwZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBpblRlc3QgfSBmcm9tIFwiLi93cmZfdGVzdFwiO1xuLy8gVE9ETyhQYXJhcykgLSBNYWtlIHN1cmUgd2UgbW9ua2V5cGF0Y2ggb24gd2ViIHdvcmtlcnMgYXMgd2VsbFxuZXhwb3J0IGNsYXNzIFdyZkJ1ZmZlciBleHRlbmRzIFNoYXJlZEFycmF5QnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGJ1ZmZlckRhdGEpIHtcbiAgICAgICAgc3VwZXIoMCk7XG4gICAgICAgIHRoaXMuX193cmZsaWJXYXNtQnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLl9fd3JmbGliQnVmZmVyRGF0YSA9IGJ1ZmZlckRhdGE7XG4gICAgfVxuICAgIC8vIFRPRE8oUGFyYXMpOiBBY3R1YWxseSBlbmZvcmNlIHRoaXMgZmxhZyBhbmQgcHJldmVudCBtdXRhdGlvbiBvZiBXcmZBcnJheXMgbWFya2VkIGFzIHJlYWRvbmx5LlxuICAgIC8vIFBvdGVudGlhbGx5LCB3ZSBjYW4gZG8gdGhpcyBieSBoYXNoaW5nIHJlYWQgb25seSBidWZmZXIgZGF0YSBhbmQgcGVyaW9kaWNhbGx5IGNoZWNraW5nIGluIGRlYnVnXG4gICAgLy8gYnVpbGRzIGlmIHRoZXkgaGF2ZSBiZWVuIG1vZGlmaWVkL3JhaXNpbmcgZXJyb3JzLlxuICAgIGdldCByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJCdWZmZXJEYXRhLnJlYWRvbmx5O1xuICAgIH1cbiAgICAvLyBUaGUgb25seSAyIG1ldGhvZHMgb24gU2hhcmVkQXJyYXlCdWZmZXIgY2xhc3MgdG8gb3ZlcnJpZGU6XG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1NoYXJlZEFycmF5QnVmZmVyI2luc3RhbmNlX3Byb3BlcnRpZXNcbiAgICBnZXQgYnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJXYXNtQnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHNsaWNlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJXYXNtQnVmZmVyLnNsaWNlKC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8vIFRoaXMgY2xhc3MgaXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciBhbGwgdHlwZWQgYXJyYXlzXG4vLyBJdCB1c2VzIFdyZkJ1ZmZlciBhcyBhIGhhbmRsZSBmb3IgdW5kZXJseWluZyBidWZmZXIgYXMgdGhlIG9iamVjdCB0aGF0IGtlZXBzIHVuZGVybHlpbmcgZGF0YSBhcm91bmRcbi8vIFJlcXVpcmVtZW50czpcbi8vICAqIFRoZSB1bmRlcmx5aW5nIHR5cGVkIGFycmF5IGJlaGF2ZXMgbGlrZSBpdCB3YXMgY3JlYXRlZCBvdmVyIHRoZSBvcmlnaW5hbCB2aWV3XG4vLyAgKiBXaGVuIHRoZSBuZXcgdHlwZWQgYXJyYXkgKHBvdGVudGlhbGx5IHdpdGggZGlmZmVyZW50IGNsYXNzIG5hbWUpIGlzIGNyZWF0ZWQgZnJvbSB0aGUgYnVmZmVyIG9mIHRoZSBvcmlnaW5hbCBvbmUsXG4vLyAgdGhleSBzaGFyZSB0aGUgc2FtZSBoYW5kbGVcbi8vXG4vLyBUaGUgUnVzdCBzaWRlIGFzc3VtZXMgdGhhdCB1bmRlcmx5aW5nIGRhdGEgYnVmZmVyIGlzIGltbXV0YWJsZSxcbi8vIGhvd2V2ZXIgaXQgc3RpbGwgY291bGQgYmUgYWNjaWRlbnRhbGx5IG1vZGlmaWVkIG9uIEpTIHNpZGUgbGVhZGluZyB0byB3ZWlyZCBiZWhhdmlvclxuLy8gVE9ETyhEbWl0cnkpOiBUaHJvdyBhbiBlcnJvciBpZiB0aGVyZSBpcyBtdXRhdGlvbiBvZiB0aGUgZGF0YVxuZnVuY3Rpb24gd3JmQnVmZmVyRXh0ZW5kcyhjbHMpIHtcbiAgICByZXR1cm4gY2xhc3MgV3JmVHlwZWRBcnJheSBleHRlbmRzIGNscyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gXCJvYmplY3RcIiAmJiBidWZmZXIgaW5zdGFuY2VvZiBXcmZCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIGluIGJ5dGVPZmZzZXQgaWYgdGhhdCdzIG9taXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICBhcmdzWzFdID0gYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5idWZmZXJQdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbGwgaW4gbGVuZ3RoIChpbiBlbGVtZW50cywgbm90IGluIGJ5dGVzKSBpZiB0aGF0J3Mgb21pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMl0gPSBNYXRoLmZsb29yKChidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlclB0ciArXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlckxlbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzFdKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJnc1sxXSA8IGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQnl0ZV9vZmZzZXQgJHthcmdzWzFdfSBpcyBvdXQgb2YgYm91bmRzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzFdICsgYXJnc1syXSAqIGNscy5CWVRFU19QRVJfRUxFTUVOVCA+XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQnl0ZV9vZmZzZXQgJHthcmdzWzFdfSArIGxlbmd0aCAke2FyZ3NbMl19IGlzIG91dCBvZiBib3VuZHNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbmV2ZXIgd2UgY3JlYXRlIFdyZlVpbnRBcnJheSB1c2luZyBXcmZCdWZmZXIgYXMgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAvLyBwYXNzIHRoZSB1bmRlcmx5aW5nIGZ1bGwgd2FzbV9idWZmZXIgZnVydGhlclxuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBidWZmZXIuX193cmZsaWJXYXNtQnVmZmVyO1xuICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX193cmZsaWJCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgYnVmZmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX193cmZsaWJCdWZmZXIgfHwgc3VwZXIuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHN1YmFycmF5KGJlZ2luID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDApIHtcbiAgICAgICAgICAgICAgICBiZWdpbiA9IHRoaXMubGVuZ3RoICsgYmVnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoICsgZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA8IGJlZ2luKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gYmVnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyZlR5cGVkQXJyYXkodGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIGJlZ2luICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVCwgZW5kIC0gYmVnaW4pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIEV4dGVuZGluZyBhbGwgdHlwZWQgYXJyYXlzXG4vLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMjaW5kZXhlZF9jb2xsZWN0aW9uc1xuZXhwb3J0IGNvbnN0IGNsYXNzZXNUb0V4dGVuZCA9IHtcbiAgICBJbnQ4QXJyYXk6IFwiV3JmSW50OEFycmF5XCIsXG4gICAgVWludDhBcnJheTogXCJXcmZVaW50OEFycmF5XCIsXG4gICAgVWludDhDbGFtcGVkQXJyYXk6IFwiV3JmVWludDhDbGFtcGVkQXJyYXlcIixcbiAgICBJbnQxNkFycmF5OiBcIldyZkludDE2QXJyYXlcIixcbiAgICBVaW50MTZBcnJheTogXCJXcmZVaW50MTZBcnJheVwiLFxuICAgIFVpbnQxNkNsYW1wZWRBcnJheTogXCJXcmZVaW50MTZDbGFtcGVkQXJyYXlcIixcbiAgICBJbnQzMkFycmF5OiBcIldyZkludDMyQXJyYXlcIixcbiAgICBVaW50MzJBcnJheTogXCJXcmZVaW50MzJBcnJheVwiLFxuICAgIEZsb2F0MzJBcnJheTogXCJXcmZGbG9hdDMyQXJyYXlcIixcbiAgICBGbG9hdDY0QXJyYXk6IFwiV3JmRmxvYXQ2NEFycmF5XCIsXG4gICAgQmlnSW50NjRBcnJheTogXCJXcmZCaWdJbnQ2NEFycmF5XCIsXG4gICAgQmlnVWludDY0QXJyYXk6IFwiV3JmQmlnVWludDY0QXJyYXlcIixcbiAgICBEYXRhVmlldzogXCJXcmZEYXRhVmlld1wiLFxufTtcbmZvciAoY29uc3QgW2Nscywgd3JmQ2xzXSBvZiBPYmplY3QuZW50cmllcyhjbGFzc2VzVG9FeHRlbmQpKSB7XG4gICAgLy8gR2V0IGEgbmV3IHR5cGUgbmFtZSBieSBwcmVmaXhpbmcgb2xkIG9uZSB3aXRoIFwiV3JmXCIuXG4gICAgLy8gZS5nLiBVaW50OEFycmF5IGlzIGV4dGVuZGVkIGJ5IFdyZlVpbnQ4QXJyYXksIGV0Y1xuICAgIGlmIChjbHMgaW4gc2VsZikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHNlbGZbd3JmQ2xzXSA9IHdyZkJ1ZmZlckV4dGVuZHMoc2VsZltjbHNdKTtcbiAgICB9XG59XG4vLyBDaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBpdHNlbGYgb3IgcmVjdXJzaXZlbHkgY29udGFpbnMgV3JmQnVmZmVycy5cbi8vIEV4cG9ydGVkIGZvciB0ZXN0cy5cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1dyZkJ1ZmZlcihvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPSBcIm9iamVjdFwiIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBcIl9fd3JmbGliQnVmZmVyXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBPbmx5IHN1cHBvcnRpbmcgbmVzdGluZyBmb3IgYXJyYXlzLCBwbGFpbiBvYmplY3RzLCBtYXBzIGFuZCBzZXRzIHNpbWlsYXIgdG8gU3RydWN0dXJlZENsb25lIGFsZ29yaXRobVxuICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1dvcmtlcnNfQVBJL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtI3N1cHBvcnRlZF90eXBlc1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgfHwgb2JqZWN0IGluc3RhbmNlb2YgU2V0IHx8IG9iamVjdCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zV3JmQnVmZmVyKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0KSkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zV3JmQnVmZmVyKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhdGNoUG9zdE1lc3NhZ2UoY2xzKSB7XG4gICAgY29uc3Qgb3JpZ1Bvc3RNZXNzYWdlID0gY2xzLnBvc3RNZXNzYWdlO1xuICAgIC8vIEV4cGxpY2l0bHkgTk9UIGEgZmF0IGFycm93ICg9Pikgc2luY2Ugd2Ugd2FudCB0byBrZWVwIHRoZSBvcmlnaW5hbCBgdGhpc2AuXG4gICAgY2xzLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zV3JmQnVmZmVyKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAvLyBUT0RPKERtaXRyeSk6IGFkZCBhIGJldHRlciBlcnJvciBtZXNzYWdlIHNob3dpbmcgdGhlIGV4YWN0IGxvY2F0aW9uIG9mIHR5cGVkIGFycmF5c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZGluZyBXcmZCdWZmZXJzIHRvL2Zyb20gd29ya2VycyBpcyBub3Qgc3VwcG9ydGVkIC0gXCIgK1xuICAgICAgICAgICAgICAgIFwidXNlIC5zbGljZSgpIG9uIHR5cGVkIGFycmF5IGluc3RlYWQgdG8gbWFrZSBhbiBleHBsaWNpdCBjb3B5XCIpO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdQb3N0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJ3cml0ZVR5cGVkQXJyYXlzV2l0aFdyZkFycmF5cygpIHtcbiAgICBmb3IgKGNvbnN0IFtjbHMsIHdyZkNsc10gb2YgT2JqZWN0LmVudHJpZXMoY2xhc3Nlc1RvRXh0ZW5kKSkge1xuICAgICAgICBpZiAoY2xzIGluIHNlbGYpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHNlbGZbY2xzXSA9IHNlbGZbd3JmQ2xzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRjaFBvc3RNZXNzYWdlKHNlbGYpO1xuICAgIHBhdGNoUG9zdE1lc3NhZ2Uoc2VsZi5Xb3JrZXIpO1xuICAgIHBhdGNoUG9zdE1lc3NhZ2Uoc2VsZi5NZXNzYWdlUG9ydCk7XG59XG5jb25zdCB3cmZCdWZmZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVkV3JmQnVmZmVyKHdyZkJ1ZmZlciwgZmFsbGJhY2tBcnJheSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIShcbiAgICAvLyBPdmVyd3JpdGUgdGhlIGNhY2hlZCB2YWx1ZSBpZiB3ZSByZXR1cm4gYSBwb2ludGVyIHRvIGEgYnVmZmVyIG9mIGEgZGlmZmVyZW50IHR5cGVcbiAgICAvLyBGb3IgZXhhbXBsZSwgUnVzdCBjb2RlIG1heSBjYXN0IGEgZmxvYXQgdG8gYW4gdTggYW5kIHJldHVybiB0aGUgc2FtZSBidWZmZXIgcG9pbnRlci5cbiAgICAoKChfYSA9IHdyZkJ1ZmZlckNhY2hlLmdldCh3cmZCdWZmZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuQllURVNfUEVSX0VMRU1FTlQpID09PVxuICAgICAgICBmYWxsYmFja0FycmF5LkJZVEVTX1BFUl9FTEVNRU5UKSkpIHtcbiAgICAgICAgd3JmQnVmZmVyQ2FjaGUuc2V0KHdyZkJ1ZmZlciwgZmFsbGJhY2tBcnJheSk7XG4gICAgfVxuICAgIHJldHVybiB3cmZCdWZmZXJDYWNoZS5nZXQod3JmQnVmZmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1dyZkJ1ZmZlcihwb3RlbnRpYWxXcmZCdWZmZXIpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwb3RlbnRpYWxXcmZCdWZmZXIgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcG90ZW50aWFsV3JmQnVmZmVyIGluc3RhbmNlb2YgV3JmQnVmZmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZhbGlkV3JmQXJyYXkod3JmQXJyYXkpIHtcbiAgICBpZiAoIWlzV3JmQnVmZmVyKHdyZkFycmF5LmJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3JmQXJyYXkuYnVmZmVyIGlzIG5vdCBhIFdyZkJ1ZmZlciBpbiBjaGVja1ZhbGlkV3JmQXJyYXlcIik7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IHdyZkFycmF5LmJ1ZmZlcjtcbiAgICBjb25zdCBidWZmZXJDb3ZlcnNXcmZCdWZmZXIgPSB3cmZBcnJheS5ieXRlT2Zmc2V0ID09PSBidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlclB0ciAmJlxuICAgICAgICB3cmZBcnJheS5ieXRlTGVuZ3RoID09PSBidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLmJ1ZmZlckxlbjtcbiAgICBpZiAoIWJ1ZmZlckNvdmVyc1dyZkJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgUnVzdCB3aXRoIGEgYnVmZmVyIHRoYXQgZG9lcyBub3Qgc3BhbiB0aGUgZW50aXJlIHVuZGVybHlpbmcgV3JmQnVmZmVyXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbVR5cGUgPSBnZXRXcmZQYXJhbVR5cGUod3JmQXJyYXksIGJ1ZmZlci5yZWFkb25seSk7XG4gICAgaWYgKHBhcmFtVHlwZSAhPT0gYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5wYXJhbVR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY2FsbCBSdXN0IHdpdGggYSBidWZmZXIgd2hpY2ggaGFzIGJlZW4gY2FzdCB0byBhIGRpZmZlcmVudCB0eXBlLiBFeHBlY3RlZCAke1dyZlBhcmFtVHlwZVtidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLnBhcmFtVHlwZV19IGJ1dCBnb3QgJHtXcmZQYXJhbVR5cGVbcGFyYW1UeXBlXX1gKTtcbiAgICB9XG59XG4vLyBDYWNoZSBXcmZCdWZmZXJzIHNvIHRoYXQgd2UgaGF2ZSBhIHN0YWJsZSBpZGVudGl0eSBmb3IgV3JmQnVmZmVycyBwb2ludGluZyB0byB0aGUgc2FtZVxuLy8gQXJjLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYW55IGRvd25zdHJlYW0gY2FjaGVzIGluIHVzZXIgY29kZS5cbmNvbnN0IGJ1ZmZlckNhY2hlID0ge307XG5leHBvcnQgY29uc3QgYWxsb2NhdGVkQXJjcyA9IHt9O1xuZXhwb3J0IGNvbnN0IGFsbG9jYXRlZFZlY3MgPSB7fTtcbmNvbnN0IGJ1ZmZlclJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCh7IGFyY1B0ciwgZGVzdHJ1Y3RvciwgfSkgPT4ge1xuICAgIGlmIChpblRlc3QpIHtcbiAgICAgICAgaWYgKGFsbG9jYXRlZEFyY3NbYXJjUHRyXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVhbGxvY2F0aW5nIGFuIGFscmVhZHkgZGVhbGxvY2F0ZWQgYXJjUHRyICR7YXJjUHRyfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG9jYXRlZEFyY3NbYXJjUHRyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlYWxsb2NhdGluZyBhbiB1bmFsbG9jYXRlZCBhcmNQdHIgJHthcmNQdHJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsb2NhdGVkQXJjc1thcmNQdHJdID0gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSBidWZmZXJDYWNoZVthcmNQdHJdO1xuICAgIGlmIChkZXN0cnVjdG9yKVxuICAgICAgICBkZXN0cnVjdG9yKGFyY1B0cik7XG59KTtcbmNvbnN0IG11dGFibGVXcmZCdWZmZXJSZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoeyBidWZmZXJEYXRhLCBkZXN0cnVjdG9yLCB9KSA9PiB7XG4gICAgaWYgKGluVGVzdCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlclB0ciB9ID0gYnVmZmVyRGF0YTtcbiAgICAgICAgaWYgKGFsbG9jYXRlZFZlY3NbYnVmZmVyUHRyXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVhbGxvY2F0aW5nIGFuIGFscmVhZHkgZGVhbGxvY2F0ZWQgYnVmZmVyUHRyICR7YnVmZmVyUHRyfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG9jYXRlZFZlY3NbYnVmZmVyUHRyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlYWxsb2NhdGluZyBhbiB1bmFsbG9jYXRlZCBidWZmZXJQdHIgJHtidWZmZXJQdHJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsb2NhdGVkVmVjc1tidWZmZXJQdHJdID0gZmFsc2U7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoYnVmZmVyRGF0YSk7XG59KTtcbi8vIFJldHVybiBhIGJ1ZmZlciB3aXRoIGEgc3RhYmxlIGlkZW50aXR5IGJhc2VkIG9uIGFyY1B0ci5cbi8vIFJlZ2lzdGVyIGNhbGxiYWNrcyBzbyB3ZSBkZS1hbGxvY2F0ZSB0aGUgYnVmZmVyIHdoZW4gaXQgZ29lcyBvdXQgb2Ygc2NvcGUuXG5leHBvcnQgY29uc3QgZ2V0V3JmQnVmZmVyV2FzbSA9ICh3YXNtTWVtb3J5LCBidWZmZXJEYXRhLCBkZXN0cnVjdG9yLCBtdXRhYmxlRGVzdHJ1Y3RvcikgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYnVmZmVyRGF0YS5yZWFkb25seSkge1xuICAgICAgICBpZiAoISgoX2EgPSBidWZmZXJDYWNoZVtidWZmZXJEYXRhLmFyY1B0cl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXJlZigpKSkge1xuICAgICAgICAgICAgaWYgKGluVGVzdCkge1xuICAgICAgICAgICAgICAgIGFsbG9jYXRlZEFyY3NbYnVmZmVyRGF0YS5hcmNQdHJdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdyZkJ1ZmZlciA9IG5ldyBXcmZCdWZmZXIod2FzbU1lbW9yeS5idWZmZXIsIGJ1ZmZlckRhdGEpO1xuICAgICAgICAgICAgYnVmZmVyUmVnaXN0cnkucmVnaXN0ZXIod3JmQnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgYXJjUHRyOiBidWZmZXJEYXRhLmFyY1B0cixcbiAgICAgICAgICAgICAgICBkZXN0cnVjdG9yLFxuICAgICAgICAgICAgICAgIC8qIG5vIHVucmVnaXN0ZXJUb2tlbiBoZXJlIHNpbmNlIHdlIG5ldmVyIG5lZWQgdG8gdW5yZWdpc3RlciAqL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBidWZmZXJDYWNoZVtidWZmZXJEYXRhLmFyY1B0cl0gPSBuZXcgV2Vha1JlZih3cmZCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBob2xkIGEgcmVmZXJlbmNlLCBkZWNyZW1lbnQgdGhlIEFyYyB3ZSB3ZXJlIGp1c3QgZ2l2ZW47XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbGVhayBtZW1vcnkuXG4gICAgICAgICAgICBkZXN0cnVjdG9yKGJ1ZmZlckRhdGEuYXJjUHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyQ2FjaGVbYnVmZmVyRGF0YS5hcmNQdHJdLmRlcmVmKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5UZXN0KSB7XG4gICAgICAgICAgICBhbGxvY2F0ZWRWZWNzW2J1ZmZlckRhdGEuYnVmZmVyUHRyXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gbmV3IFdyZkJ1ZmZlcih3YXNtTWVtb3J5LmJ1ZmZlciwgYnVmZmVyRGF0YSk7XG4gICAgICAgIG11dGFibGVXcmZCdWZmZXJSZWdpc3RyeS5yZWdpc3Rlcih3cmZCdWZmZXIsIHtcbiAgICAgICAgICAgIGJ1ZmZlckRhdGEsXG4gICAgICAgICAgICBkZXN0cnVjdG9yOiBtdXRhYmxlRGVzdHJ1Y3RvcixcbiAgICAgICAgfSwgd3JmQnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHdyZkJ1ZmZlcjtcbiAgICB9XG59O1xuLy8gUmVtb3ZlIG11dGFibGUgV3JmQnVmZmVycyB3aXRob3V0IHJ1bm5pbmcgZGVzdHJ1Y3RvcnMuIFRoaXMgaXMgdXNlZnVsXG4vLyB3aGVuIHRyYW5zZmVycmluZyBvd25lcnNoaXAgb2YgYnVmZmVycyB0byBSdXN0IHdpdGhvdXQgZGVhbGxvY2F0aW5nIGRhdGEuXG5leHBvcnQgY29uc3QgdW5yZWdpc3Rlck11dGFibGVCdWZmZXIgPSAod3JmQnVmZmVyKSA9PiB7XG4gICAgaWYgKHdyZkJ1ZmZlci5yZWFkb25seSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdW5yZWdpc3Rlck11dGFibGVCdWZmZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBtdXRhYmxlIFdyZkJ1ZmZlcnNcIik7XG4gICAgfVxuICAgIG11dGFibGVXcmZCdWZmZXJSZWdpc3RyeS51bnJlZ2lzdGVyKHdyZkJ1ZmZlcik7XG4gICAgaWYgKGluVGVzdCkge1xuICAgICAgICBhbGxvY2F0ZWRWZWNzW3dyZkJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYnVmZmVyUHRyXSA9IGZhbHNlO1xuICAgIH1cbn07XG4vLyBSZXR1cm4gYSBidWZmZXIgd2l0aCBhIHN0YWJsZSBpZGVudGl0eSBiYXNlZCBvbiBhcmNQdHJcbmV4cG9ydCBjb25zdCBnZXRXcmZCdWZmZXJDZWYgPSAoYnVmZmVyLCBhcmNQdHIsIHBhcmFtVHlwZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYXJjUHRyKSB7XG4gICAgICAgIGlmICghKChfYSA9IGJ1ZmZlckNhY2hlW2FyY1B0cl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXJlZigpKSkge1xuICAgICAgICAgICAgY29uc3Qgd3JmQnVmZmVyID0gbmV3IFdyZkJ1ZmZlcihidWZmZXIsIHtcbiAgICAgICAgICAgICAgICBidWZmZXJQdHI6IDAsXG4gICAgICAgICAgICAgICAgYnVmZmVyTGVuOiBidWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJhbVR5cGUsXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhQYXJhcyk6IFRoZXNlIGZpZWxkcyBiZWxvdyBkbyBub3QgYXBwbHkgdG8gQ0VGXG4gICAgICAgICAgICAgICAgYXJjUHRyOiAtMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnVmZmVyUmVnaXN0cnkucmVnaXN0ZXIod3JmQnVmZmVyLCB7IGFyY1B0ciB9KTtcbiAgICAgICAgICAgIGJ1ZmZlckNhY2hlW2FyY1B0cl0gPSBuZXcgV2Vha1JlZih3cmZCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXJDYWNoZVthcmNQdHJdLmRlcmVmKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFdyZkJ1ZmZlcihidWZmZXIsIHtcbiAgICAgICAgICAgIGJ1ZmZlclB0cjogMCxcbiAgICAgICAgICAgIGJ1ZmZlckxlbjogYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBidWZmZXJDYXA6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgcGFyYW1UeXBlLFxuICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./wrf_buffer.ts\n");

/***/ }),

/***/ "./wrf_cef_runtime.ts":
/*!****************************!*\
  !*** ./wrf_cef_runtime.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"callRust\": () => (/* binding */ callRust),\n/* harmony export */   \"registerCallJsCallbacks\": () => (/* binding */ registerCallJsCallbacks),\n/* harmony export */   \"unregisterCallJsCallbacks\": () => (/* binding */ unregisterCallJsCallbacks),\n/* harmony export */   \"callRustInSameThreadSync\": () => (/* binding */ callRustInSameThreadSync),\n/* harmony export */   \"wrfNewWorkerPort\": () => (/* binding */ wrfNewWorkerPort),\n/* harmony export */   \"serializeWrfArrayForPostMessage\": () => (/* binding */ serializeWrfArrayForPostMessage),\n/* harmony export */   \"deserializeWrfArrayFromPostMessage\": () => (/* binding */ deserializeWrfArrayFromPostMessage),\n/* harmony export */   \"initialize\": () => (/* binding */ initialize),\n/* harmony export */   \"createBuffer\": () => (/* binding */ createBuffer),\n/* harmony export */   \"createReadOnlyBuffer\": () => (/* binding */ createReadOnlyBuffer)\n/* harmony export */ });\n/* harmony import */ var _cursor_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cursor_map */ \"./cursor_map.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n/* harmony import */ var _make_textarea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./make_textarea */ \"./make_textarea.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n/* harmony import */ var _zerde__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zerde */ \"./zerde.ts\");\n/* harmony import */ var _zerde_keyboard_handlers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zerde_keyboard_handlers */ \"./zerde_keyboard_handlers.ts\");\n/* harmony import */ var _rpc_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rpc_types */ \"./rpc_types.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\nlet newCallbackId = 0;\n// keeping track of pending callbacks from rust side\nconst pendingCallbacks = {};\nconst callRust = (name, params = []) => {\n    const cefParams = params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else {\n            if ((0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_4__.isWrfBuffer)(param.buffer)) {\n                (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_4__.checkValidWrfArray)(param);\n                const wrfBuffer = param.buffer;\n                return [\n                    wrfBuffer.__wrflibWasmBuffer,\n                    (0,_common__WEBPACK_IMPORTED_MODULE_1__.getWrfParamType)(param, wrfBuffer.readonly),\n                ];\n            }\n            const paramType = (0,_common__WEBPACK_IMPORTED_MODULE_1__.getWrfParamType)(param, false);\n            const [cefBuffer] = window.cefCreateArrayBuffer(param.length, paramType);\n            (0,_common__WEBPACK_IMPORTED_MODULE_1__.copyArrayToRustBuffer)(param, cefBuffer, 0);\n            return [cefBuffer, paramType];\n        }\n    });\n    const callbackId = newCallbackId++;\n    const promise = new Promise((resolve, _reject) => {\n        pendingCallbacks[callbackId] = (data) => {\n            // TODO(Dmitry): implement retrun_error on rust side and use reject(...) to communicate the error\n            resolve(data);\n        };\n    });\n    window.cefCallRust(name, cefParams, callbackId);\n    return promise;\n};\nfunction _wrflibReturnParams(params) {\n    const callbackId = JSON.parse(params[0]);\n    pendingCallbacks[callbackId](params.slice(1));\n    delete pendingCallbacks[callbackId];\n}\n// Initial set of framework-specific functions\nconst fromCefJsFunctions = {\n    _wrflibReturnParams,\n};\n/// Users must call this function to register functions as runnable from\n/// Rust via `[Cx::call_js]`.\nconst registerCallJsCallbacks = (fns) => {\n    // Check that all new functions are unique\n    for (const key of Object.keys(fns)) {\n        if (key in fromCefJsFunctions) {\n            throw new Error(`Error: overwriting existing function \"${key}\"`);\n        }\n    }\n    Object.assign(fromCefJsFunctions, fns);\n    window.cefReadyForMessages();\n};\n/// Users must call this function to unregister functions as runnable from\n/// Rust via `[Cx::call_js]`.\nconst unregisterCallJsCallbacks = (fnNames) => {\n    fnNames.forEach((name) => {\n        // Check that functions are registered\n        if (!(name in fromCefJsFunctions)) {\n            throw new Error(`Error: unregistering non-existent function \"${name}\"`);\n        }\n        delete fromCefJsFunctions[name];\n    });\n};\nconst transformReturnParams = (returnParams) => returnParams.map((param) => {\n    if (typeof param === \"string\") {\n        return param;\n    }\n    else {\n        const [buffer, arcPtr, paramType] = param;\n        const wrfBuffer = (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_4__.getWrfBufferCef)(buffer, arcPtr, paramType);\n        if (paramType === _types__WEBPACK_IMPORTED_MODULE_3__.WrfParamType.String) {\n            throw new Error(\"WrfParam buffer type called with string paramType\");\n        }\n        // These are actually WrfArray types, since we overwrite TypedArrays in overwriteTypedArraysWithWrfArrays()\n        const ParamTypeToArrayConstructor = {\n            [_types__WEBPACK_IMPORTED_MODULE_3__.WrfParamType.U8Buffer]: Uint8Array,\n            [_types__WEBPACK_IMPORTED_MODULE_3__.WrfParamType.ReadOnlyU8Buffer]: Uint8Array,\n            [_types__WEBPACK_IMPORTED_MODULE_3__.WrfParamType.F32Buffer]: Float32Array,\n            [_types__WEBPACK_IMPORTED_MODULE_3__.WrfParamType.ReadOnlyF32Buffer]: Float32Array,\n        };\n        // Creating array with stable identity as that's what underlying underlying API expects\n        return (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_4__.getCachedWrfBuffer)(wrfBuffer, new ParamTypeToArrayConstructor[paramType](wrfBuffer));\n    }\n});\n// TODO(JP): Some of this code is duplicated with callRust/call_js; see if we can reuse some.\nconst callRustInSameThreadSync = (name, params = []) => {\n    const cefParams = params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else {\n            const paramType = (0,_common__WEBPACK_IMPORTED_MODULE_1__.getWrfParamType)(param, false);\n            const [cefBuffer] = window.cefCreateArrayBuffer(param.length, paramType);\n            // TODO(Dmitry): implement optimization to avoid copying when possible\n            (0,_common__WEBPACK_IMPORTED_MODULE_1__.copyArrayToRustBuffer)(param, cefBuffer, 0);\n            return [cefBuffer, paramType];\n        }\n    });\n    const returnParams = window.cefCallRustInSameThreadSync(name, cefParams);\n    return transformReturnParams(returnParams);\n};\nconst wrfNewWorkerPort = () => {\n    throw new Error(\"`wrfNewWorkerPort` is currently not supported on CEF\");\n};\nconst serializeWrfArrayForPostMessage = (_postMessageData) => {\n    throw new Error(\"`serializeWrfArrayForPostMessage` is currently not supported on CEF\");\n};\nconst deserializeWrfArrayFromPostMessage = (_postMessageData) => {\n    throw new Error(\"`deserializeWrfArrayFromPostMessage` is currently not supported on CEF\");\n};\nconst initialize = (_initParams) => new Promise((resolve) => {\n    (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_4__.overwriteTypedArraysWithWrfArrays)();\n    window.fromCefSetMouseCursor = (cursorId) => {\n        if (document.body) {\n            document.body.style.cursor = _cursor_map__WEBPACK_IMPORTED_MODULE_0__.cursorMap[cursorId] || \"default\";\n        }\n    };\n    window.fromCefCallJsFunction = (name, params) => {\n        fromCefJsFunctions[name](transformReturnParams(params));\n    };\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        const { showTextIME, textareaHasFocus } = (0,_make_textarea__WEBPACK_IMPORTED_MODULE_2__.makeTextarea)((taEvent) => {\n            const slots = 20;\n            const [buffer] = window.cefCreateArrayBuffer(slots * 4, _types__WEBPACK_IMPORTED_MODULE_3__.WrfParamType.U8Buffer);\n            const zerdeBuilder = new _zerde__WEBPACK_IMPORTED_MODULE_5__.ZerdeBuilder({\n                buffer,\n                byteOffset: 0,\n                slots,\n                growCallback: () => {\n                    throw new Error(\"Growing of this buffer is not supported\");\n                },\n            });\n            if (taEvent.type === _rpc_types__WEBPACK_IMPORTED_MODULE_7__.WorkerEvent.KeyDown) {\n                _zerde_keyboard_handlers__WEBPACK_IMPORTED_MODULE_6__.zerdeKeyboardHandlers.keyDown(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === _rpc_types__WEBPACK_IMPORTED_MODULE_7__.WorkerEvent.KeyUp) {\n                _zerde_keyboard_handlers__WEBPACK_IMPORTED_MODULE_6__.zerdeKeyboardHandlers.keyUp(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === _rpc_types__WEBPACK_IMPORTED_MODULE_7__.WorkerEvent.TextInput) {\n                _zerde_keyboard_handlers__WEBPACK_IMPORTED_MODULE_6__.zerdeKeyboardHandlers.textInput(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === _rpc_types__WEBPACK_IMPORTED_MODULE_7__.WorkerEvent.TextCopy) {\n                _zerde_keyboard_handlers__WEBPACK_IMPORTED_MODULE_6__.zerdeKeyboardHandlers.textCopy(zerdeBuilder);\n            }\n            window.cefHandleKeyboardEvent(buffer);\n        });\n        window.fromCefSetIMEPosition = (x, y) => {\n            showTextIME({ x, y });\n        };\n        document.addEventListener(\"keydown\", (event) => {\n            const code = event.keyCode;\n            if (event.metaKey || event.ctrlKey) {\n                if (!textareaHasFocus()) {\n                    // TODO(JP): Maybe at some point we should use some library for these keycodes,\n                    // e.g. see https://stackoverflow.com/questions/1465374/event-keycode-constants\n                    if (code == 67 /* c */) {\n                        window.cefTriggerCopy();\n                    }\n                    else if (code == 88 /* x */) {\n                        window.cefTriggerCut();\n                    }\n                    else if (code == 65 /* a */) {\n                        window.cefTriggerSelectAll();\n                    }\n                }\n                // We want pastes to also be triggered when the textarea has focus, so we can\n                // handle the paste event in JS.\n                if (code == 86 /* v */) {\n                    window.cefTriggerPaste();\n                }\n            }\n        });\n        resolve();\n    });\n});\nconst createBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const paramType = (0,_common__WEBPACK_IMPORTED_MODULE_1__.getWrfParamType)(data, false);\n    const [cefBuffer] = window.cefCreateArrayBuffer(data.length, paramType);\n    (0,_common__WEBPACK_IMPORTED_MODULE_1__.copyArrayToRustBuffer)(data, cefBuffer, 0);\n    return transformReturnParams([\n        [cefBuffer, undefined, paramType],\n    ])[0];\n});\nconst createReadOnlyBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const paramType = (0,_common__WEBPACK_IMPORTED_MODULE_1__.getWrfParamType)(data, true);\n    const [cefBuffer, arcPtr] = window.cefCreateArrayBuffer(data.length, paramType);\n    (0,_common__WEBPACK_IMPORTED_MODULE_1__.copyArrayToRustBuffer)(data, cefBuffer, 0);\n    return transformReturnParams([\n        [cefBuffer, arcPtr, paramType],\n    ])[0];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfY2VmX3J1bnRpbWUudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3dyZl9jZWZfcnVudGltZS50cz8wNmZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMS1wcmVzZW50LCBDcnVpc2UgTExDXG4vL1xuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UtQVBBQ0hFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGN1cnNvck1hcCB9IGZyb20gXCIuL2N1cnNvcl9tYXBcIjtcbmltcG9ydCB7IGNvcHlBcnJheVRvUnVzdEJ1ZmZlciwgZ2V0V3JmUGFyYW1UeXBlIH0gZnJvbSBcIi4vY29tbW9uXCI7XG5pbXBvcnQgeyBtYWtlVGV4dGFyZWEgfSBmcm9tIFwiLi9tYWtlX3RleHRhcmVhXCI7XG5pbXBvcnQgeyBXcmZQYXJhbVR5cGUsIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGdldENhY2hlZFdyZkJ1ZmZlciwgb3ZlcndyaXRlVHlwZWRBcnJheXNXaXRoV3JmQXJyYXlzLCBpc1dyZkJ1ZmZlciwgY2hlY2tWYWxpZFdyZkFycmF5LCBnZXRXcmZCdWZmZXJDZWYsIH0gZnJvbSBcIi4vd3JmX2J1ZmZlclwiO1xuaW1wb3J0IHsgWmVyZGVCdWlsZGVyIH0gZnJvbSBcIi4vemVyZGVcIjtcbmltcG9ydCB7IHplcmRlS2V5Ym9hcmRIYW5kbGVycyB9IGZyb20gXCIuL3plcmRlX2tleWJvYXJkX2hhbmRsZXJzXCI7XG5pbXBvcnQgeyBXb3JrZXJFdmVudCB9IGZyb20gXCIuL3JwY190eXBlc1wiO1xubGV0IG5ld0NhbGxiYWNrSWQgPSAwO1xuLy8ga2VlcGluZyB0cmFjayBvZiBwZW5kaW5nIGNhbGxiYWNrcyBmcm9tIHJ1c3Qgc2lkZVxuY29uc3QgcGVuZGluZ0NhbGxiYWNrcyA9IHt9O1xuZXhwb3J0IGNvbnN0IGNhbGxSdXN0ID0gKG5hbWUsIHBhcmFtcyA9IFtdKSA9PiB7XG4gICAgY29uc3QgY2VmUGFyYW1zID0gcGFyYW1zLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzV3JmQnVmZmVyKHBhcmFtLmJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICBjaGVja1ZhbGlkV3JmQXJyYXkocGFyYW0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyZkJ1ZmZlciA9IHBhcmFtLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB3cmZCdWZmZXIuX193cmZsaWJXYXNtQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICBnZXRXcmZQYXJhbVR5cGUocGFyYW0sIHdyZkJ1ZmZlci5yZWFkb25seSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IGdldFdyZlBhcmFtVHlwZShwYXJhbSwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgW2NlZkJ1ZmZlcl0gPSB3aW5kb3cuY2VmQ3JlYXRlQXJyYXlCdWZmZXIocGFyYW0ubGVuZ3RoLCBwYXJhbVR5cGUpO1xuICAgICAgICAgICAgY29weUFycmF5VG9SdXN0QnVmZmVyKHBhcmFtLCBjZWZCdWZmZXIsIDApO1xuICAgICAgICAgICAgcmV0dXJuIFtjZWZCdWZmZXIsIHBhcmFtVHlwZV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjYWxsYmFja0lkID0gbmV3Q2FsbGJhY2tJZCsrO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgICAgICBwZW5kaW5nQ2FsbGJhY2tzW2NhbGxiYWNrSWRdID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE8oRG1pdHJ5KTogaW1wbGVtZW50IHJldHJ1bl9lcnJvciBvbiBydXN0IHNpZGUgYW5kIHVzZSByZWplY3QoLi4uKSB0byBjb21tdW5pY2F0ZSB0aGUgZXJyb3JcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgd2luZG93LmNlZkNhbGxSdXN0KG5hbWUsIGNlZlBhcmFtcywgY2FsbGJhY2tJZCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gX3dyZmxpYlJldHVyblBhcmFtcyhwYXJhbXMpIHtcbiAgICBjb25zdCBjYWxsYmFja0lkID0gSlNPTi5wYXJzZShwYXJhbXNbMF0pO1xuICAgIHBlbmRpbmdDYWxsYmFja3NbY2FsbGJhY2tJZF0ocGFyYW1zLnNsaWNlKDEpKTtcbiAgICBkZWxldGUgcGVuZGluZ0NhbGxiYWNrc1tjYWxsYmFja0lkXTtcbn1cbi8vIEluaXRpYWwgc2V0IG9mIGZyYW1ld29yay1zcGVjaWZpYyBmdW5jdGlvbnNcbmNvbnN0IGZyb21DZWZKc0Z1bmN0aW9ucyA9IHtcbiAgICBfd3JmbGliUmV0dXJuUGFyYW1zLFxufTtcbi8vLyBVc2VycyBtdXN0IGNhbGwgdGhpcyBmdW5jdGlvbiB0byByZWdpc3RlciBmdW5jdGlvbnMgYXMgcnVubmFibGUgZnJvbVxuLy8vIFJ1c3QgdmlhIGBbQ3g6OmNhbGxfanNdYC5cbmV4cG9ydCBjb25zdCByZWdpc3RlckNhbGxKc0NhbGxiYWNrcyA9IChmbnMpID0+IHtcbiAgICAvLyBDaGVjayB0aGF0IGFsbCBuZXcgZnVuY3Rpb25zIGFyZSB1bmlxdWVcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmbnMpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gZnJvbUNlZkpzRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiBvdmVyd3JpdGluZyBleGlzdGluZyBmdW5jdGlvbiBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihmcm9tQ2VmSnNGdW5jdGlvbnMsIGZucyk7XG4gICAgd2luZG93LmNlZlJlYWR5Rm9yTWVzc2FnZXMoKTtcbn07XG4vLy8gVXNlcnMgbXVzdCBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gdW5yZWdpc3RlciBmdW5jdGlvbnMgYXMgcnVubmFibGUgZnJvbVxuLy8vIFJ1c3QgdmlhIGBbQ3g6OmNhbGxfanNdYC5cbmV4cG9ydCBjb25zdCB1bnJlZ2lzdGVyQ2FsbEpzQ2FsbGJhY2tzID0gKGZuTmFtZXMpID0+IHtcbiAgICBmbk5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBmdW5jdGlvbnMgYXJlIHJlZ2lzdGVyZWRcbiAgICAgICAgaWYgKCEobmFtZSBpbiBmcm9tQ2VmSnNGdW5jdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiB1bnJlZ2lzdGVyaW5nIG5vbi1leGlzdGVudCBmdW5jdGlvbiBcIiR7bmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBmcm9tQ2VmSnNGdW5jdGlvbnNbbmFtZV07XG4gICAgfSk7XG59O1xuY29uc3QgdHJhbnNmb3JtUmV0dXJuUGFyYW1zID0gKHJldHVyblBhcmFtcykgPT4gcmV0dXJuUGFyYW1zLm1hcCgocGFyYW0pID0+IHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IFtidWZmZXIsIGFyY1B0ciwgcGFyYW1UeXBlXSA9IHBhcmFtO1xuICAgICAgICBjb25zdCB3cmZCdWZmZXIgPSBnZXRXcmZCdWZmZXJDZWYoYnVmZmVyLCBhcmNQdHIsIHBhcmFtVHlwZSk7XG4gICAgICAgIGlmIChwYXJhbVR5cGUgPT09IFdyZlBhcmFtVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyZlBhcmFtIGJ1ZmZlciB0eXBlIGNhbGxlZCB3aXRoIHN0cmluZyBwYXJhbVR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlc2UgYXJlIGFjdHVhbGx5IFdyZkFycmF5IHR5cGVzLCBzaW5jZSB3ZSBvdmVyd3JpdGUgVHlwZWRBcnJheXMgaW4gb3ZlcndyaXRlVHlwZWRBcnJheXNXaXRoV3JmQXJyYXlzKClcbiAgICAgICAgY29uc3QgUGFyYW1UeXBlVG9BcnJheUNvbnN0cnVjdG9yID0ge1xuICAgICAgICAgICAgW1dyZlBhcmFtVHlwZS5VOEJ1ZmZlcl06IFVpbnQ4QXJyYXksXG4gICAgICAgICAgICBbV3JmUGFyYW1UeXBlLlJlYWRPbmx5VThCdWZmZXJdOiBVaW50OEFycmF5LFxuICAgICAgICAgICAgW1dyZlBhcmFtVHlwZS5GMzJCdWZmZXJdOiBGbG9hdDMyQXJyYXksXG4gICAgICAgICAgICBbV3JmUGFyYW1UeXBlLlJlYWRPbmx5RjMyQnVmZmVyXTogRmxvYXQzMkFycmF5LFxuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGluZyBhcnJheSB3aXRoIHN0YWJsZSBpZGVudGl0eSBhcyB0aGF0J3Mgd2hhdCB1bmRlcmx5aW5nIHVuZGVybHlpbmcgQVBJIGV4cGVjdHNcbiAgICAgICAgcmV0dXJuIGdldENhY2hlZFdyZkJ1ZmZlcih3cmZCdWZmZXIsIG5ldyBQYXJhbVR5cGVUb0FycmF5Q29uc3RydWN0b3JbcGFyYW1UeXBlXSh3cmZCdWZmZXIpKTtcbiAgICB9XG59KTtcbi8vIFRPRE8oSlApOiBTb21lIG9mIHRoaXMgY29kZSBpcyBkdXBsaWNhdGVkIHdpdGggY2FsbFJ1c3QvY2FsbF9qczsgc2VlIGlmIHdlIGNhbiByZXVzZSBzb21lLlxuZXhwb3J0IGNvbnN0IGNhbGxSdXN0SW5TYW1lVGhyZWFkU3luYyA9IChuYW1lLCBwYXJhbXMgPSBbXSkgPT4ge1xuICAgIGNvbnN0IGNlZlBhcmFtcyA9IHBhcmFtcy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IGdldFdyZlBhcmFtVHlwZShwYXJhbSwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgW2NlZkJ1ZmZlcl0gPSB3aW5kb3cuY2VmQ3JlYXRlQXJyYXlCdWZmZXIocGFyYW0ubGVuZ3RoLCBwYXJhbVR5cGUpO1xuICAgICAgICAgICAgLy8gVE9ETyhEbWl0cnkpOiBpbXBsZW1lbnQgb3B0aW1pemF0aW9uIHRvIGF2b2lkIGNvcHlpbmcgd2hlbiBwb3NzaWJsZVxuICAgICAgICAgICAgY29weUFycmF5VG9SdXN0QnVmZmVyKHBhcmFtLCBjZWZCdWZmZXIsIDApO1xuICAgICAgICAgICAgcmV0dXJuIFtjZWZCdWZmZXIsIHBhcmFtVHlwZV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZXR1cm5QYXJhbXMgPSB3aW5kb3cuY2VmQ2FsbFJ1c3RJblNhbWVUaHJlYWRTeW5jKG5hbWUsIGNlZlBhcmFtcyk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVJldHVyblBhcmFtcyhyZXR1cm5QYXJhbXMpO1xufTtcbmV4cG9ydCBjb25zdCB3cmZOZXdXb3JrZXJQb3J0ID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImB3cmZOZXdXb3JrZXJQb3J0YCBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBvbiBDRUZcIik7XG59O1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZVdyZkFycmF5Rm9yUG9zdE1lc3NhZ2UgPSAoX3Bvc3RNZXNzYWdlRGF0YSkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBzZXJpYWxpemVXcmZBcnJheUZvclBvc3RNZXNzYWdlYCBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBvbiBDRUZcIik7XG59O1xuZXhwb3J0IGNvbnN0IGRlc2VyaWFsaXplV3JmQXJyYXlGcm9tUG9zdE1lc3NhZ2UgPSAoX3Bvc3RNZXNzYWdlRGF0YSkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBkZXNlcmlhbGl6ZVdyZkFycmF5RnJvbVBvc3RNZXNzYWdlYCBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBvbiBDRUZcIik7XG59O1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemUgPSAoX2luaXRQYXJhbXMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgb3ZlcndyaXRlVHlwZWRBcnJheXNXaXRoV3JmQXJyYXlzKCk7XG4gICAgd2luZG93LmZyb21DZWZTZXRNb3VzZUN1cnNvciA9IChjdXJzb3JJZCkgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JNYXBbY3Vyc29ySWRdIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuZnJvbUNlZkNhbGxKc0Z1bmN0aW9uID0gKG5hbWUsIHBhcmFtcykgPT4ge1xuICAgICAgICBmcm9tQ2VmSnNGdW5jdGlvbnNbbmFtZV0odHJhbnNmb3JtUmV0dXJuUGFyYW1zKHBhcmFtcykpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNob3dUZXh0SU1FLCB0ZXh0YXJlYUhhc0ZvY3VzIH0gPSBtYWtlVGV4dGFyZWEoKHRhRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3RzID0gMjA7XG4gICAgICAgICAgICBjb25zdCBbYnVmZmVyXSA9IHdpbmRvdy5jZWZDcmVhdGVBcnJheUJ1ZmZlcihzbG90cyAqIDQsIFdyZlBhcmFtVHlwZS5VOEJ1ZmZlcik7XG4gICAgICAgICAgICBjb25zdCB6ZXJkZUJ1aWxkZXIgPSBuZXcgWmVyZGVCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgICAgICBncm93Q2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3Jvd2luZyBvZiB0aGlzIGJ1ZmZlciBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0YUV2ZW50LnR5cGUgPT09IFdvcmtlckV2ZW50LktleURvd24pIHtcbiAgICAgICAgICAgICAgICB6ZXJkZUtleWJvYXJkSGFuZGxlcnMua2V5RG93bih6ZXJkZUJ1aWxkZXIsIHRhRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFFdmVudC50eXBlID09PSBXb3JrZXJFdmVudC5LZXlVcCkge1xuICAgICAgICAgICAgICAgIHplcmRlS2V5Ym9hcmRIYW5kbGVycy5rZXlVcCh6ZXJkZUJ1aWxkZXIsIHRhRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFFdmVudC50eXBlID09PSBXb3JrZXJFdmVudC5UZXh0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICB6ZXJkZUtleWJvYXJkSGFuZGxlcnMudGV4dElucHV0KHplcmRlQnVpbGRlciwgdGFFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YUV2ZW50LnR5cGUgPT09IFdvcmtlckV2ZW50LlRleHRDb3B5KSB7XG4gICAgICAgICAgICAgICAgemVyZGVLZXlib2FyZEhhbmRsZXJzLnRleHRDb3B5KHplcmRlQnVpbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuY2VmSGFuZGxlS2V5Ym9hcmRFdmVudChidWZmZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmZyb21DZWZTZXRJTUVQb3NpdGlvbiA9ICh4LCB5KSA9PiB7XG4gICAgICAgICAgICBzaG93VGV4dElNRSh7IHgsIHkgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgICAgICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXh0YXJlYUhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhKUCk6IE1heWJlIGF0IHNvbWUgcG9pbnQgd2Ugc2hvdWxkIHVzZSBzb21lIGxpYnJhcnkgZm9yIHRoZXNlIGtleWNvZGVzLFxuICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDY1Mzc0L2V2ZW50LWtleWNvZGUtY29uc3RhbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDY3IC8qIGMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jZWZUcmlnZ2VyQ29weSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPT0gODggLyogeCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNlZlRyaWdnZXJDdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlID09IDY1IC8qIGEgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jZWZUcmlnZ2VyU2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCBwYXN0ZXMgdG8gYWxzbyBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdGV4dGFyZWEgaGFzIGZvY3VzLCBzbyB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHBhc3RlIGV2ZW50IGluIEpTLlxuICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDg2IC8qIHYgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNlZlRyaWdnZXJQYXN0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbn0pO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUJ1ZmZlciA9IChkYXRhKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBwYXJhbVR5cGUgPSBnZXRXcmZQYXJhbVR5cGUoZGF0YSwgZmFsc2UpO1xuICAgIGNvbnN0IFtjZWZCdWZmZXJdID0gd2luZG93LmNlZkNyZWF0ZUFycmF5QnVmZmVyKGRhdGEubGVuZ3RoLCBwYXJhbVR5cGUpO1xuICAgIGNvcHlBcnJheVRvUnVzdEJ1ZmZlcihkYXRhLCBjZWZCdWZmZXIsIDApO1xuICAgIHJldHVybiB0cmFuc2Zvcm1SZXR1cm5QYXJhbXMoW1xuICAgICAgICBbY2VmQnVmZmVyLCB1bmRlZmluZWQsIHBhcmFtVHlwZV0sXG4gICAgXSlbMF07XG59KTtcbmV4cG9ydCBjb25zdCBjcmVhdGVSZWFkT25seUJ1ZmZlciA9IChkYXRhKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBwYXJhbVR5cGUgPSBnZXRXcmZQYXJhbVR5cGUoZGF0YSwgdHJ1ZSk7XG4gICAgY29uc3QgW2NlZkJ1ZmZlciwgYXJjUHRyXSA9IHdpbmRvdy5jZWZDcmVhdGVBcnJheUJ1ZmZlcihkYXRhLmxlbmd0aCwgcGFyYW1UeXBlKTtcbiAgICBjb3B5QXJyYXlUb1J1c3RCdWZmZXIoZGF0YSwgY2VmQnVmZmVyLCAwKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtUmV0dXJuUGFyYW1zKFtcbiAgICAgICAgW2NlZkJ1ZmZlciwgYXJjUHRyLCBwYXJhbVR5cGVdLFxuICAgIF0pWzBdO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./wrf_cef_runtime.ts\n");

/***/ }),

/***/ "./wrf_runtime.ts":
/*!************************!*\
  !*** ./wrf_runtime.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initialize\": () => (/* binding */ initialize),\n/* harmony export */   \"wrfNewWorkerPort\": () => (/* binding */ wrfNewWorkerPort),\n/* harmony export */   \"registerCallJsCallbacks\": () => (/* binding */ registerCallJsCallbacks),\n/* harmony export */   \"unregisterCallJsCallbacks\": () => (/* binding */ unregisterCallJsCallbacks),\n/* harmony export */   \"callRust\": () => (/* binding */ callRust),\n/* harmony export */   \"serializeWrfArrayForPostMessage\": () => (/* binding */ serializeWrfArrayForPostMessage),\n/* harmony export */   \"deserializeWrfArrayFromPostMessage\": () => (/* binding */ deserializeWrfArrayFromPostMessage),\n/* harmony export */   \"callRustInSameThreadSync\": () => (/* binding */ callRustInSameThreadSync),\n/* harmony export */   \"jsRuntime\": () => (/* reexport safe */ _type_of_runtime__WEBPACK_IMPORTED_MODULE_2__.jsRuntime),\n/* harmony export */   \"createBuffer\": () => (/* binding */ createBuffer),\n/* harmony export */   \"createReadOnlyBuffer\": () => (/* binding */ createReadOnlyBuffer)\n/* harmony export */ });\n/* harmony import */ var _wrf_wasm_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrf_wasm_runtime */ \"./wrf_wasm_runtime.ts\");\n/* harmony import */ var _wrf_cef_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrf_cef_runtime */ \"./wrf_cef_runtime.ts\");\n/* harmony import */ var _type_of_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type_of_runtime */ \"./type_of_runtime.ts\");\n/* harmony import */ var _wrf_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrf.css */ \"./wrf.css\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// This is the universal Wrf Runtime which will work on both CEF and WebAssembly environments,\n// doing runtime detection of which modules to load. No other file besides this one should conditionally\n// branch based on environments, such that cef/wasm runtimes can work without including unnecessary code.\n\n\n\n\nconst { initialize, wrfNewWorkerPort, registerCallJsCallbacks, unregisterCallJsCallbacks, callRust, serializeWrfArrayForPostMessage, deserializeWrfArrayFromPostMessage, callRustInSameThreadSync, createBuffer, createReadOnlyBuffer, } = _type_of_runtime__WEBPACK_IMPORTED_MODULE_2__.jsRuntime === \"cef\" ? _wrf_cef_runtime__WEBPACK_IMPORTED_MODULE_1__ : _wrf_wasm_runtime__WEBPACK_IMPORTED_MODULE_0__;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfcnVudGltZS50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vd3JmX3J1bnRpbWUudHM/NGU1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjEtcHJlc2VudCwgQ3J1aXNlIExMQ1xuLy9cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCxcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFLUFQQUNIRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gVGhpcyBpcyB0aGUgdW5pdmVyc2FsIFdyZiBSdW50aW1lIHdoaWNoIHdpbGwgd29yayBvbiBib3RoIENFRiBhbmQgV2ViQXNzZW1ibHkgZW52aXJvbm1lbnRzLFxuLy8gZG9pbmcgcnVudGltZSBkZXRlY3Rpb24gb2Ygd2hpY2ggbW9kdWxlcyB0byBsb2FkLiBObyBvdGhlciBmaWxlIGJlc2lkZXMgdGhpcyBvbmUgc2hvdWxkIGNvbmRpdGlvbmFsbHlcbi8vIGJyYW5jaCBiYXNlZCBvbiBlbnZpcm9ubWVudHMsIHN1Y2ggdGhhdCBjZWYvd2FzbSBydW50aW1lcyBjYW4gd29yayB3aXRob3V0IGluY2x1ZGluZyB1bm5lY2Vzc2FyeSBjb2RlLlxuaW1wb3J0ICogYXMgd2FzbSBmcm9tIFwiLi93cmZfd2FzbV9ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyBjZWYgZnJvbSBcIi4vd3JmX2NlZl9ydW50aW1lXCI7XG5pbXBvcnQgeyBqc1J1bnRpbWUgfSBmcm9tIFwiLi90eXBlX29mX3J1bnRpbWVcIjtcbmltcG9ydCBcIi4vd3JmLmNzc1wiO1xuY29uc3QgeyBpbml0aWFsaXplLCB3cmZOZXdXb3JrZXJQb3J0LCByZWdpc3RlckNhbGxKc0NhbGxiYWNrcywgdW5yZWdpc3RlckNhbGxKc0NhbGxiYWNrcywgY2FsbFJ1c3QsIHNlcmlhbGl6ZVdyZkFycmF5Rm9yUG9zdE1lc3NhZ2UsIGRlc2VyaWFsaXplV3JmQXJyYXlGcm9tUG9zdE1lc3NhZ2UsIGNhbGxSdXN0SW5TYW1lVGhyZWFkU3luYywgY3JlYXRlQnVmZmVyLCBjcmVhdGVSZWFkT25seUJ1ZmZlciwgfSA9IGpzUnVudGltZSA9PT0gXCJjZWZcIiA/IGNlZiA6IHdhc207XG5leHBvcnQgeyBpbml0aWFsaXplLCB3cmZOZXdXb3JrZXJQb3J0LCByZWdpc3RlckNhbGxKc0NhbGxiYWNrcywgdW5yZWdpc3RlckNhbGxKc0NhbGxiYWNrcywgY2FsbFJ1c3QsIHNlcmlhbGl6ZVdyZkFycmF5Rm9yUG9zdE1lc3NhZ2UsIGRlc2VyaWFsaXplV3JmQXJyYXlGcm9tUG9zdE1lc3NhZ2UsIGNhbGxSdXN0SW5TYW1lVGhyZWFkU3luYywganNSdW50aW1lLCBjcmVhdGVCdWZmZXIsIGNyZWF0ZVJlYWRPbmx5QnVmZmVyLCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./wrf_runtime.ts\n");

/***/ }),

/***/ "./wrf_test.ts":
/*!*********************!*\
  !*** ./wrf_test.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"expect\": () => (/* binding */ expect),\n/* harmony export */   \"expectThrow\": () => (/* binding */ expectThrow),\n/* harmony export */   \"expectThrowAsync\": () => (/* binding */ expectThrowAsync),\n/* harmony export */   \"expectDeallocationOrUnregister\": () => (/* binding */ expectDeallocationOrUnregister),\n/* harmony export */   \"inTest\": () => (/* binding */ inTest),\n/* harmony export */   \"setInTest\": () => (/* binding */ setInTest)\n/* harmony export */ });\n/* harmony import */ var _type_of_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type_of_runtime */ \"./type_of_runtime.ts\");\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst expect = (actual, expected) => {\n    if (expected === actual) {\n        console.debug(`Success: Got ${actual}, Expected ${expected}`);\n    }\n    else {\n        throw new Error(`Failure: Got ${actual}, Expected ${expected}`);\n    }\n};\n// TODO(Paras): Would be nice to combine the two functions below at some point.\nconst expectThrow = (f, expectedMessage) => {\n    let error;\n    try {\n        f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n};\nconst expectThrowAsync = (f, expectedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n    let error;\n    try {\n        yield f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n});\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst checkConditionTimeout = (condition, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n    const startTime = performance.now();\n    while (!condition() && performance.now() < startTime + timeout) {\n        yield sleep(10);\n    }\n    return condition();\n});\n// Generate some dummy data and then delete it. This usually triggers the garbage collector.\nconst generateGarbage = () => {\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        self[\"garbage_\" + i] = { i };\n    }\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        delete self[\"garbage_\" + i];\n    }\n};\nconst arcAllocated = (callRust, buffer) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!buffer.__wrflibBufferData.readonly)\n        throw new Error(\"arcAllocated called on mutable buffer\");\n    const arcPtr = buffer.__wrflibBufferData.arcPtr;\n    // We still have the buffer here! So it should still be allocated.\n    expect(_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedArcs[arcPtr], true);\n    const [result] = yield callRust(\"check_arc_count\", [`${BigInt(arcPtr)}`]);\n    const [countBeforeDeallocation] = result;\n    expect(countBeforeDeallocation, 1);\n    return arcPtr;\n});\nconst arcDeallocated = (arcPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // From here on out we don't refer to `buffer` any more, so it should get\n    // deallocated, if the garbage collector is any good.\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedArcs[arcPtr] === false;\n    }, 20000), true);\n});\nconst vecDeallocated = (bufferPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // Even though we have the buffer, it might have already been unregistered\n    // when passed to Rust. We shouldn't read/write to it any more. If this is the\n    // case, let's just bail.\n    if (!_wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedVecs[bufferPtr])\n        return;\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return _wrf_buffer__WEBPACK_IMPORTED_MODULE_1__.allocatedVecs[bufferPtr] === false;\n    }, 20000), true);\n});\n// Test that WrfBuffers were deallocated at some point in the next 20 seconds.\n// This is a bit brittle given that there are no guarantees for garbage collection during this time,\n// but observationally this ends up being enough time. The caller must also ensure that the buffer will go out of scope\n// shortly after calling this.\n// We have to pass in `callRust` because we can call this function from a variety of runtimes.\n// Note that assertions on garbage collection are extremely sensitive to exactly how these functions are written,\n// and can easily break if you restucture the function, use a different/newer browser, etc!\nconst expectDeallocationOrUnregister = (callRust, wrfArray) => {\n    // Deallocation code is only run in WASM for now.\n    if (_type_of_runtime__WEBPACK_IMPORTED_MODULE_0__.jsRuntime === \"cef\")\n        return Promise.resolve();\n    const buffer = wrfArray.buffer;\n    return buffer.readonly\n        ? arcAllocated(callRust, buffer).then((arcPtr) => arcDeallocated(arcPtr))\n        : vecDeallocated(buffer.__wrflibBufferData.bufferPtr);\n};\nlet inTest = false;\n// Set this to true to enable testing code\nconst setInTest = (v) => {\n    inTest = v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfdGVzdC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3JmLy4vd3JmX3Rlc3QudHM/MzI5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjEtcHJlc2VudCwgQ3J1aXNlIExMQ1xuLy9cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCxcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFLUFQQUNIRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBqc1J1bnRpbWUgfSBmcm9tIFwiLi90eXBlX29mX3J1bnRpbWVcIjtcbmltcG9ydCB7IGFsbG9jYXRlZEFyY3MsIGFsbG9jYXRlZFZlY3MgfSBmcm9tIFwiLi93cmZfYnVmZmVyXCI7XG5leHBvcnQgY29uc3QgZXhwZWN0ID0gKGFjdHVhbCwgZXhwZWN0ZWQpID0+IHtcbiAgICBpZiAoZXhwZWN0ZWQgPT09IGFjdHVhbCkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKGBTdWNjZXNzOiBHb3QgJHthY3R1YWx9LCBFeHBlY3RlZCAke2V4cGVjdGVkfWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsdXJlOiBHb3QgJHthY3R1YWx9LCBFeHBlY3RlZCAke2V4cGVjdGVkfWApO1xuICAgIH1cbn07XG4vLyBUT0RPKFBhcmFzKTogV291bGQgYmUgbmljZSB0byBjb21iaW5lIHRoZSB0d28gZnVuY3Rpb25zIGJlbG93IGF0IHNvbWUgcG9pbnQuXG5leHBvcnQgY29uc3QgZXhwZWN0VGhyb3cgPSAoZiwgZXhwZWN0ZWRNZXNzYWdlKSA9PiB7XG4gICAgbGV0IGVycm9yO1xuICAgIHRyeSB7XG4gICAgICAgIGYoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgIH1cbiAgICBleHBlY3QoISFlcnJvciwgdHJ1ZSk7XG4gICAgaWYgKGVycm9yICYmIGV4cGVjdGVkTWVzc2FnZSkge1xuICAgICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSwgZXhwZWN0ZWRNZXNzYWdlKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGV4cGVjdFRocm93QXN5bmMgPSAoZiwgZXhwZWN0ZWRNZXNzYWdlKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgICAgeWllbGQgZigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvciA9IGU7XG4gICAgfVxuICAgIGV4cGVjdCghIWVycm9yLCB0cnVlKTtcbiAgICBpZiAoZXJyb3IgJiYgZXhwZWN0ZWRNZXNzYWdlKSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlLCBleHBlY3RlZE1lc3NhZ2UpO1xuICAgIH1cbn0pO1xuY29uc3Qgc2xlZXAgPSAobXMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5jb25zdCBjaGVja0NvbmRpdGlvblRpbWVvdXQgPSAoY29uZGl0aW9uLCB0aW1lb3V0KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB3aGlsZSAoIWNvbmRpdGlvbigpICYmIHBlcmZvcm1hbmNlLm5vdygpIDwgc3RhcnRUaW1lICsgdGltZW91dCkge1xuICAgICAgICB5aWVsZCBzbGVlcCgxMCk7XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb24oKTtcbn0pO1xuLy8gR2VuZXJhdGUgc29tZSBkdW1teSBkYXRhIGFuZCB0aGVuIGRlbGV0ZSBpdC4gVGhpcyB1c3VhbGx5IHRyaWdnZXJzIHRoZSBnYXJiYWdlIGNvbGxlY3Rvci5cbmNvbnN0IGdlbmVyYXRlR2FyYmFnZSA9ICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDAwOyBpKyspIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzZWxmW1wiZ2FyYmFnZV9cIiArIGldID0geyBpIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDA7IGkrKykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGV0ZSBzZWxmW1wiZ2FyYmFnZV9cIiArIGldO1xuICAgIH1cbn07XG5jb25zdCBhcmNBbGxvY2F0ZWQgPSAoY2FsbFJ1c3QsIGJ1ZmZlcikgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKCFidWZmZXIuX193cmZsaWJCdWZmZXJEYXRhLnJlYWRvbmx5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcmNBbGxvY2F0ZWQgY2FsbGVkIG9uIG11dGFibGUgYnVmZmVyXCIpO1xuICAgIGNvbnN0IGFyY1B0ciA9IGJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEuYXJjUHRyO1xuICAgIC8vIFdlIHN0aWxsIGhhdmUgdGhlIGJ1ZmZlciBoZXJlISBTbyBpdCBzaG91bGQgc3RpbGwgYmUgYWxsb2NhdGVkLlxuICAgIGV4cGVjdChhbGxvY2F0ZWRBcmNzW2FyY1B0cl0sIHRydWUpO1xuICAgIGNvbnN0IFtyZXN1bHRdID0geWllbGQgY2FsbFJ1c3QoXCJjaGVja19hcmNfY291bnRcIiwgW2Ake0JpZ0ludChhcmNQdHIpfWBdKTtcbiAgICBjb25zdCBbY291bnRCZWZvcmVEZWFsbG9jYXRpb25dID0gcmVzdWx0O1xuICAgIGV4cGVjdChjb3VudEJlZm9yZURlYWxsb2NhdGlvbiwgMSk7XG4gICAgcmV0dXJuIGFyY1B0cjtcbn0pO1xuY29uc3QgYXJjRGVhbGxvY2F0ZWQgPSAoYXJjUHRyKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAvLyBGcm9tIGhlcmUgb24gb3V0IHdlIGRvbid0IHJlZmVyIHRvIGBidWZmZXJgIGFueSBtb3JlLCBzbyBpdCBzaG91bGQgZ2V0XG4gICAgLy8gZGVhbGxvY2F0ZWQsIGlmIHRoZSBnYXJiYWdlIGNvbGxlY3RvciBpcyBhbnkgZ29vZC5cbiAgICBleHBlY3QoeWllbGQgY2hlY2tDb25kaXRpb25UaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGVHYXJiYWdlKCk7XG4gICAgICAgIHJldHVybiBhbGxvY2F0ZWRBcmNzW2FyY1B0cl0gPT09IGZhbHNlO1xuICAgIH0sIDIwMDAwKSwgdHJ1ZSk7XG59KTtcbmNvbnN0IHZlY0RlYWxsb2NhdGVkID0gKGJ1ZmZlclB0cikgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgLy8gRXZlbiB0aG91Z2ggd2UgaGF2ZSB0aGUgYnVmZmVyLCBpdCBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiB1bnJlZ2lzdGVyZWRcbiAgICAvLyB3aGVuIHBhc3NlZCB0byBSdXN0LiBXZSBzaG91bGRuJ3QgcmVhZC93cml0ZSB0byBpdCBhbnkgbW9yZS4gSWYgdGhpcyBpcyB0aGVcbiAgICAvLyBjYXNlLCBsZXQncyBqdXN0IGJhaWwuXG4gICAgaWYgKCFhbGxvY2F0ZWRWZWNzW2J1ZmZlclB0cl0pXG4gICAgICAgIHJldHVybjtcbiAgICBleHBlY3QoeWllbGQgY2hlY2tDb25kaXRpb25UaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGVHYXJiYWdlKCk7XG4gICAgICAgIHJldHVybiBhbGxvY2F0ZWRWZWNzW2J1ZmZlclB0cl0gPT09IGZhbHNlO1xuICAgIH0sIDIwMDAwKSwgdHJ1ZSk7XG59KTtcbi8vIFRlc3QgdGhhdCBXcmZCdWZmZXJzIHdlcmUgZGVhbGxvY2F0ZWQgYXQgc29tZSBwb2ludCBpbiB0aGUgbmV4dCAyMCBzZWNvbmRzLlxuLy8gVGhpcyBpcyBhIGJpdCBicml0dGxlIGdpdmVuIHRoYXQgdGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBkdXJpbmcgdGhpcyB0aW1lLFxuLy8gYnV0IG9ic2VydmF0aW9uYWxseSB0aGlzIGVuZHMgdXAgYmVpbmcgZW5vdWdoIHRpbWUuIFRoZSBjYWxsZXIgbXVzdCBhbHNvIGVuc3VyZSB0aGF0IHRoZSBidWZmZXIgd2lsbCBnbyBvdXQgb2Ygc2NvcGVcbi8vIHNob3J0bHkgYWZ0ZXIgY2FsbGluZyB0aGlzLlxuLy8gV2UgaGF2ZSB0byBwYXNzIGluIGBjYWxsUnVzdGAgYmVjYXVzZSB3ZSBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uIGZyb20gYSB2YXJpZXR5IG9mIHJ1bnRpbWVzLlxuLy8gTm90ZSB0aGF0IGFzc2VydGlvbnMgb24gZ2FyYmFnZSBjb2xsZWN0aW9uIGFyZSBleHRyZW1lbHkgc2Vuc2l0aXZlIHRvIGV4YWN0bHkgaG93IHRoZXNlIGZ1bmN0aW9ucyBhcmUgd3JpdHRlbixcbi8vIGFuZCBjYW4gZWFzaWx5IGJyZWFrIGlmIHlvdSByZXN0dWN0dXJlIHRoZSBmdW5jdGlvbiwgdXNlIGEgZGlmZmVyZW50L25ld2VyIGJyb3dzZXIsIGV0YyFcbmV4cG9ydCBjb25zdCBleHBlY3REZWFsbG9jYXRpb25PclVucmVnaXN0ZXIgPSAoY2FsbFJ1c3QsIHdyZkFycmF5KSA9PiB7XG4gICAgLy8gRGVhbGxvY2F0aW9uIGNvZGUgaXMgb25seSBydW4gaW4gV0FTTSBmb3Igbm93LlxuICAgIGlmIChqc1J1bnRpbWUgPT09IFwiY2VmXCIpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCBidWZmZXIgPSB3cmZBcnJheS5idWZmZXI7XG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkb25seVxuICAgICAgICA/IGFyY0FsbG9jYXRlZChjYWxsUnVzdCwgYnVmZmVyKS50aGVuKChhcmNQdHIpID0+IGFyY0RlYWxsb2NhdGVkKGFyY1B0cikpXG4gICAgICAgIDogdmVjRGVhbGxvY2F0ZWQoYnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5idWZmZXJQdHIpO1xufTtcbmV4cG9ydCBsZXQgaW5UZXN0ID0gZmFsc2U7XG4vLyBTZXQgdGhpcyB0byB0cnVlIHRvIGVuYWJsZSB0ZXN0aW5nIGNvZGVcbmV4cG9ydCBjb25zdCBzZXRJblRlc3QgPSAodikgPT4ge1xuICAgIGluVGVzdCA9IHY7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./wrf_test.ts\n");

/***/ }),

/***/ "./wrf_wasm_runtime.ts":
/*!*****************************!*\
  !*** ./wrf_wasm_runtime.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"registerCallJsCallbacks\": () => (/* binding */ registerCallJsCallbacks),\n/* harmony export */   \"unregisterCallJsCallbacks\": () => (/* binding */ unregisterCallJsCallbacks),\n/* harmony export */   \"wrfNewWorkerPort\": () => (/* binding */ wrfNewWorkerPort),\n/* harmony export */   \"serializeWrfArrayForPostMessage\": () => (/* binding */ serializeWrfArrayForPostMessage),\n/* harmony export */   \"callRust\": () => (/* binding */ callRust),\n/* harmony export */   \"createBuffer\": () => (/* binding */ createBuffer),\n/* harmony export */   \"createReadOnlyBuffer\": () => (/* binding */ createReadOnlyBuffer),\n/* harmony export */   \"deserializeWrfArrayFromPostMessage\": () => (/* binding */ deserializeWrfArrayFromPostMessage),\n/* harmony export */   \"callRustInSameThreadSync\": () => (/* binding */ callRustInSameThreadSync),\n/* harmony export */   \"initialize\": () => (/* binding */ initialize)\n/* harmony export */ });\n/* harmony import */ var _wrf_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrf_buffer */ \"./wrf_buffer.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n/* harmony import */ var _make_textarea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./make_textarea */ \"./make_textarea.ts\");\n/* harmony import */ var _webgl_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webgl_renderer */ \"./webgl_renderer.ts\");\n/* harmony import */ var _make_rpc_event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./make_rpc_event */ \"./make_rpc_event.ts\");\n/* harmony import */ var _rpc_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rpc_types */ \"./rpc_types.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst jsFunctions = {};\n/// Users must call this function to register functions as runnable from\n/// Rust via `[Cx::call_js]`.\nconst registerCallJsCallbacks = (fns) => {\n    // Check that all new functions are unique\n    for (const key of Object.keys(fns)) {\n        if (key in jsFunctions) {\n            throw new Error(`Error: overwriting existing function \"${key}\" in window.jsFunctions`);\n        }\n    }\n    Object.assign(jsFunctions, fns);\n};\n/// Users must call this function to unregister functions as runnable from\n/// Rust via `[Cx::call_js]`.\nconst unregisterCallJsCallbacks = (fnNames) => {\n    for (const name of fnNames) {\n        // Check that functions are registered\n        if (!(name in jsFunctions)) {\n            throw new Error(`Error: unregistering non-existent function \"${name}\".`);\n        }\n        delete jsFunctions[name];\n    }\n};\nlet rpc;\nconst wrfNewWorkerPort = () => {\n    const channel = new MessageChannel();\n    rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.BindMainWorkerPort, channel.port1, [channel.port1]);\n    return channel.port2;\n};\nlet wasmMemory;\nconst destructor = (arcPtr) => {\n    rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.DecrementArc, arcPtr);\n};\nconst mutableDestructor = (bufferData) => {\n    rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.DeallocVec, bufferData);\n};\nconst transformParamsFromRust = (params) => (0,_common__WEBPACK_IMPORTED_MODULE_1__.transformParamsFromRustImpl)(wasmMemory, destructor, mutableDestructor, params);\n// TODO(JP): Somewhat duplicated with the other implementation.\nconst temporarilyHeldBuffersForPostMessage = new Set();\nconst serializeWrfArrayForPostMessage = (wrfArray) => {\n    if (!(typeof wrfArray === \"object\" && (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_0__.isWrfBuffer)(wrfArray.buffer))) {\n        throw new Error(\"Only pass Wrf arrays to serializeWrfArrayForPostMessage\");\n    }\n    const wrfBuffer = wrfArray.buffer;\n    if (wrfBuffer.__wrflibBufferData.readonly) {\n        // Store the buffer temporarily until we've received confirmation that the Arc has been incremented.\n        // Otherwise it might get garbage collected and deallocated (if the Arc's count was 1) before it gets\n        // incremented.\n        temporarilyHeldBuffersForPostMessage.add(wrfBuffer);\n        rpc\n            .send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.IncrementArc, wrfBuffer.__wrflibBufferData.arcPtr)\n            .then(() => {\n            temporarilyHeldBuffersForPostMessage.delete(wrfBuffer);\n        });\n    }\n    else {\n        (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_0__.unregisterMutableBuffer)(wrfBuffer);\n    }\n    return {\n        bufferData: wrfBuffer.__wrflibBufferData,\n        byteOffset: wrfArray.byteOffset,\n        byteLength: wrfArray.byteLength,\n    };\n};\nconst callRust = (name, params = []) => __awaiter(void 0, void 0, void 0, function* () {\n    const transformedParams = params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else if ((0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_0__.isWrfBuffer)(param.buffer)) {\n            (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_0__.checkValidWrfArray)(param);\n            return serializeWrfArrayForPostMessage(param);\n        }\n        else {\n            if (!(param.buffer instanceof SharedArrayBuffer)) {\n                console.warn(\"Consider passing Uint8Arrays backed by WrfBuffer or SharedArrayBuffer into `callRust` to prevent copying data\");\n            }\n            return param;\n        }\n    });\n    return transformParamsFromRust(yield rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.CallRust, { name, params: transformedParams }));\n});\nconst createBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const bufferLen = data.byteLength;\n    const bufferPtr = yield rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.CreateBuffer, data, [\n        data.buffer,\n    ]);\n    return transformParamsFromRust([\n        {\n            paramType: (0,_common__WEBPACK_IMPORTED_MODULE_1__.getWrfParamType)(data, false),\n            bufferPtr,\n            bufferLen,\n            bufferCap: bufferLen,\n            readonly: false,\n        },\n    ])[0];\n});\nconst createReadOnlyBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const bufferLen = data.byteLength;\n    const { bufferPtr, arcPtr } = yield rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.CreateReadOnlyBuffer, data, [data.buffer]);\n    return transformParamsFromRust([\n        {\n            paramType: (0,_common__WEBPACK_IMPORTED_MODULE_1__.getWrfParamType)(data, true),\n            bufferPtr,\n            bufferLen,\n            arcPtr,\n            readonly: true,\n        },\n    ])[0];\n});\nconst deserializeWrfArrayFromPostMessage = (postMessageData) => {\n    const wrfBuffer = (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_0__.getWrfBufferWasm)(wasmMemory, postMessageData.bufferData, destructor, mutableDestructor);\n    return new Uint8Array(wrfBuffer, postMessageData.byteOffset, postMessageData.byteLength);\n};\nconst callRustInSameThreadSync = (name, _params = []) => {\n    throw new Error(\"`callRustInSameThreadSync` is currently not supported on the main thread in WASM\");\n};\nconst initialize = (initParams) => new Promise((resolve) => {\n    (0,_wrf_buffer__WEBPACK_IMPORTED_MODULE_0__.overwriteTypedArraysWithWrfArrays)();\n    rpc = new _common__WEBPACK_IMPORTED_MODULE_1__.Rpc(new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"wrf_wasm_worker_ts\"), __webpack_require__.b)));\n    let wasmFilename;\n    if (\"filename\" in initParams) {\n        wasmFilename = initParams.filename;\n    }\n    else {\n        // @ts-ignore\n        const env = new URL(window.document.location).searchParams.get(\"debug\")\n            ? \"debug\"\n            : \"release\";\n        wasmFilename = `target/wasm32-unknown-unknown/${env}/${initParams.targetName}.wasm`;\n    }\n    const wasmPath = new URL(wasmFilename, document.baseURI).href;\n    // Safari (as of version 15.2) needs the WebAssembly Module to be compiled on the browser's\n    // main thread. This also allows us to start compiling while still waiting for the DOM to load.\n    const wasmModulePromise = WebAssembly.compileStreaming(fetch(wasmPath));\n    // TODO(JP): These file handles are only sent to a worker when it starts running;\n    // it currently can't receive any file handles added after that.\n    const fileHandles = [];\n    const loader = () => {\n        const isMobileSafari = self.navigator.platform.match(/iPhone|iPad/i);\n        const isAndroid = self.navigator.userAgent.match(/Android/i);\n        let rpcInitialized = false;\n        rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.ShowIncompatibleBrowserNotification, () => {\n            const span = document.createElement(\"span\");\n            span.style.color = \"white\";\n            (0,_common__WEBPACK_IMPORTED_MODULE_1__.assertNotNull)(canvas.parentNode).replaceChild(span, canvas);\n            span.innerHTML =\n                \"Sorry, we need browser support for WebGL to run<br/>Please update your browser to a more modern one<br/>Update to at least iOS 10, Safari 10, latest Chrome, Edge or Firefox<br/>Go and update and come back, your browser will be better, faster and more secure!<br/>If you are using chrome on OSX on a 2011/2012 mac please enable your GPU at: Override software rendering list:Enable (the top item) in: <a href='about://flags'>about://flags</a>. Or switch to Firefox or Safari.\";\n        });\n        rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.RemoveLoadingIndicators, () => {\n            const loaders = document.getElementsByClassName(\"cx_webgl_loader\");\n            for (let i = 0; i < loaders.length; i++) {\n                (0,_common__WEBPACK_IMPORTED_MODULE_1__.assertNotNull)(loaders[i].parentNode).removeChild(loaders[i]);\n            }\n        });\n        rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.SetDocumentTitle, (title) => {\n            document.title = title;\n        });\n        rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.SetMouseCursor, (style) => {\n            document.body.style.cursor = style;\n        });\n        rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.Fullscreen, () => {\n            if (document.body.requestFullscreen) {\n                document.body.requestFullscreen();\n            }\n            else if (document.body.webkitRequestFullscreen) {\n                document.body.webkitRequestFullscreen();\n            }\n            else if (document.body.mozRequestFullscreen) {\n                document.body.mozRequestFullscreen();\n            }\n        });\n        rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.Normalscreen, () => {\n            if (document.exitFullscreen) {\n                document.exitFullscreen();\n            }\n            else if (document.webkitExitFullscreen) {\n                document.webkitExitFullscreen();\n            }\n            else if (document.mozExitFullscreen) {\n                document.mozExitFullscreen();\n            }\n        });\n        rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.TextCopyResponse, (textCopyResponse) => {\n            window.navigator.clipboard.writeText(textCopyResponse);\n        });\n        rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.EnableGlobalFileDropTarget, () => {\n            document.addEventListener(\"dragenter\", (ev) => {\n                const dataTransfer = ev.dataTransfer;\n                // dataTransfer isn't guaranteed to exist by spec, so it must be checked\n                if (dataTransfer &&\n                    dataTransfer.types.length === 1 &&\n                    dataTransfer.types[0] === \"Files\") {\n                    ev.stopPropagation();\n                    ev.preventDefault();\n                    dataTransfer.dropEffect = \"copy\";\n                    if (rpcInitialized)\n                        rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.DragEnter);\n                }\n            });\n            document.addEventListener(\"dragover\", (ev) => {\n                ev.stopPropagation();\n                ev.preventDefault();\n                if (rpcInitialized)\n                    rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.DragOver, { x: ev.clientX, y: ev.clientY });\n            });\n            document.addEventListener(\"dragleave\", (ev) => {\n                ev.stopPropagation();\n                ev.preventDefault();\n                if (rpcInitialized)\n                    rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.DragLeave);\n            });\n            document.addEventListener(\"drop\", (ev) => {\n                if (!ev.dataTransfer) {\n                    return;\n                }\n                const files = Array.from(ev.dataTransfer.files);\n                if (!files.length) {\n                    return;\n                }\n                ev.preventDefault();\n                ev.stopPropagation();\n                const fileHandlesToSend = [];\n                for (const file of files) {\n                    const fileHandle = {\n                        id: fileHandles.length,\n                        basename: file.name,\n                        file,\n                        lastReadStart: -1,\n                        lastReadEnd: -1,\n                    };\n                    fileHandlesToSend.push(fileHandle);\n                    fileHandles.push(fileHandle);\n                }\n                if (rpcInitialized) {\n                    rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.Drop, { fileHandles, fileHandlesToSend });\n                }\n            });\n        });\n        rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.CallJs, ({ fnName, params }) => {\n            const fn = jsFunctions[fnName];\n            if (!fn) {\n                console.error(`call_js with ${fnName} is not available. Have you registered it using \\`registerCallJsCallbacks\\`?`);\n                return;\n            }\n            fn(transformParamsFromRust(params));\n        });\n        const canvas = document.createElement(\"canvas\");\n        canvas.className = \"cx_webgl\";\n        document.body.appendChild(canvas);\n        const loadingIndicator = document.createElement(\"div\");\n        loadingIndicator.className = \"cx_webgl_loader\";\n        loadingIndicator.innerHTML =\n            '<span></span><div style=\"color: rgba(255, 202, 0, 0.5);\">Loading</div>';\n        document.body.appendChild(loadingIndicator);\n        document.addEventListener(\"contextmenu\", (event) => {\n            var _a;\n            if (event.target instanceof Element &&\n                (!((_a = document.getElementById(\"js_root\")) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ||\n                    Array.from(event.target.classList).includes(\"wrflibPanel\"))) {\n                event.preventDefault();\n            }\n        });\n        document.addEventListener(\"mousedown\", (event) => {\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.CanvasMouseDown, (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_4__.makeRpcMouseEvent)(event));\n        });\n        window.addEventListener(\"mouseup\", (event) => {\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.WindowMouseUp, (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_4__.makeRpcMouseEvent)(event));\n        });\n        window.addEventListener(\"mousemove\", (event) => {\n            document.body.scrollTop = 0;\n            document.body.scrollLeft = 0;\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.WindowMouseMove, (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_4__.makeRpcMouseEvent)(event));\n        });\n        window.addEventListener(\"mouseout\", (event) => {\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.WindowMouseOut, (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_4__.makeRpcMouseEvent)(event));\n        });\n        document.addEventListener(\"touchstart\", (event) => {\n            event.preventDefault();\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.WindowTouchStart, (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_4__.makeRpcTouchEvent)(event));\n        }, { passive: false });\n        window.addEventListener(\"touchmove\", (event) => {\n            event.preventDefault();\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.WindowTouchMove, (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_4__.makeRpcTouchEvent)(event));\n        }, { passive: false });\n        const touchEndCancelLeave = (event) => {\n            event.preventDefault();\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.WindowTouchEndCancelLeave, (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_4__.makeRpcTouchEvent)(event));\n        };\n        window.addEventListener(\"touchend\", touchEndCancelLeave);\n        window.addEventListener(\"touchcancel\", touchEndCancelLeave);\n        document.addEventListener(\"wheel\", (event) => {\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.CanvasWheel, (0,_make_rpc_event__WEBPACK_IMPORTED_MODULE_4__.makeRpcWheelEvent)(event));\n        });\n        window.addEventListener(\"focus\", () => {\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.WindowFocus);\n        });\n        window.addEventListener(\"blur\", () => {\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.WindowBlur);\n        });\n        if (!isMobileSafari && !isAndroid) {\n            // mobile keyboards are unusable on a UI like this\n            const { showTextIME } = (0,_make_textarea__WEBPACK_IMPORTED_MODULE_2__.makeTextarea)((taEvent) => {\n                if (rpcInitialized)\n                    rpc.send(taEvent.type, taEvent);\n            });\n            rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.ShowTextIME, showTextIME);\n        }\n        // One of these variables should get set, depending on if\n        // the browser supports OffscreenCanvas or not.\n        let offscreenCanvas;\n        let webglRenderer;\n        function getSizingData() {\n            const canFullscreen = !!(document.fullscreenEnabled ||\n                document.webkitFullscreenEnabled ||\n                document.mozFullscreenEnabled);\n            const isFullscreen = !!(document.fullscreenElement ||\n                document.webkitFullscreenElement ||\n                document.mozFullscreenElement);\n            return {\n                width: canvas.offsetWidth,\n                height: canvas.offsetHeight,\n                dpiFactor: window.devicePixelRatio,\n                canFullscreen,\n                isFullscreen,\n            };\n        }\n        function onScreenResize() {\n            // TODO(JP): Some day bring this back?\n            // if (is_add_to_homescreen_safari) { // extremely ugly. but whatever.\n            //     if (window.orientation == 90 || window.orientation == -90) {\n            //         h = screen.width;\n            //         w = screen.height - 90;\n            //     }\n            //     else {\n            //         w = screen.width;\n            //         h = screen.height - 80;\n            //     }\n            // }\n            const sizingData = getSizingData();\n            if (webglRenderer) {\n                webglRenderer.resize(sizingData);\n            }\n            if (rpcInitialized)\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.ScreenResize, sizingData);\n        }\n        window.addEventListener(\"resize\", () => onScreenResize());\n        window.addEventListener(\"orientationchange\", () => onScreenResize());\n        let dpiFactor = window.devicePixelRatio;\n        const mqString = \"(resolution: \" + window.devicePixelRatio + \"dppx)\";\n        const mq = matchMedia(mqString);\n        if (mq && mq.addEventListener) {\n            mq.addEventListener(\"change\", () => onScreenResize());\n        }\n        else {\n            // poll for it. yes. its terrible\n            self.setInterval(() => {\n                if (window.devicePixelRatio != dpiFactor) {\n                    dpiFactor = window.devicePixelRatio;\n                    onScreenResize();\n                }\n            }, 1000);\n        }\n        // Some browsers (e.g. Safari 15.2) require SharedArrayBuffers to be initialized\n        // on the browser's main thread; so that's why this has to happen here.\n        //\n        // We also do this before initializing `WebAssembly.Memory`, to make sure we have\n        // enough memory for both.. (This is mostly relevant on mobile; see note below.)\n        const taskWorkerSab = (0,_common__WEBPACK_IMPORTED_MODULE_1__.initTaskWorkerSab)();\n        const taskWorkerRpc = new _common__WEBPACK_IMPORTED_MODULE_1__.Rpc(new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"task_worker_ts\"), __webpack_require__.b)));\n        taskWorkerRpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.TaskWorkerEvent.Init, {\n            taskWorkerSab,\n            wasmMemory,\n        });\n        // Initial has to be equal to or higher than required by the app (which at the time of writing\n        // is around 20 pages).\n        // Maximum has to be equal to or lower than that of the app, which we've currently set to\n        // the maximum for wasm32 (4GB). Browsers should use virtual memory, as to not actually take up\n        // all this space until requested by the app. TODO(JP): We might need to check this behavior in\n        // different browsers at some point (in Chrome it seems to work fine).\n        //\n        // In Safari on my phone (JP), using maximum:65535 causes an out-of-memory error, so we instead\n        // try a hardcoded value of ~400MB.. Note that especially on mobile, all of\n        // this is quite tricky; see e.g. https://github.com/WebAssembly/design/issues/1397\n        //\n        // TODO(JP): It looks like when using shared memory, the maximum might get fully allocated on\n        // some devices (mobile?), which means that there is little room left for JS objects, and it\n        // means that the web page is at higher risk of getting evicted when switching tabs. There are a\n        // few options here:\n        // 1. Allow the user to specify a maximum by hand for mobile in general; or for specific\n        //    devices (cumbersome!).\n        // 2. Allow single-threaded operation, where we don't specify a maximum (but run the risk of\n        //    getting much less memory to use and therefore the app crashing; see again\n        //    https://github.com/WebAssembly/design/issues/1397 for more details).\n        try {\n            wasmMemory = new WebAssembly.Memory({\n                initial: 40,\n                maximum: 65535,\n                shared: true,\n            });\n        }\n        catch (_) {\n            console.log(\"Can't allocate full WebAssembly memory; trying ~400MB\");\n            try {\n                wasmMemory = new WebAssembly.Memory({\n                    initial: 40,\n                    maximum: 6000,\n                    shared: true,\n                });\n            }\n            catch (_) {\n                throw new Error(\"Can't initilialize WebAssembly memory..\");\n            }\n        }\n        // If the browser supports OffscreenCanvas, then we'll use that. Otherwise, we render on\n        // the browser's main thread using WebGLRenderer.\n        try {\n            offscreenCanvas = canvas.transferControlToOffscreen();\n        }\n        catch (_) {\n            webglRenderer = new _webgl_renderer__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderer(canvas, wasmMemory, getSizingData(), () => {\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.ShowIncompatibleBrowserNotification);\n            });\n            rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.RunWebGL, (zerdeParserPtr) => {\n                webglRenderer.processMessages(zerdeParserPtr);\n                return new Promise((resolve) => {\n                    requestAnimationFrame(() => {\n                        resolve(undefined);\n                    });\n                });\n            });\n        }\n        wasmModulePromise.then((wasmModule) => {\n            // Threads need to be spawned on the browser's main thread, otherwise Safari (as of version 15.2)\n            // throws errors.\n            const asyncWorkers = new Set();\n            const threadSpawn = ({ ctxPtr, tlsAndStackData, }) => {\n                const worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"async_worker_ts\"), __webpack_require__.b));\n                const workerErrorHandler = (event) => {\n                    console.log(\"Async worker error event: \", event);\n                };\n                worker.onerror = workerErrorHandler;\n                worker.onmessageerror = workerErrorHandler;\n                const workerRpc = new _common__WEBPACK_IMPORTED_MODULE_1__.Rpc(worker);\n                // Add the worker to an array of workers, to prevent them getting killed when\n                // during garbage collection in Firefox; see https://bugzilla.mozilla.org/show_bug.cgi?id=1592227\n                asyncWorkers.add(worker);\n                const channel = new MessageChannel();\n                rpc.send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.BindMainWorkerPort, channel.port1, [\n                    channel.port1,\n                ]);\n                workerRpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.AsyncWorkerEvent.ThreadSpawn, threadSpawn);\n                workerRpc\n                    .send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.AsyncWorkerEvent.Run, {\n                    wasmModule,\n                    memory: wasmMemory,\n                    taskWorkerSab,\n                    ctxPtr,\n                    fileHandles,\n                    baseUri: document.baseURI,\n                    tlsAndStackData,\n                    mainWorkerPort: channel.port2,\n                }, [channel.port2])\n                    .catch((e) => {\n                    console.error(\"async worker failed\", e);\n                })\n                    .finally(() => {\n                    worker.terminate();\n                    asyncWorkers.delete(worker);\n                });\n            };\n            rpc.receive(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.ThreadSpawn, threadSpawn);\n            rpc\n                .send(_rpc_types__WEBPACK_IMPORTED_MODULE_5__.WorkerEvent.Init, {\n                wasmModule,\n                offscreenCanvas,\n                sizingData: getSizingData(),\n                baseUri: document.baseURI,\n                memory: wasmMemory,\n                taskWorkerSab,\n            }, offscreenCanvas ? [offscreenCanvas] : [])\n                .then(() => {\n                rpcInitialized = true;\n                onScreenResize();\n                resolve();\n            });\n        });\n    };\n    if (document.readyState !== \"loading\") {\n        loader();\n    }\n    else {\n        document.addEventListener(\"DOMContentLoaded\", loader);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93cmZfd2FzbV9ydW50aW1lLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3dyZl93YXNtX3J1bnRpbWUudHM/YmRmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGdldFdyZkJ1ZmZlcldhc20sIGlzV3JmQnVmZmVyLCBvdmVyd3JpdGVUeXBlZEFycmF5c1dpdGhXcmZBcnJheXMsIHVucmVnaXN0ZXJNdXRhYmxlQnVmZmVyLCBjaGVja1ZhbGlkV3JmQXJyYXksIH0gZnJvbSBcIi4vd3JmX2J1ZmZlclwiO1xuaW1wb3J0IHsgYXNzZXJ0Tm90TnVsbCwgZ2V0V3JmUGFyYW1UeXBlLCBpbml0VGFza1dvcmtlclNhYiwgUnBjLCB0cmFuc2Zvcm1QYXJhbXNGcm9tUnVzdEltcGwsIH0gZnJvbSBcIi4vY29tbW9uXCI7XG5pbXBvcnQgeyBtYWtlVGV4dGFyZWEgfSBmcm9tIFwiLi9tYWtlX3RleHRhcmVhXCI7XG5pbXBvcnQgeyBXZWJHTFJlbmRlcmVyIH0gZnJvbSBcIi4vd2ViZ2xfcmVuZGVyZXJcIjtcbmltcG9ydCB7IG1ha2VScGNNb3VzZUV2ZW50LCBtYWtlUnBjVG91Y2hFdmVudCwgbWFrZVJwY1doZWVsRXZlbnQsIH0gZnJvbSBcIi4vbWFrZV9ycGNfZXZlbnRcIjtcbmltcG9ydCB7IFdvcmtlckV2ZW50LCBUYXNrV29ya2VyRXZlbnQsIEFzeW5jV29ya2VyRXZlbnQsIH0gZnJvbSBcIi4vcnBjX3R5cGVzXCI7XG5jb25zdCBqc0Z1bmN0aW9ucyA9IHt9O1xuLy8vIFVzZXJzIG11c3QgY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyBhcyBydW5uYWJsZSBmcm9tXG4vLy8gUnVzdCB2aWEgYFtDeDo6Y2FsbF9qc11gLlxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQ2FsbEpzQ2FsbGJhY2tzID0gKGZucykgPT4ge1xuICAgIC8vIENoZWNrIHRoYXQgYWxsIG5ldyBmdW5jdGlvbnMgYXJlIHVuaXF1ZVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZucykpIHtcbiAgICAgICAgaWYgKGtleSBpbiBqc0Z1bmN0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvcjogb3ZlcndyaXRpbmcgZXhpc3RpbmcgZnVuY3Rpb24gXCIke2tleX1cIiBpbiB3aW5kb3cuanNGdW5jdGlvbnNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKGpzRnVuY3Rpb25zLCBmbnMpO1xufTtcbi8vLyBVc2VycyBtdXN0IGNhbGwgdGhpcyBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIGZ1bmN0aW9ucyBhcyBydW5uYWJsZSBmcm9tXG4vLy8gUnVzdCB2aWEgYFtDeDo6Y2FsbF9qc11gLlxuZXhwb3J0IGNvbnN0IHVucmVnaXN0ZXJDYWxsSnNDYWxsYmFja3MgPSAoZm5OYW1lcykgPT4ge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBmbk5hbWVzKSB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgZnVuY3Rpb25zIGFyZSByZWdpc3RlcmVkXG4gICAgICAgIGlmICghKG5hbWUgaW4ganNGdW5jdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiB1bnJlZ2lzdGVyaW5nIG5vbi1leGlzdGVudCBmdW5jdGlvbiBcIiR7bmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUganNGdW5jdGlvbnNbbmFtZV07XG4gICAgfVxufTtcbmxldCBycGM7XG5leHBvcnQgY29uc3Qgd3JmTmV3V29ya2VyUG9ydCA9ICgpID0+IHtcbiAgICBjb25zdCBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcnBjLnNlbmQoV29ya2VyRXZlbnQuQmluZE1haW5Xb3JrZXJQb3J0LCBjaGFubmVsLnBvcnQxLCBbY2hhbm5lbC5wb3J0MV0pO1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyO1xufTtcbmxldCB3YXNtTWVtb3J5O1xuY29uc3QgZGVzdHJ1Y3RvciA9IChhcmNQdHIpID0+IHtcbiAgICBycGMuc2VuZChXb3JrZXJFdmVudC5EZWNyZW1lbnRBcmMsIGFyY1B0cik7XG59O1xuY29uc3QgbXV0YWJsZURlc3RydWN0b3IgPSAoYnVmZmVyRGF0YSkgPT4ge1xuICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LkRlYWxsb2NWZWMsIGJ1ZmZlckRhdGEpO1xufTtcbmNvbnN0IHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0ID0gKHBhcmFtcykgPT4gdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3RJbXBsKHdhc21NZW1vcnksIGRlc3RydWN0b3IsIG11dGFibGVEZXN0cnVjdG9yLCBwYXJhbXMpO1xuLy8gVE9ETyhKUCk6IFNvbWV3aGF0IGR1cGxpY2F0ZWQgd2l0aCB0aGUgb3RoZXIgaW1wbGVtZW50YXRpb24uXG5jb25zdCB0ZW1wb3JhcmlseUhlbGRCdWZmZXJzRm9yUG9zdE1lc3NhZ2UgPSBuZXcgU2V0KCk7XG5leHBvcnQgY29uc3Qgc2VyaWFsaXplV3JmQXJyYXlGb3JQb3N0TWVzc2FnZSA9ICh3cmZBcnJheSkgPT4ge1xuICAgIGlmICghKHR5cGVvZiB3cmZBcnJheSA9PT0gXCJvYmplY3RcIiAmJiBpc1dyZkJ1ZmZlcih3cmZBcnJheS5idWZmZXIpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHBhc3MgV3JmIGFycmF5cyB0byBzZXJpYWxpemVXcmZBcnJheUZvclBvc3RNZXNzYWdlXCIpO1xuICAgIH1cbiAgICBjb25zdCB3cmZCdWZmZXIgPSB3cmZBcnJheS5idWZmZXI7XG4gICAgaWYgKHdyZkJ1ZmZlci5fX3dyZmxpYkJ1ZmZlckRhdGEucmVhZG9ubHkpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGJ1ZmZlciB0ZW1wb3JhcmlseSB1bnRpbCB3ZSd2ZSByZWNlaXZlZCBjb25maXJtYXRpb24gdGhhdCB0aGUgQXJjIGhhcyBiZWVuIGluY3JlbWVudGVkLlxuICAgICAgICAvLyBPdGhlcndpc2UgaXQgbWlnaHQgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkIGFuZCBkZWFsbG9jYXRlZCAoaWYgdGhlIEFyYydzIGNvdW50IHdhcyAxKSBiZWZvcmUgaXQgZ2V0c1xuICAgICAgICAvLyBpbmNyZW1lbnRlZC5cbiAgICAgICAgdGVtcG9yYXJpbHlIZWxkQnVmZmVyc0ZvclBvc3RNZXNzYWdlLmFkZCh3cmZCdWZmZXIpO1xuICAgICAgICBycGNcbiAgICAgICAgICAgIC5zZW5kKFdvcmtlckV2ZW50LkluY3JlbWVudEFyYywgd3JmQnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YS5hcmNQdHIpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0ZW1wb3JhcmlseUhlbGRCdWZmZXJzRm9yUG9zdE1lc3NhZ2UuZGVsZXRlKHdyZkJ1ZmZlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5yZWdpc3Rlck11dGFibGVCdWZmZXIod3JmQnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnVmZmVyRGF0YTogd3JmQnVmZmVyLl9fd3JmbGliQnVmZmVyRGF0YSxcbiAgICAgICAgYnl0ZU9mZnNldDogd3JmQXJyYXkuYnl0ZU9mZnNldCxcbiAgICAgICAgYnl0ZUxlbmd0aDogd3JmQXJyYXkuYnl0ZUxlbmd0aCxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBjYWxsUnVzdCA9IChuYW1lLCBwYXJhbXMgPSBbXSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBwYXJhbXMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNXcmZCdWZmZXIocGFyYW0uYnVmZmVyKSkge1xuICAgICAgICAgICAgY2hlY2tWYWxpZFdyZkFycmF5KHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVXcmZBcnJheUZvclBvc3RNZXNzYWdlKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKHBhcmFtLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvbnNpZGVyIHBhc3NpbmcgVWludDhBcnJheXMgYmFja2VkIGJ5IFdyZkJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciBpbnRvIGBjYWxsUnVzdGAgdG8gcHJldmVudCBjb3B5aW5nIGRhdGFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3QoeWllbGQgcnBjLnNlbmQoV29ya2VyRXZlbnQuQ2FsbFJ1c3QsIHsgbmFtZSwgcGFyYW1zOiB0cmFuc2Zvcm1lZFBhcmFtcyB9KSk7XG59KTtcbmV4cG9ydCBjb25zdCBjcmVhdGVCdWZmZXIgPSAoZGF0YSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYnVmZmVyTGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZmZlclB0ciA9IHlpZWxkIHJwYy5zZW5kKFdvcmtlckV2ZW50LkNyZWF0ZUJ1ZmZlciwgZGF0YSwgW1xuICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICBdKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zRnJvbVJ1c3QoW1xuICAgICAgICB7XG4gICAgICAgICAgICBwYXJhbVR5cGU6IGdldFdyZlBhcmFtVHlwZShkYXRhLCBmYWxzZSksXG4gICAgICAgICAgICBidWZmZXJQdHIsXG4gICAgICAgICAgICBidWZmZXJMZW4sXG4gICAgICAgICAgICBidWZmZXJDYXA6IGJ1ZmZlckxlbixcbiAgICAgICAgICAgIHJlYWRvbmx5OiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICBdKVswXTtcbn0pO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlYWRPbmx5QnVmZmVyID0gKGRhdGEpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGJ1ZmZlckxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCB7IGJ1ZmZlclB0ciwgYXJjUHRyIH0gPSB5aWVsZCBycGMuc2VuZChXb3JrZXJFdmVudC5DcmVhdGVSZWFkT25seUJ1ZmZlciwgZGF0YSwgW2RhdGEuYnVmZmVyXSk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0KFtcbiAgICAgICAge1xuICAgICAgICAgICAgcGFyYW1UeXBlOiBnZXRXcmZQYXJhbVR5cGUoZGF0YSwgdHJ1ZSksXG4gICAgICAgICAgICBidWZmZXJQdHIsXG4gICAgICAgICAgICBidWZmZXJMZW4sXG4gICAgICAgICAgICBhcmNQdHIsXG4gICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICBdKVswXTtcbn0pO1xuZXhwb3J0IGNvbnN0IGRlc2VyaWFsaXplV3JmQXJyYXlGcm9tUG9zdE1lc3NhZ2UgPSAocG9zdE1lc3NhZ2VEYXRhKSA9PiB7XG4gICAgY29uc3Qgd3JmQnVmZmVyID0gZ2V0V3JmQnVmZmVyV2FzbSh3YXNtTWVtb3J5LCBwb3N0TWVzc2FnZURhdGEuYnVmZmVyRGF0YSwgZGVzdHJ1Y3RvciwgbXV0YWJsZURlc3RydWN0b3IpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh3cmZCdWZmZXIsIHBvc3RNZXNzYWdlRGF0YS5ieXRlT2Zmc2V0LCBwb3N0TWVzc2FnZURhdGEuYnl0ZUxlbmd0aCk7XG59O1xuZXhwb3J0IGNvbnN0IGNhbGxSdXN0SW5TYW1lVGhyZWFkU3luYyA9IChuYW1lLCBfcGFyYW1zID0gW10pID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgY2FsbFJ1c3RJblNhbWVUaHJlYWRTeW5jYCBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBvbiB0aGUgbWFpbiB0aHJlYWQgaW4gV0FTTVwiKTtcbn07XG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZSA9IChpbml0UGFyYW1zKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIG92ZXJ3cml0ZVR5cGVkQXJyYXlzV2l0aFdyZkFycmF5cygpO1xuICAgIHJwYyA9IG5ldyBScGMobmV3IFdvcmtlcihuZXcgVVJMKFwiLi93cmZfd2FzbV93b3JrZXIudHNcIiwgaW1wb3J0Lm1ldGEudXJsKSkpO1xuICAgIGxldCB3YXNtRmlsZW5hbWU7XG4gICAgaWYgKFwiZmlsZW5hbWVcIiBpbiBpbml0UGFyYW1zKSB7XG4gICAgICAgIHdhc21GaWxlbmFtZSA9IGluaXRQYXJhbXMuZmlsZW5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IGVudiA9IG5ldyBVUkwod2luZG93LmRvY3VtZW50LmxvY2F0aW9uKS5zZWFyY2hQYXJhbXMuZ2V0KFwiZGVidWdcIilcbiAgICAgICAgICAgID8gXCJkZWJ1Z1wiXG4gICAgICAgICAgICA6IFwicmVsZWFzZVwiO1xuICAgICAgICB3YXNtRmlsZW5hbWUgPSBgdGFyZ2V0L3dhc20zMi11bmtub3duLXVua25vd24vJHtlbnZ9LyR7aW5pdFBhcmFtcy50YXJnZXROYW1lfS53YXNtYDtcbiAgICB9XG4gICAgY29uc3Qgd2FzbVBhdGggPSBuZXcgVVJMKHdhc21GaWxlbmFtZSwgZG9jdW1lbnQuYmFzZVVSSSkuaHJlZjtcbiAgICAvLyBTYWZhcmkgKGFzIG9mIHZlcnNpb24gMTUuMikgbmVlZHMgdGhlIFdlYkFzc2VtYmx5IE1vZHVsZSB0byBiZSBjb21waWxlZCBvbiB0aGUgYnJvd3NlcidzXG4gICAgLy8gbWFpbiB0aHJlYWQuIFRoaXMgYWxzbyBhbGxvd3MgdXMgdG8gc3RhcnQgY29tcGlsaW5nIHdoaWxlIHN0aWxsIHdhaXRpbmcgZm9yIHRoZSBET00gdG8gbG9hZC5cbiAgICBjb25zdCB3YXNtTW9kdWxlUHJvbWlzZSA9IFdlYkFzc2VtYmx5LmNvbXBpbGVTdHJlYW1pbmcoZmV0Y2god2FzbVBhdGgpKTtcbiAgICAvLyBUT0RPKEpQKTogVGhlc2UgZmlsZSBoYW5kbGVzIGFyZSBvbmx5IHNlbnQgdG8gYSB3b3JrZXIgd2hlbiBpdCBzdGFydHMgcnVubmluZztcbiAgICAvLyBpdCBjdXJyZW50bHkgY2FuJ3QgcmVjZWl2ZSBhbnkgZmlsZSBoYW5kbGVzIGFkZGVkIGFmdGVyIHRoYXQuXG4gICAgY29uc3QgZmlsZUhhbmRsZXMgPSBbXTtcbiAgICBjb25zdCBsb2FkZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTW9iaWxlU2FmYXJpID0gc2VsZi5uYXZpZ2F0b3IucGxhdGZvcm0ubWF0Y2goL2lQaG9uZXxpUGFkL2kpO1xuICAgICAgICBjb25zdCBpc0FuZHJvaWQgPSBzZWxmLm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7XG4gICAgICAgIGxldCBycGNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICBycGMucmVjZWl2ZShXb3JrZXJFdmVudC5TaG93SW5jb21wYXRpYmxlQnJvd3Nlck5vdGlmaWNhdGlvbiwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgc3Bhbi5zdHlsZS5jb2xvciA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgIGFzc2VydE5vdE51bGwoY2FudmFzLnBhcmVudE5vZGUpLnJlcGxhY2VDaGlsZChzcGFuLCBjYW52YXMpO1xuICAgICAgICAgICAgc3Bhbi5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgIFwiU29ycnksIHdlIG5lZWQgYnJvd3NlciBzdXBwb3J0IGZvciBXZWJHTCB0byBydW48YnIvPlBsZWFzZSB1cGRhdGUgeW91ciBicm93c2VyIHRvIGEgbW9yZSBtb2Rlcm4gb25lPGJyLz5VcGRhdGUgdG8gYXQgbGVhc3QgaU9TIDEwLCBTYWZhcmkgMTAsIGxhdGVzdCBDaHJvbWUsIEVkZ2Ugb3IgRmlyZWZveDxici8+R28gYW5kIHVwZGF0ZSBhbmQgY29tZSBiYWNrLCB5b3VyIGJyb3dzZXIgd2lsbCBiZSBiZXR0ZXIsIGZhc3RlciBhbmQgbW9yZSBzZWN1cmUhPGJyLz5JZiB5b3UgYXJlIHVzaW5nIGNocm9tZSBvbiBPU1ggb24gYSAyMDExLzIwMTIgbWFjIHBsZWFzZSBlbmFibGUgeW91ciBHUFUgYXQ6IE92ZXJyaWRlIHNvZnR3YXJlIHJlbmRlcmluZyBsaXN0OkVuYWJsZSAodGhlIHRvcCBpdGVtKSBpbjogPGEgaHJlZj0nYWJvdXQ6Ly9mbGFncyc+YWJvdXQ6Ly9mbGFnczwvYT4uIE9yIHN3aXRjaCB0byBGaXJlZm94IG9yIFNhZmFyaS5cIjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJwYy5yZWNlaXZlKFdvcmtlckV2ZW50LlJlbW92ZUxvYWRpbmdJbmRpY2F0b3JzLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2FkZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImN4X3dlYmdsX2xvYWRlclwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9hZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFzc2VydE5vdE51bGwobG9hZGVyc1tpXS5wYXJlbnROb2RlKS5yZW1vdmVDaGlsZChsb2FkZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJwYy5yZWNlaXZlKFdvcmtlckV2ZW50LlNldERvY3VtZW50VGl0bGUsICh0aXRsZSkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJwYy5yZWNlaXZlKFdvcmtlckV2ZW50LlNldE1vdXNlQ3Vyc29yLCAoc3R5bGUpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gc3R5bGU7XG4gICAgICAgIH0pO1xuICAgICAgICBycGMucmVjZWl2ZShXb3JrZXJFdmVudC5GdWxsc2NyZWVuLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmJvZHkud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5ib2R5Lm1velJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5tb3pSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcnBjLnJlY2VpdmUoV29ya2VyRXZlbnQuTm9ybWFsc2NyZWVuLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQubW96RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5tb3pFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcnBjLnJlY2VpdmUoV29ya2VyRXZlbnQuVGV4dENvcHlSZXNwb25zZSwgKHRleHRDb3B5UmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0Q29weVJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJwYy5yZWNlaXZlKFdvcmtlckV2ZW50LkVuYWJsZUdsb2JhbEZpbGVEcm9wVGFyZ2V0LCAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsIChldikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGV2LmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgICAgICAvLyBkYXRhVHJhbnNmZXIgaXNuJ3QgZ3VhcmFudGVlZCB0byBleGlzdCBieSBzcGVjLCBzbyBpdCBtdXN0IGJlIGNoZWNrZWRcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci50eXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLnR5cGVzWzBdID09PSBcIkZpbGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJjb3B5XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChycGNJbml0aWFsaXplZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LkRyYWdFbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAocnBjSW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LkRyYWdPdmVyLCB7IHg6IGV2LmNsaWVudFgsIHk6IGV2LmNsaWVudFkgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnbGVhdmVcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAocnBjSW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LkRyYWdMZWF2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChldikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXYuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBBcnJheS5mcm9tKGV2LmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVIYW5kbGVzVG9TZW5kID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVIYW5kbGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUhhbmRsZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZW5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVhZFN0YXJ0OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZWFkRW5kOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZUhhbmRsZXNUb1NlbmQucHVzaChmaWxlSGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZUhhbmRsZXMucHVzaChmaWxlSGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJwY0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LkRyb3AsIHsgZmlsZUhhbmRsZXMsIGZpbGVIYW5kbGVzVG9TZW5kIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcnBjLnJlY2VpdmUoV29ya2VyRXZlbnQuQ2FsbEpzLCAoeyBmbk5hbWUsIHBhcmFtcyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IGpzRnVuY3Rpb25zW2ZuTmFtZV07XG4gICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbF9qcyB3aXRoICR7Zm5OYW1lfSBpcyBub3QgYXZhaWxhYmxlLiBIYXZlIHlvdSByZWdpc3RlcmVkIGl0IHVzaW5nIFxcYHJlZ2lzdGVyQ2FsbEpzQ2FsbGJhY2tzXFxgP2ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuKHRyYW5zZm9ybVBhcmFtc0Zyb21SdXN0KHBhcmFtcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiY3hfd2ViZ2xcIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICBjb25zdCBsb2FkaW5nSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgbG9hZGluZ0luZGljYXRvci5jbGFzc05hbWUgPSBcImN4X3dlYmdsX2xvYWRlclwiO1xuICAgICAgICBsb2FkaW5nSW5kaWNhdG9yLmlubmVySFRNTCA9XG4gICAgICAgICAgICAnPHNwYW4+4pqhPC9zcGFuPjxkaXYgc3R5bGU9XCJjb2xvcjogcmdiYSgyNTUsIDIwMiwgMCwgMC41KTtcIj5Mb2FkaW5n4oCmPC9kaXY+JztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsb2FkaW5nSW5kaWNhdG9yKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAoISgoX2EgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImpzX3Jvb3RcIikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC50YXJnZXQpKSB8fFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QpLmluY2x1ZGVzKFwid3JmbGliUGFuZWxcIikpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAocnBjSW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgcnBjLnNlbmQoV29ya2VyRXZlbnQuQ2FudmFzTW91c2VEb3duLCBtYWtlUnBjTW91c2VFdmVudChldmVudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJwY0luaXRpYWxpemVkKVxuICAgICAgICAgICAgICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LldpbmRvd01vdXNlVXAsIG1ha2VScGNNb3VzZUV2ZW50KGV2ZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgICAgICBpZiAocnBjSW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgcnBjLnNlbmQoV29ya2VyRXZlbnQuV2luZG93TW91c2VNb3ZlLCBtYWtlUnBjTW91c2VFdmVudChldmVudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChycGNJbml0aWFsaXplZClcbiAgICAgICAgICAgICAgICBycGMuc2VuZChXb3JrZXJFdmVudC5XaW5kb3dNb3VzZU91dCwgbWFrZVJwY01vdXNlRXZlbnQoZXZlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChycGNJbml0aWFsaXplZClcbiAgICAgICAgICAgICAgICBycGMuc2VuZChXb3JrZXJFdmVudC5XaW5kb3dUb3VjaFN0YXJ0LCBtYWtlUnBjVG91Y2hFdmVudChldmVudCkpO1xuICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAocnBjSW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgcnBjLnNlbmQoV29ya2VyRXZlbnQuV2luZG93VG91Y2hNb3ZlLCBtYWtlUnBjVG91Y2hFdmVudChldmVudCkpO1xuICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICBjb25zdCB0b3VjaEVuZENhbmNlbExlYXZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHJwY0luaXRpYWxpemVkKVxuICAgICAgICAgICAgICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LldpbmRvd1RvdWNoRW5kQ2FuY2VsTGVhdmUsIG1ha2VScGNUb3VjaEV2ZW50KGV2ZW50KSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdG91Y2hFbmRDYW5jZWxMZWF2ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdG91Y2hFbmRDYW5jZWxMZWF2ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChycGNJbml0aWFsaXplZClcbiAgICAgICAgICAgICAgICBycGMuc2VuZChXb3JrZXJFdmVudC5DYW52YXNXaGVlbCwgbWFrZVJwY1doZWVsRXZlbnQoZXZlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJwY0luaXRpYWxpemVkKVxuICAgICAgICAgICAgICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LldpbmRvd0ZvY3VzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocnBjSW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgcnBjLnNlbmQoV29ya2VyRXZlbnQuV2luZG93Qmx1cik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzTW9iaWxlU2FmYXJpICYmICFpc0FuZHJvaWQpIHtcbiAgICAgICAgICAgIC8vIG1vYmlsZSBrZXlib2FyZHMgYXJlIHVudXNhYmxlIG9uIGEgVUkgbGlrZSB0aGlzXG4gICAgICAgICAgICBjb25zdCB7IHNob3dUZXh0SU1FIH0gPSBtYWtlVGV4dGFyZWEoKHRhRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocnBjSW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJwYy5zZW5kKHRhRXZlbnQudHlwZSwgdGFFdmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJwYy5yZWNlaXZlKFdvcmtlckV2ZW50LlNob3dUZXh0SU1FLCBzaG93VGV4dElNRSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25lIG9mIHRoZXNlIHZhcmlhYmxlcyBzaG91bGQgZ2V0IHNldCwgZGVwZW5kaW5nIG9uIGlmXG4gICAgICAgIC8vIHRoZSBicm93c2VyIHN1cHBvcnRzIE9mZnNjcmVlbkNhbnZhcyBvciBub3QuXG4gICAgICAgIGxldCBvZmZzY3JlZW5DYW52YXM7XG4gICAgICAgIGxldCB3ZWJnbFJlbmRlcmVyO1xuICAgICAgICBmdW5jdGlvbiBnZXRTaXppbmdEYXRhKCkge1xuICAgICAgICAgICAgY29uc3QgY2FuRnVsbHNjcmVlbiA9ICEhKGRvY3VtZW50LmZ1bGxzY3JlZW5FbmFibGVkIHx8XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWQgfHxcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5tb3pGdWxsc2NyZWVuRW5hYmxlZCk7XG4gICAgICAgICAgICBjb25zdCBpc0Z1bGxzY3JlZW4gPSAhIShkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQubW96RnVsbHNjcmVlbkVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogY2FudmFzLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogY2FudmFzLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICBkcGlGYWN0b3I6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIGNhbkZ1bGxzY3JlZW4sXG4gICAgICAgICAgICAgICAgaXNGdWxsc2NyZWVuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblNjcmVlblJlc2l6ZSgpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oSlApOiBTb21lIGRheSBicmluZyB0aGlzIGJhY2s/XG4gICAgICAgICAgICAvLyBpZiAoaXNfYWRkX3RvX2hvbWVzY3JlZW5fc2FmYXJpKSB7IC8vIGV4dHJlbWVseSB1Z2x5LiBidXQgd2hhdGV2ZXIuXG4gICAgICAgICAgICAvLyAgICAgaWYgKHdpbmRvdy5vcmllbnRhdGlvbiA9PSA5MCB8fCB3aW5kb3cub3JpZW50YXRpb24gPT0gLTkwKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGggPSBzY3JlZW4ud2lkdGg7XG4gICAgICAgICAgICAvLyAgICAgICAgIHcgPSBzY3JlZW4uaGVpZ2h0IC0gOTA7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgICAgICB3ID0gc2NyZWVuLndpZHRoO1xuICAgICAgICAgICAgLy8gICAgICAgICBoID0gc2NyZWVuLmhlaWdodCAtIDgwO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemluZ0RhdGEgPSBnZXRTaXppbmdEYXRhKCk7XG4gICAgICAgICAgICBpZiAod2ViZ2xSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHdlYmdsUmVuZGVyZXIucmVzaXplKHNpemluZ0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJwY0luaXRpYWxpemVkKVxuICAgICAgICAgICAgICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LlNjcmVlblJlc2l6ZSwgc2l6aW5nRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gb25TY3JlZW5SZXNpemUoKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgKCkgPT4gb25TY3JlZW5SZXNpemUoKSk7XG4gICAgICAgIGxldCBkcGlGYWN0b3IgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3QgbXFTdHJpbmcgPSBcIihyZXNvbHV0aW9uOiBcIiArIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICsgXCJkcHB4KVwiO1xuICAgICAgICBjb25zdCBtcSA9IG1hdGNoTWVkaWEobXFTdHJpbmcpO1xuICAgICAgICBpZiAobXEgJiYgbXEuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgbXEuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiBvblNjcmVlblJlc2l6ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBvbGwgZm9yIGl0LiB5ZXMuIGl0cyB0ZXJyaWJsZVxuICAgICAgICAgICAgc2VsZi5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICE9IGRwaUZhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBkcGlGYWN0b3IgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgICAgICAgICAgb25TY3JlZW5SZXNpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGJyb3dzZXJzIChlLmcuIFNhZmFyaSAxNS4yKSByZXF1aXJlIFNoYXJlZEFycmF5QnVmZmVycyB0byBiZSBpbml0aWFsaXplZFxuICAgICAgICAvLyBvbiB0aGUgYnJvd3NlcidzIG1haW4gdGhyZWFkOyBzbyB0aGF0J3Mgd2h5IHRoaXMgaGFzIHRvIGhhcHBlbiBoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBhbHNvIGRvIHRoaXMgYmVmb3JlIGluaXRpYWxpemluZyBgV2ViQXNzZW1ibHkuTWVtb3J5YCwgdG8gbWFrZSBzdXJlIHdlIGhhdmVcbiAgICAgICAgLy8gZW5vdWdoIG1lbW9yeSBmb3IgYm90aC4uIChUaGlzIGlzIG1vc3RseSByZWxldmFudCBvbiBtb2JpbGU7IHNlZSBub3RlIGJlbG93LilcbiAgICAgICAgY29uc3QgdGFza1dvcmtlclNhYiA9IGluaXRUYXNrV29ya2VyU2FiKCk7XG4gICAgICAgIGNvbnN0IHRhc2tXb3JrZXJScGMgPSBuZXcgUnBjKG5ldyBXb3JrZXIobmV3IFVSTChcIi4vdGFza193b3JrZXIudHNcIiwgaW1wb3J0Lm1ldGEudXJsKSkpO1xuICAgICAgICB0YXNrV29ya2VyUnBjLnNlbmQoVGFza1dvcmtlckV2ZW50LkluaXQsIHtcbiAgICAgICAgICAgIHRhc2tXb3JrZXJTYWIsXG4gICAgICAgICAgICB3YXNtTWVtb3J5LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW5pdGlhbCBoYXMgdG8gYmUgZXF1YWwgdG8gb3IgaGlnaGVyIHRoYW4gcmVxdWlyZWQgYnkgdGhlIGFwcCAod2hpY2ggYXQgdGhlIHRpbWUgb2Ygd3JpdGluZ1xuICAgICAgICAvLyBpcyBhcm91bmQgMjAgcGFnZXMpLlxuICAgICAgICAvLyBNYXhpbXVtIGhhcyB0byBiZSBlcXVhbCB0byBvciBsb3dlciB0aGFuIHRoYXQgb2YgdGhlIGFwcCwgd2hpY2ggd2UndmUgY3VycmVudGx5IHNldCB0b1xuICAgICAgICAvLyB0aGUgbWF4aW11bSBmb3Igd2FzbTMyICg0R0IpLiBCcm93c2VycyBzaG91bGQgdXNlIHZpcnR1YWwgbWVtb3J5LCBhcyB0byBub3QgYWN0dWFsbHkgdGFrZSB1cFxuICAgICAgICAvLyBhbGwgdGhpcyBzcGFjZSB1bnRpbCByZXF1ZXN0ZWQgYnkgdGhlIGFwcC4gVE9ETyhKUCk6IFdlIG1pZ2h0IG5lZWQgdG8gY2hlY2sgdGhpcyBiZWhhdmlvciBpblxuICAgICAgICAvLyBkaWZmZXJlbnQgYnJvd3NlcnMgYXQgc29tZSBwb2ludCAoaW4gQ2hyb21lIGl0IHNlZW1zIHRvIHdvcmsgZmluZSkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIFNhZmFyaSBvbiBteSBwaG9uZSAoSlApLCB1c2luZyBtYXhpbXVtOjY1NTM1IGNhdXNlcyBhbiBvdXQtb2YtbWVtb3J5IGVycm9yLCBzbyB3ZSBpbnN0ZWFkXG4gICAgICAgIC8vIHRyeSBhIGhhcmRjb2RlZCB2YWx1ZSBvZiB+NDAwTUIuLiBOb3RlIHRoYXQgZXNwZWNpYWxseSBvbiBtb2JpbGUsIGFsbCBvZlxuICAgICAgICAvLyB0aGlzIGlzIHF1aXRlIHRyaWNreTsgc2VlIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL1dlYkFzc2VtYmx5L2Rlc2lnbi9pc3N1ZXMvMTM5N1xuICAgICAgICAvL1xuICAgICAgICAvLyBUT0RPKEpQKTogSXQgbG9va3MgbGlrZSB3aGVuIHVzaW5nIHNoYXJlZCBtZW1vcnksIHRoZSBtYXhpbXVtIG1pZ2h0IGdldCBmdWxseSBhbGxvY2F0ZWQgb25cbiAgICAgICAgLy8gc29tZSBkZXZpY2VzIChtb2JpbGU/KSwgd2hpY2ggbWVhbnMgdGhhdCB0aGVyZSBpcyBsaXR0bGUgcm9vbSBsZWZ0IGZvciBKUyBvYmplY3RzLCBhbmQgaXRcbiAgICAgICAgLy8gbWVhbnMgdGhhdCB0aGUgd2ViIHBhZ2UgaXMgYXQgaGlnaGVyIHJpc2sgb2YgZ2V0dGluZyBldmljdGVkIHdoZW4gc3dpdGNoaW5nIHRhYnMuIFRoZXJlIGFyZSBhXG4gICAgICAgIC8vIGZldyBvcHRpb25zIGhlcmU6XG4gICAgICAgIC8vIDEuIEFsbG93IHRoZSB1c2VyIHRvIHNwZWNpZnkgYSBtYXhpbXVtIGJ5IGhhbmQgZm9yIG1vYmlsZSBpbiBnZW5lcmFsOyBvciBmb3Igc3BlY2lmaWNcbiAgICAgICAgLy8gICAgZGV2aWNlcyAoY3VtYmVyc29tZSEpLlxuICAgICAgICAvLyAyLiBBbGxvdyBzaW5nbGUtdGhyZWFkZWQgb3BlcmF0aW9uLCB3aGVyZSB3ZSBkb24ndCBzcGVjaWZ5IGEgbWF4aW11bSAoYnV0IHJ1biB0aGUgcmlzayBvZlxuICAgICAgICAvLyAgICBnZXR0aW5nIG11Y2ggbGVzcyBtZW1vcnkgdG8gdXNlIGFuZCB0aGVyZWZvcmUgdGhlIGFwcCBjcmFzaGluZzsgc2VlIGFnYWluXG4gICAgICAgIC8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJBc3NlbWJseS9kZXNpZ24vaXNzdWVzLzEzOTcgZm9yIG1vcmUgZGV0YWlscykuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3YXNtTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAgICAgICAgICAgaW5pdGlhbDogNDAsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogNjU1MzUsXG4gICAgICAgICAgICAgICAgc2hhcmVkOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FuJ3QgYWxsb2NhdGUgZnVsbCBXZWJBc3NlbWJseSBtZW1vcnk7IHRyeWluZyB+NDAwTUJcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdhc21NZW1vcnkgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbDogNDAsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IDYwMDAsXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaW5pdGlsaWFsaXplIFdlYkFzc2VtYmx5IG1lbW9yeS4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIE9mZnNjcmVlbkNhbnZhcywgdGhlbiB3ZSdsbCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCB3ZSByZW5kZXIgb25cbiAgICAgICAgLy8gdGhlIGJyb3dzZXIncyBtYWluIHRocmVhZCB1c2luZyBXZWJHTFJlbmRlcmVyLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2Zmc2NyZWVuQ2FudmFzID0gY2FudmFzLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHdlYmdsUmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcihjYW52YXMsIHdhc21NZW1vcnksIGdldFNpemluZ0RhdGEoKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJwYy5zZW5kKFdvcmtlckV2ZW50LlNob3dJbmNvbXBhdGlibGVCcm93c2VyTm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcnBjLnJlY2VpdmUoV29ya2VyRXZlbnQuUnVuV2ViR0wsICh6ZXJkZVBhcnNlclB0cikgPT4ge1xuICAgICAgICAgICAgICAgIHdlYmdsUmVuZGVyZXIucHJvY2Vzc01lc3NhZ2VzKHplcmRlUGFyc2VyUHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB3YXNtTW9kdWxlUHJvbWlzZS50aGVuKCh3YXNtTW9kdWxlKSA9PiB7XG4gICAgICAgICAgICAvLyBUaHJlYWRzIG5lZWQgdG8gYmUgc3Bhd25lZCBvbiB0aGUgYnJvd3NlcidzIG1haW4gdGhyZWFkLCBvdGhlcndpc2UgU2FmYXJpIChhcyBvZiB2ZXJzaW9uIDE1LjIpXG4gICAgICAgICAgICAvLyB0aHJvd3MgZXJyb3JzLlxuICAgICAgICAgICAgY29uc3QgYXN5bmNXb3JrZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3QgdGhyZWFkU3Bhd24gPSAoeyBjdHhQdHIsIHRsc0FuZFN0YWNrRGF0YSwgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIobmV3IFVSTChcIi4vYXN5bmNfd29ya2VyLnRzXCIsIGltcG9ydC5tZXRhLnVybCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtlckVycm9ySGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFzeW5jIHdvcmtlciBlcnJvciBldmVudDogXCIsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdvcmtlci5vbmVycm9yID0gd29ya2VyRXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICAgIHdvcmtlci5vbm1lc3NhZ2VlcnJvciA9IHdvcmtlckVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrZXJScGMgPSBuZXcgUnBjKHdvcmtlcik7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB3b3JrZXIgdG8gYW4gYXJyYXkgb2Ygd29ya2VycywgdG8gcHJldmVudCB0aGVtIGdldHRpbmcga2lsbGVkIHdoZW5cbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uIGluIEZpcmVmb3g7IHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTkyMjI3XG4gICAgICAgICAgICAgICAgYXN5bmNXb3JrZXJzLmFkZCh3b3JrZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICAgICAgICBycGMuc2VuZChXb3JrZXJFdmVudC5CaW5kTWFpbldvcmtlclBvcnQsIGNoYW5uZWwucG9ydDEsIFtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5wb3J0MSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB3b3JrZXJScGMucmVjZWl2ZShBc3luY1dvcmtlckV2ZW50LlRocmVhZFNwYXduLCB0aHJlYWRTcGF3bik7XG4gICAgICAgICAgICAgICAgd29ya2VyUnBjXG4gICAgICAgICAgICAgICAgICAgIC5zZW5kKEFzeW5jV29ya2VyRXZlbnQuUnVuLCB7XG4gICAgICAgICAgICAgICAgICAgIHdhc21Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIG1lbW9yeTogd2FzbU1lbW9yeSxcbiAgICAgICAgICAgICAgICAgICAgdGFza1dvcmtlclNhYixcbiAgICAgICAgICAgICAgICAgICAgY3R4UHRyLFxuICAgICAgICAgICAgICAgICAgICBmaWxlSGFuZGxlcyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVyaTogZG9jdW1lbnQuYmFzZVVSSSxcbiAgICAgICAgICAgICAgICAgICAgdGxzQW5kU3RhY2tEYXRhLFxuICAgICAgICAgICAgICAgICAgICBtYWluV29ya2VyUG9ydDogY2hhbm5lbC5wb3J0MixcbiAgICAgICAgICAgICAgICB9LCBbY2hhbm5lbC5wb3J0Ml0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYXN5bmMgd29ya2VyIGZhaWxlZFwiLCBlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNXb3JrZXJzLmRlbGV0ZSh3b3JrZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJwYy5yZWNlaXZlKFdvcmtlckV2ZW50LlRocmVhZFNwYXduLCB0aHJlYWRTcGF3bik7XG4gICAgICAgICAgICBycGNcbiAgICAgICAgICAgICAgICAuc2VuZChXb3JrZXJFdmVudC5Jbml0LCB7XG4gICAgICAgICAgICAgICAgd2FzbU1vZHVsZSxcbiAgICAgICAgICAgICAgICBvZmZzY3JlZW5DYW52YXMsXG4gICAgICAgICAgICAgICAgc2l6aW5nRGF0YTogZ2V0U2l6aW5nRGF0YSgpLFxuICAgICAgICAgICAgICAgIGJhc2VVcmk6IGRvY3VtZW50LmJhc2VVUkksXG4gICAgICAgICAgICAgICAgbWVtb3J5OiB3YXNtTWVtb3J5LFxuICAgICAgICAgICAgICAgIHRhc2tXb3JrZXJTYWIsXG4gICAgICAgICAgICB9LCBvZmZzY3JlZW5DYW52YXMgPyBbb2Zmc2NyZWVuQ2FudmFzXSA6IFtdKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBycGNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgb25TY3JlZW5SZXNpemUoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgbG9hZGVyKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBsb2FkZXIpO1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./wrf_wasm_runtime.ts\n");

/***/ }),

/***/ "./zerde.ts":
/*!******************!*\
  !*** ./zerde.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZerdeBuilder\": () => (/* binding */ ZerdeBuilder),\n/* harmony export */   \"ZerdeParser\": () => (/* binding */ ZerdeParser)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./types.ts\");\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\n// Zerde is our lightweight manual serialization/deserialization system.\n//\n// Keep in sync with zerde.rs, and see there for more information.\n\n// Construct a buffer that can be read in Rust, using the corresponding `ZerderParser` struct in Rust.\nclass ZerdeBuilder {\n    constructor({ buffer, byteOffset, slots, growCallback, }) {\n        this._buffer = buffer;\n        this._byteOffset = byteOffset;\n        this._slots = slots;\n        this._growCallback = growCallback;\n        this._used = 2; // Skip 8 byte header which contains the size.\n        this._updateRefs();\n    }\n    _updateRefs() {\n        this._f32 = new Float32Array(this._buffer, this._byteOffset, this._slots);\n        this._u32 = new Uint32Array(this._buffer, this._byteOffset, this._slots);\n        this._f64 = new Float64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64 = new BigUint64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64[0] = BigInt(this._slots) * BigInt(4); // Write size to header.\n    }\n    _fit(slots) {\n        if (this._used + slots > this._slots) {\n            let newSlots = Math.max(this._used + slots, this._slots * 2); // Exponential growth\n            if (newSlots & 1)\n                newSlots++; // 64-bit align it\n            const newBytes = newSlots * 4;\n            const { buffer, byteOffset } = this._growCallback(this._buffer, this._byteOffset, newBytes);\n            this._buffer = buffer;\n            this._byteOffset = byteOffset;\n            this._slots = newSlots;\n            this._updateRefs();\n        }\n        const pos = this._used;\n        this._used += slots;\n        return pos;\n    }\n    sendF32(value) {\n        const pos = this._fit(1);\n        this._f32[pos] = value;\n    }\n    sendU32(value) {\n        const pos = this._fit(1);\n        this._u32[pos] = value;\n    }\n    sendF64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._f64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._f64[pos >> 1] = value;\n        }\n    }\n    sendU64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._u64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._u64[pos >> 1] = value;\n        }\n    }\n    sendString(str) {\n        let pos = this._fit(str.length + 1);\n        this._u32[pos++] = str.length;\n        for (let i = 0; i < str.length; i++) {\n            this._u32[pos++] = str.charCodeAt(i);\n        }\n    }\n    getData() {\n        return { buffer: this._buffer, byteOffset: this._byteOffset };\n    }\n}\nclass ZerdeParser {\n    constructor(memory, zerdePtr) {\n        this._memory = memory;\n        // set up local shortcuts to the zerde memory chunk for faster parsing\n        this._usedSlots = 2; // skip the 8 byte header\n        this._f32 = new Float32Array(this._memory.buffer, zerdePtr);\n        this._u32 = new Uint32Array(this._memory.buffer, zerdePtr);\n        this._f64 = new Float64Array(this._memory.buffer, zerdePtr);\n        this._u64 = new BigUint64Array(this._memory.buffer, zerdePtr);\n    }\n    parseU32() {\n        return this._u32[this._usedSlots++];\n    }\n    parseF32() {\n        return this._f32[this._usedSlots++];\n    }\n    parseF64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._f64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseU64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._u64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseString() {\n        let str = \"\";\n        const len = this.parseU32();\n        for (let i = 0; i < len; i++) {\n            const c = this.parseU32();\n            if (c != 0)\n                str += String.fromCharCode(c);\n        }\n        return str;\n    }\n    parseU8Slice() {\n        const u8Len = this.parseU32();\n        const len = u8Len >> 2;\n        const data = new Uint8Array(u8Len);\n        const spare = u8Len & 3;\n        for (let i = 0; i < len; i++) {\n            const u8Pos = i << 2;\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n            data[u8Pos + 3] = (u32 >> 24) & 0xff;\n        }\n        const u8Pos = len << 2;\n        if (spare == 1) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n        }\n        else if (spare == 2) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n        }\n        else if (spare == 3) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n        }\n        return data;\n    }\n    parseWrfParams() {\n        const len = this.parseU32();\n        const params = [];\n        for (let i = 0; i < len; ++i) {\n            const paramType = this.parseU32();\n            if (paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.String) {\n                params.push(this.parseString());\n            }\n            else if (paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyU8Buffer ||\n                paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.ReadOnlyF32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const arcPtr = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    arcPtr,\n                    readonly: true,\n                });\n            }\n            else if (paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.U8Buffer ||\n                paramType === _types__WEBPACK_IMPORTED_MODULE_0__.WrfParamType.F32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const bufferCap = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    bufferCap,\n                    readonly: false,\n                });\n            }\n            else {\n                throw new Error(`Unknown WrfParam type: ${paramType}`);\n            }\n        }\n        return params;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi96ZXJkZS50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3plcmRlLnRzPzNjNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFplcmRlIGlzIG91ciBsaWdodHdlaWdodCBtYW51YWwgc2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRpb24gc3lzdGVtLlxuLy9cbi8vIEtlZXAgaW4gc3luYyB3aXRoIHplcmRlLnJzLCBhbmQgc2VlIHRoZXJlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuaW1wb3J0IHsgV3JmUGFyYW1UeXBlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbi8vIENvbnN0cnVjdCBhIGJ1ZmZlciB0aGF0IGNhbiBiZSByZWFkIGluIFJ1c3QsIHVzaW5nIHRoZSBjb3JyZXNwb25kaW5nIGBaZXJkZXJQYXJzZXJgIHN0cnVjdCBpbiBSdXN0LlxuZXhwb3J0IGNsYXNzIFplcmRlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoeyBidWZmZXIsIGJ5dGVPZmZzZXQsIHNsb3RzLCBncm93Q2FsbGJhY2ssIH0pIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLl9ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgdGhpcy5fc2xvdHMgPSBzbG90cztcbiAgICAgICAgdGhpcy5fZ3Jvd0NhbGxiYWNrID0gZ3Jvd0NhbGxiYWNrO1xuICAgICAgICB0aGlzLl91c2VkID0gMjsgLy8gU2tpcCA4IGJ5dGUgaGVhZGVyIHdoaWNoIGNvbnRhaW5zIHRoZSBzaXplLlxuICAgICAgICB0aGlzLl91cGRhdGVSZWZzKCk7XG4gICAgfVxuICAgIF91cGRhdGVSZWZzKCkge1xuICAgICAgICB0aGlzLl9mMzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5fYnl0ZU9mZnNldCwgdGhpcy5fc2xvdHMpO1xuICAgICAgICB0aGlzLl91MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0LCB0aGlzLl9zbG90cyk7XG4gICAgICAgIHRoaXMuX2Y2NCA9IG5ldyBGbG9hdDY0QXJyYXkodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0LCB0aGlzLl9zbG90cyA+PiAxKTtcbiAgICAgICAgdGhpcy5fdTY0ID0gbmV3IEJpZ1VpbnQ2NEFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5fYnl0ZU9mZnNldCwgdGhpcy5fc2xvdHMgPj4gMSk7XG4gICAgICAgIHRoaXMuX3U2NFswXSA9IEJpZ0ludCh0aGlzLl9zbG90cykgKiBCaWdJbnQoNCk7IC8vIFdyaXRlIHNpemUgdG8gaGVhZGVyLlxuICAgIH1cbiAgICBfZml0KHNsb3RzKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VkICsgc2xvdHMgPiB0aGlzLl9zbG90cykge1xuICAgICAgICAgICAgbGV0IG5ld1Nsb3RzID0gTWF0aC5tYXgodGhpcy5fdXNlZCArIHNsb3RzLCB0aGlzLl9zbG90cyAqIDIpOyAvLyBFeHBvbmVudGlhbCBncm93dGhcbiAgICAgICAgICAgIGlmIChuZXdTbG90cyAmIDEpXG4gICAgICAgICAgICAgICAgbmV3U2xvdHMrKzsgLy8gNjQtYml0IGFsaWduIGl0XG4gICAgICAgICAgICBjb25zdCBuZXdCeXRlcyA9IG5ld1Nsb3RzICogNDtcbiAgICAgICAgICAgIGNvbnN0IHsgYnVmZmVyLCBieXRlT2Zmc2V0IH0gPSB0aGlzLl9ncm93Q2FsbGJhY2sodGhpcy5fYnVmZmVyLCB0aGlzLl9ieXRlT2Zmc2V0LCBuZXdCeXRlcyk7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB0aGlzLl9ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX3Nsb3RzID0gbmV3U2xvdHM7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSZWZzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fdXNlZDtcbiAgICAgICAgdGhpcy5fdXNlZCArPSBzbG90cztcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc2VuZEYzMih2YWx1ZSkge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9maXQoMSk7XG4gICAgICAgIHRoaXMuX2YzMltwb3NdID0gdmFsdWU7XG4gICAgfVxuICAgIHNlbmRVMzIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fZml0KDEpO1xuICAgICAgICB0aGlzLl91MzJbcG9zXSA9IHZhbHVlO1xuICAgIH1cbiAgICBzZW5kRjY0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VkICYgMSkge1xuICAgICAgICAgICAgLy8gNjQtYml0IGFsaWdubWVudC5cbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2ZpdCgzKSArIDE7XG4gICAgICAgICAgICB0aGlzLl9mNjRbcG9zID4+IDFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9maXQoMik7XG4gICAgICAgICAgICB0aGlzLl9mNjRbcG9zID4+IDFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZFU2NCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fdXNlZCAmIDEpIHtcbiAgICAgICAgICAgIC8vIDY0LWJpdCBhbGlnbm1lbnQuXG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9maXQoMykgKyAxO1xuICAgICAgICAgICAgdGhpcy5fdTY0W3BvcyA+PiAxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fZml0KDIpO1xuICAgICAgICAgICAgdGhpcy5fdTY0W3BvcyA+PiAxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRTdHJpbmcoc3RyKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLl9maXQoc3RyLmxlbmd0aCArIDEpO1xuICAgICAgICB0aGlzLl91MzJbcG9zKytdID0gc3RyLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3UzMltwb3MrK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4geyBidWZmZXI6IHRoaXMuX2J1ZmZlciwgYnl0ZU9mZnNldDogdGhpcy5fYnl0ZU9mZnNldCB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBaZXJkZVBhcnNlciB7XG4gICAgY29uc3RydWN0b3IobWVtb3J5LCB6ZXJkZVB0cikge1xuICAgICAgICB0aGlzLl9tZW1vcnkgPSBtZW1vcnk7XG4gICAgICAgIC8vIHNldCB1cCBsb2NhbCBzaG9ydGN1dHMgdG8gdGhlIHplcmRlIG1lbW9yeSBjaHVuayBmb3IgZmFzdGVyIHBhcnNpbmdcbiAgICAgICAgdGhpcy5fdXNlZFNsb3RzID0gMjsgLy8gc2tpcCB0aGUgOCBieXRlIGhlYWRlclxuICAgICAgICB0aGlzLl9mMzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX21lbW9yeS5idWZmZXIsIHplcmRlUHRyKTtcbiAgICAgICAgdGhpcy5fdTMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX21lbW9yeS5idWZmZXIsIHplcmRlUHRyKTtcbiAgICAgICAgdGhpcy5fZjY0ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLl9tZW1vcnkuYnVmZmVyLCB6ZXJkZVB0cik7XG4gICAgICAgIHRoaXMuX3U2NCA9IG5ldyBCaWdVaW50NjRBcnJheSh0aGlzLl9tZW1vcnkuYnVmZmVyLCB6ZXJkZVB0cik7XG4gICAgfVxuICAgIHBhcnNlVTMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdTMyW3RoaXMuX3VzZWRTbG90cysrXTtcbiAgICB9XG4gICAgcGFyc2VGMzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mMzJbdGhpcy5fdXNlZFNsb3RzKytdO1xuICAgIH1cbiAgICBwYXJzZUY2NCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZWRTbG90cyAmIDEpIHtcbiAgICAgICAgICAgIC8vIDY0LWJpdCBhbGlnbm1lbnQuXG4gICAgICAgICAgICB0aGlzLl91c2VkU2xvdHMrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzLl9mNjRbdGhpcy5fdXNlZFNsb3RzID4+IDFdO1xuICAgICAgICB0aGlzLl91c2VkU2xvdHMgKz0gMjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcGFyc2VVNjQoKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VkU2xvdHMgJiAxKSB7XG4gICAgICAgICAgICAvLyA2NC1iaXQgYWxpZ25tZW50LlxuICAgICAgICAgICAgdGhpcy5fdXNlZFNsb3RzKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5fdTY0W3RoaXMuX3VzZWRTbG90cyA+PiAxXTtcbiAgICAgICAgdGhpcy5fdXNlZFNsb3RzICs9IDI7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHBhcnNlU3RyaW5nKCkge1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgaWYgKGMgIT0gMClcbiAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBwYXJzZVU4U2xpY2UoKSB7XG4gICAgICAgIGNvbnN0IHU4TGVuID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICBjb25zdCBsZW4gPSB1OExlbiA+PiAyO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodThMZW4pO1xuICAgICAgICBjb25zdCBzcGFyZSA9IHU4TGVuICYgMztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdThQb3MgPSBpIDw8IDI7XG4gICAgICAgICAgICBjb25zdCB1MzIgPSB0aGlzLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgMF0gPSB1MzIgJiAweGZmO1xuICAgICAgICAgICAgZGF0YVt1OFBvcyArIDFdID0gKHUzMiA+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgMl0gPSAodTMyID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgM10gPSAodTMyID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdThQb3MgPSBsZW4gPDwgMjtcbiAgICAgICAgaWYgKHNwYXJlID09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHUzMiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAwXSA9IHUzMiAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3BhcmUgPT0gMikge1xuICAgICAgICAgICAgY29uc3QgdTMyID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgZGF0YVt1OFBvcyArIDBdID0gdTMyICYgMHhmZjtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAxXSA9ICh1MzIgPj4gOCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNwYXJlID09IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUzMiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAwXSA9IHUzMiAmIDB4ZmY7XG4gICAgICAgICAgICBkYXRhW3U4UG9zICsgMV0gPSAodTMyID4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIGRhdGFbdThQb3MgKyAyXSA9ICh1MzIgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcGFyc2VXcmZQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgIGlmIChwYXJhbVR5cGUgPT09IFdyZlBhcmFtVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh0aGlzLnBhcnNlU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1UeXBlID09PSBXcmZQYXJhbVR5cGUuUmVhZE9ubHlVOEJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgIHBhcmFtVHlwZSA9PT0gV3JmUGFyYW1UeXBlLlJlYWRPbmx5RjMyQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyUHRyID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckxlbiA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmNQdHIgPSB0aGlzLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclB0cixcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyTGVuLFxuICAgICAgICAgICAgICAgICAgICBhcmNQdHIsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1UeXBlID09PSBXcmZQYXJhbVR5cGUuVThCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICBwYXJhbVR5cGUgPT09IFdyZlBhcmFtVHlwZS5GMzJCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJQdHIgPSB0aGlzLnBhcnNlVTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyTGVuID0gdGhpcy5wYXJzZVUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckNhcCA9IHRoaXMucGFyc2VVMzIoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUHRyLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXJMZW4sXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckNhcCxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFdyZlBhcmFtIHR5cGU6ICR7cGFyYW1UeXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./zerde.ts\n");

/***/ }),

/***/ "./zerde_keyboard_handlers.ts":
/*!************************************!*\
  !*** ./zerde_keyboard_handlers.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"packKeyModifier\": () => (/* binding */ packKeyModifier),\n/* harmony export */   \"zerdeKeyboardHandlers\": () => (/* binding */ zerdeKeyboardHandlers)\n/* harmony export */ });\n// Copyright (c) 2021-present, Cruise LLC\n//\n// This source code is licensed under the Apache License, Version 2.0,\n// found in the LICENSE-APACHE file in the root directory of this source tree.\n// You may not use this file except in compliance with the License.\nfunction packKeyModifier(e) {\n    return ((e.shiftKey ? 1 : 0) |\n        (e.ctrlKey ? 2 : 0) |\n        (e.altKey ? 4 : 0) |\n        (e.metaKey ? 8 : 0));\n}\nconst zerdeKeyboardHandlers = {\n    keyDown(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(12);\n        zerdeBuilder.sendU32(data.event.keyCode);\n        zerdeBuilder.sendU32(data.event.repeat ? 1 : 0);\n        zerdeBuilder.sendU32(packKeyModifier(data.event));\n        zerdeBuilder.sendF64(performance.now() / 1000.0);\n    },\n    keyUp(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(13);\n        zerdeBuilder.sendU32(data.event.keyCode);\n        zerdeBuilder.sendU32(data.event.repeat ? 1 : 0);\n        zerdeBuilder.sendU32(packKeyModifier(data.event));\n        zerdeBuilder.sendF64(performance.now() / 1000.0);\n    },\n    textInput(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(14);\n        zerdeBuilder.sendU32(data.wasPaste ? 1 : 0),\n            zerdeBuilder.sendU32(data.replaceLast ? 1 : 0),\n            zerdeBuilder.sendString(data.input);\n    },\n    textCopy(zerdeBuilder) {\n        zerdeBuilder.sendU32(17);\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi96ZXJkZV9rZXlib2FyZF9oYW5kbGVycy50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dyZi8uL3plcmRlX2tleWJvYXJkX2hhbmRsZXJzLnRzPzk2NDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQsIENydWlzZSBMTENcbi8vXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRS1BUEFDSEUgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbmV4cG9ydCBmdW5jdGlvbiBwYWNrS2V5TW9kaWZpZXIoZSkge1xuICAgIHJldHVybiAoKGUuc2hpZnRLZXkgPyAxIDogMCkgfFxuICAgICAgICAoZS5jdHJsS2V5ID8gMiA6IDApIHxcbiAgICAgICAgKGUuYWx0S2V5ID8gNCA6IDApIHxcbiAgICAgICAgKGUubWV0YUtleSA/IDggOiAwKSk7XG59XG5leHBvcnQgY29uc3QgemVyZGVLZXlib2FyZEhhbmRsZXJzID0ge1xuICAgIGtleURvd24oemVyZGVCdWlsZGVyLCBkYXRhKSB7XG4gICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKDEyKTtcbiAgICAgICAgemVyZGVCdWlsZGVyLnNlbmRVMzIoZGF0YS5ldmVudC5rZXlDb2RlKTtcbiAgICAgICAgemVyZGVCdWlsZGVyLnNlbmRVMzIoZGF0YS5ldmVudC5yZXBlYXQgPyAxIDogMCk7XG4gICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKHBhY2tLZXlNb2RpZmllcihkYXRhLmV2ZW50KSk7XG4gICAgICAgIHplcmRlQnVpbGRlci5zZW5kRjY0KHBlcmZvcm1hbmNlLm5vdygpIC8gMTAwMC4wKTtcbiAgICB9LFxuICAgIGtleVVwKHplcmRlQnVpbGRlciwgZGF0YSkge1xuICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMigxMyk7XG4gICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKGRhdGEuZXZlbnQua2V5Q29kZSk7XG4gICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKGRhdGEuZXZlbnQucmVwZWF0ID8gMSA6IDApO1xuICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMihwYWNrS2V5TW9kaWZpZXIoZGF0YS5ldmVudCkpO1xuICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZEY2NChwZXJmb3JtYW5jZS5ub3coKSAvIDEwMDAuMCk7XG4gICAgfSxcbiAgICB0ZXh0SW5wdXQoemVyZGVCdWlsZGVyLCBkYXRhKSB7XG4gICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKDE0KTtcbiAgICAgICAgemVyZGVCdWlsZGVyLnNlbmRVMzIoZGF0YS53YXNQYXN0ZSA/IDEgOiAwKSxcbiAgICAgICAgICAgIHplcmRlQnVpbGRlci5zZW5kVTMyKGRhdGEucmVwbGFjZUxhc3QgPyAxIDogMCksXG4gICAgICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFN0cmluZyhkYXRhLmlucHV0KTtcbiAgICB9LFxuICAgIHRleHRDb3B5KHplcmRlQnVpbGRlcikge1xuICAgICAgICB6ZXJkZUJ1aWxkZXIuc2VuZFUzMigxNyk7XG4gICAgfSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./zerde_keyboard_handlers.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"wrf_runtime": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./wrf_runtime.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});